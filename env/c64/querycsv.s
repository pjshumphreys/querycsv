;
; File generated by cc65 v 2.15
;
	.fopt		compiler,"cc65 v 2.15"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.forceimport	__STARTUP__
	.forceimport	initmainargs
	.import		_stdout
	.import		_stderr
	.import		_fclose
	.import		_feof
	.import		_fflush
	.import		_fgetc
	.import		_fopen
	.import		_fprintf
	.import		_fputs
	.import		_sprintf
	.import		_ungetc
	.import		_vsnprintf
	.import		_vsprintf
	.import		_malloc
	.import		_calloc
	.import		_realloc
	.import		_free
	.import		_exit
	.import		_getenv
	.import		_putenv
	.import		_strcat
	.import		_strcmp
	.import		_strcpy
	.import		_strlen
	.import		_strncat
	.import		_strstr
	.import		_memcpy
	.export		_strdup
	.import		_setlocale
	.import		_gmtime
	.import		_localtime
	.import		_strftime
	.import		_time
	.import		__ctof
	.import		__fdiv
	.import		__fmul
	.import		__fadd
	.import		__fsub
	.import		__fneg
	.import		__ftostr
	.import		__fcmp
	.import		_strtod
	.import		_in_word_set
	.import		_normaliseAndGet
	.import		_isCombiningChar
	.import		_isInHash2
	.export		_getValue
	.export		_parse_orderingSpec
	.export		_parse_scalarExpColumnRef
	.export		_parse_columnRefUnsuccessful
	.export		_hash_createTable
	.export		_parse_tableFactor
	.export		_readParams
	.export		_endOfFile
	.export		_strNumberCompare
	.export		_getUnicodeChar
	.export		_outputHeader
	.export		_combiningCharCompare
	.export		_getCalculatedColumns
	.export		_main
	.export		_groupResults
	.export		_getCsvColumn
	.export		_parse_whereClause
	.export		_parse_groupingSpec
	.export		_cleanup_inputColumns
	.export		_cleanup_atomList
	.export		_exp_uminus
	.export		_hash_freeTable
	.export		_parse_scalarExp
	.export		_cleanup_columnReferences
	.export		_parse_inPredicate
	.export		_exp_divide
	.export		_strCompare
	.export		_strReplace
	.export		_parse_functionRef
	.export		_parse_newOutputColumn
	.export		_d_strftime
	.export		_getColumnValue
	.export		_cleanup_expression
	.export		_parse_atomCommaList
	.export		_cleanup_query
	.export		_strRTrim
	.export		_walkRejectRecord
	.export		_getColumnCount
	.export		_parse_expCommaList
	.export		_parse_functionRefStar
	.export		_myfseek
	.export		_tree_walkAndCleanup
	.export		_runQuery
	.export		_hash_compare
	.export		_hash_lookupString
	.export		_reallocMsg
	.export		_consumeCombiningChars
	.export		_getNextRecordOffset
	.export		_getMatchingRecord
	.export		_stringGet
	.export		_cleanup_inputTables
	.export		_outputResult
	.export		_recordCompare
	.export		_parse_scalarExpLiteral
	.export		_strAppendUTF8
	.export		_getCurrentDate
	.export		_needsEscaping
	.export		_updateRunningCounts
	.export		_yyerror
	.export		_readQuery
	.export		_tree_insert
	.export		_d_tztime
	.export		_getFirstRecord
	.export		_groupResultsInner
	.export		_skipBom
	.export		_getUnicodeCharFast
	.export		_runCommand
	.export		_getLookupTableEntry
	.export		_isNumberWithGetByteLength
	.export		_cleanup_resultColumns
	.export		_strAppend
	.export		_d_sprintf
	.export		_hash_addString
	.export		_strFree
	.export		_getGroupedColumns
	.export		_yyerror2
	.export		_cleanup_orderByClause
	.export		_cleanup_matchValues
	.import		_yyparse
	.import		_yylex_init
	.import		_yylex_destroy
	.import		_yyset_in

.segment	"DATA"

_numberEntry:
	.word	$0000
	.word	$007F
	.word	$0000
	.word	$0000

.segment	"RODATA"

L119C:
	.byte	$D0,$41,$52,$53,$49,$4E,$47,$20,$54,$48,$45,$20,$49,$4E,$50,$55
	.byte	$54,$20,$46,$49,$4C,$45,$20,$55,$53,$45,$44,$20,$55,$50,$20,$41
	.byte	$4C,$4C,$20,$4D,$45,$4D,$4F,$52,$59,$20,$53,$54,$4F,$52,$41,$47
	.byte	$45,$20,$53,$50,$41,$43,$45,$0D,$00
L112E	:=	L119C+0
L1135:
	.byte	$C1,$4E,$20,$55,$4E,$4B,$4E,$4F,$57,$4E,$20,$45,$52,$52,$4F,$52
	.byte	$20,$4F,$43,$43,$55,$52,$52,$45,$44,$20,$57,$48,$45,$4E,$20,$50
	.byte	$41,$52,$53,$49,$4E,$47,$20,$54,$48,$45,$20,$49,$4E,$50,$55,$54
	.byte	$20,$46,$49,$4C,$45,$0D,$00
L11A3	:=	L1135+0
L1194:
	.byte	$C1,$20,$53,$59,$4E,$54,$41,$58,$20,$45,$52,$52,$4F,$52,$20,$4F
	.byte	$43,$43,$55,$52,$52,$45,$44,$20,$57,$48,$45,$4E,$20,$50,$41,$52
	.byte	$53,$49,$4E,$47,$20,$54,$48,$45,$20,$49,$4E,$50,$55,$54,$20,$46
	.byte	$49,$4C,$45,$0D,$00
L1126	:=	L1194+0
L04E2:
	.byte	$CE,$4F,$20,$46,$49,$4C,$45,$20,$4E,$41,$4D,$45,$20,$53,$50,$45
	.byte	$43,$49,$46,$45,$44,$0D,$D5,$53,$41,$47,$45,$3A,$20,$51,$55,$45
	.byte	$52,$59,$43,$53,$56,$20,$5B,$46,$49,$4C,$45,$4E,$41,$4D,$45,$5D
	.byte	$00
L09D5:
	.byte	$C3,$4F,$55,$4C,$44,$4E,$27,$54,$20,$53,$45,$45,$4B,$20,$54,$4F
	.byte	$20,$53,$50,$45,$43,$49,$46,$49,$45,$44,$20,$46,$49,$4C,$45,$20
	.byte	$4F,$46,$46,$53,$45,$54,$0D,$00
L0D3D	:=	L09D5+0
L147C:
	.byte	$D5,$4E,$54,$45,$52,$4D,$49,$4E,$41,$54,$45,$44,$20,$53,$54,$52
	.byte	$49,$4E,$47,$20,$4F,$4E,$20,$4C,$49,$4E,$45,$20,$25,$4C,$44,$20
	.byte	$28,$25,$53,$29,$0D,$00
L0CCC:
	.byte	$C3,$4F,$55,$4C,$44,$20,$4E,$4F,$54,$20,$41,$4C,$4C,$4F,$43,$41
	.byte	$54,$45,$20,$4E,$45,$45,$44,$45,$44,$20,$4D,$45,$4D,$4F,$52,$59
	.byte	$0D,$00
L0B67	:=	L0CCC+0
L0B48	:=	L0CCC+0
L0B56	:=	L0CCC+0
L04D5:
	.byte	$D4,$DA,$3D,$C7,$CD,$D4,$30,$C2,$D3,$D4,$2C,$CD,$33,$2E,$35,$2E
	.byte	$30,$2F,$31,$2C,$CD,$31,$30,$2E,$35,$2E,$30,$2F,$32,$00
L0934:
	.byte	$43,$41,$4E,$27,$54,$20,$41,$47,$47,$52,$45,$47,$41,$54,$45,$20
	.byte	$41,$4E,$20,$41,$47,$47,$52,$45,$47,$41,$54,$45,$00
L0432:
	.byte	$4F,$50,$45,$4E,$49,$4E,$47,$20,$4F,$55,$54,$50,$55,$54,$20,$46
	.byte	$49,$4C,$45,$20,$46,$41,$49,$4C,$45,$44,$00
L0F57:
	.byte	$25,$25,$D9,$2D,$25,$25,$4D,$2D,$25,$25,$44,$D4,$25,$25,$C8,$3A
	.byte	$25,$25,$CD,$3A,$25,$25,$D3,$25,$53,$00
L0B15:
	.byte	$C3,$4F,$55,$4C,$44,$4E,$27,$54,$20,$4F,$50,$45,$4E,$20,$49,$4E
	.byte	$50,$55,$54,$20,$46,$49,$4C,$45,$0D,$00
L01F7	:=	L0B15+0
L09C6	:=	L0B15+0
L1180	:=	L0B15+0
L10EF	:=	L0B15+0
L0219	:=	L0B15+0
L0D32	:=	L0B15+0
L0BEE:
	.byte	$4F,$4E,$4C,$59,$20,$43,$4F,$55,$4E,$54,$28,$2A,$29,$20,$49,$53
	.byte	$20,$56,$41,$4C,$49,$44,$00
L0F6B:
	.byte	$53,$54,$52,$46,$54,$49,$4D,$45,$A4,$44,$20,$46,$41,$49,$4C,$45
	.byte	$44,$0D,$00
L0F5C:
	.byte	$53,$50,$52,$49,$4E,$54,$46,$A4,$44,$20,$46,$41,$49,$4C,$45,$44
	.byte	$0D,$00
L0F4C:
	.byte	$54,$5A,$54,$49,$4D,$45,$A4,$44,$20,$46,$41,$49,$4C,$45,$44,$0D
	.byte	$00
L0B51:
	.byte	$A4,$C3,$4F,$4C,$55,$4D,$4E,$20,$25,$44,$00
L04D9:
	.byte	$45,$4E,$A4,$C7,$C2,$2E,$D5,$D4,$C6,$38,$00
L1209:
	.byte	$2B,$25,$30,$32,$49,$25,$30,$32,$49,$00
L04CD:
	.byte	$D4,$CD,$D0,$C4,$C9,$D2,$3D,$3A,$00
L0738:
	.byte	$C9,$4E,$46,$49,$4E,$49,$54,$59,$00
L1282:
	.byte	$25,$30,$33,$49,$25,$30,$32,$49,$00
L04C9:
	.byte	$D4,$CD,$D0,$C4,$C9,$D2,$00
L1034:
	.byte	$25,$53,$25,$53,$00
L102B	:=	L1034+0
L011E	:=	L1034+0
L0443:
	.byte	$EF,$BB,$BF,$00
L0D4D:
	.byte	$25,$4C,$44,$00
L0267:
	.byte	$A4,$25,$53,$00
L0C97	:=	L0B51+8
L1472	:=	L0B51+8
L146A	:=	L0B51+8
L0E33:
	.byte	$2C,$20,$00
L0E5E:
	.byte	$BF,$CE,$00
L0E6A:
	.byte	$22,$22,$00
L12EB:
	.byte	$52,$42,$00
L0E76	:=	L0E6A+0
L12D2	:=	L12EB+0
L0421	:=	L0E33+0
L0427:
	.byte	$0A,$0D,$00
L0B62	:=	L0B51+8
L0B26	:=	L0B51+8
L113C	:=	L0427+0
L0F85	:=	L0E5E+0
L0F88	:=	L0E5E+0
L04D1:
	.byte	$D4,$DA,$00
L042C:
	.byte	$57,$42,$00
L01E8	:=	L12EB+0
L0439	:=	L119C+55
L0E30:
	.byte	$2C,$00
L0E74	:=	L0E6A+1
L0E7A	:=	L0E6A+1
L065A:
	.byte	$30,$00
L113F	:=	L119C+55
L117A:
	.byte	$52,$00
L041E	:=	L0E30+0
L0E81	:=	L0E6A+1
L10E9	:=	L117A+0
L0059	:=	L119C+56
L008C	:=	L119C+56
L0BF8	:=	L119C+56
L009F	:=	L119C+56
L00AE	:=	L119C+56
L04AF	:=	L119C+56
L0DA4	:=	L119C+56
L0066	:=	L119C+56
L001A	:=	L119C+56

; ---------------------------------------------------------------
; __near__ unsigned char * __near__ __fastcall__ strdup (__near__ const unsigned char *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_strdup: near

.segment	"CODE"

;
; char* __fastcall__ strdup(const char* s) {
;
	jsr     pushax
;
; char *res = NULL;
;
	jsr     push0
;
; reallocMsg((void**)&res, strlen(s) + 1);
;
	lda     sp
	ldx     sp+1
	jsr     pushax
	ldy     #$05
	jsr     ldaxysp
	jsr     _strlen
	jsr     incax1
	jsr     _reallocMsg
;
; strcpy(res, s);
;
	jsr     pushw0sp
	ldy     #$05
	jsr     ldaxysp
	jsr     _strcpy
;
; return res;
;
	jsr     ldax0sp
;
; }
;
	jsr     incsp4
	jmp     farret

.endproc

; ---------------------------------------------------------------
; void __near__ getValue (__near__ struct expression *, __near__ struct resultColumnParam *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_getValue: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; expressionPtr->leftNull = FALSE;
;
	ldy     #$0E
	jsr     subysp
	ldy     #$11
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$08
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; switch(expressionPtr->type) {
;
	ldy     #$11
	jsr     ldaxysp
	jsr     ldaxi
;
; }
;
	cpx     #$00
	jne     L0099
	cmp     #$01
	beq     L000D
	cmp     #$02
	jeq     L0024
	cmp     #$03
	jeq     L0029
	cmp     #$09
	jeq     L005C
	cmp     #$0A
	jeq     L0082
	cmp     #$16
	jeq     L003B
	jmp     L0099
;
; field = &(match->ptr[
;
L000D:	ldy     #$0F
	jsr     ldaxysp
;
; ((struct inputColumn*)(expressionPtr->unionPtrs.voidPtr))->
;
	ldy     #$03
	jsr     pushwidx
	ldy     #$13
	jsr     ldaxysp
;
; firstResultColumn->resultColumnIndex
;
	ldy     #$0F
	jsr     ldaxidx
;
; ]);
;
	ldy     #$07
	jsr     ldaxidx
	jsr     pushw
	lda     #$0E
	jsr     tosmula0
	jsr     tosaddax
	ldy     #$08
	jsr     staxysp
;
; if(field->leftNull) {
;
	ldy     #$08
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	iny
	ora     (ptr1),y
	beq     L0014
;
; expressionPtr->leftNull = TRUE;
;
	ldy     #$11
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$01
	ldy     #$08
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; expressionPtr->value = strdup("");
;
	ldy     #$13
	jsr     pushwysp
	lda     #<(L001A)
	ldx     #>(L001A)
	jsr     _strdup
	ldy     #$0C
	jsr     staxspidx
;
; else {
;
	jmp     L000B
;
; stringGet((unsigned char **)(&(expressionPtr->value)), field, match->params);
;
L0014:	ldy     #$11
	jsr     ldaxysp
	ldy     #$0C
	jsr     incaxy
	jsr     pushax
	ldy     #$0D
	jsr     pushwysp
	ldy     #$13
	jsr     ldaxysp
	jsr     ldaxi
	jsr     _stringGet
;
; } break;
;
	jmp     L000B
;
; expressionPtr->value = strdup((char *)expressionPtr->unionPtrs.voidPtr);
;
L0024:	ldy     #$13
	jsr     pushwysp
	ldy     #$13
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	jsr     _strdup
	ldy     #$0C
	jsr     staxspidx
;
; } break;
;
	jmp     L000B
;
; calculatedField = ((struct expression*)(expressionPtr->unionPtrs.voidPtr));
;
L0029:	ldy     #$11
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	ldy     #$0C
	jsr     staxysp
;
; getValue(calculatedField, match);
;
	jsr     pushax
	ldy     #$11
	jsr     ldaxysp
	jsr     _getValue
;
; expressionPtr->leftNull = calculatedField->leftNull;
;
	ldy     #$11
	jsr     ldaxysp
	sta     sreg
	stx     sreg+1
	ldy     #$0D
	jsr     ldaxysp
	ldy     #$09
	jsr     ldaxidx
	ldy     #$08
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; expressionPtr->value = strdup(calculatedField->value);
;
	ldy     #$13
	jsr     pushwysp
	ldy     #$0F
	jsr     ldaxysp
	ldy     #$0D
	jsr     ldaxidx
	jsr     _strdup
	ldy     #$0C
	jsr     staxspidx
;
; freeAndZero(calculatedField->value);
;
	iny
	jsr     ldaxysp
	ldy     #$0D
	jsr     ldaxidx
	jsr     _free
	ldy     #$0D
	jsr     ldaxysp
;
; } break;
;
	jmp     L14A9
;
; column = (struct resultColumn *)(expressionPtr->unionPtrs.voidPtr);
;
L003B:	ldy     #$11
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	ldy     #$0A
	jsr     staxysp
;
; if(column->groupingDone) {
;
	ldy     #$10
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	iny
	ora     (ptr1),y
	beq     L003F
;
; field = &(match->ptr[column->resultColumnIndex]);
;
	ldy     #$0F
	jsr     ldaxysp
	ldy     #$03
	jsr     pushwidx
	ldy     #$0D
	jsr     ldaxysp
	jsr     pushw
	lda     #$0E
	jsr     tosmula0
	jsr     tosaddax
	ldy     #$08
	jsr     staxysp
;
; if(field->leftNull == FALSE) {
;
	ldy     #$09
	jsr     ldaxidx
	cpx     #$00
	bne     L004F
	cmp     #$00
	bne     L004F
;
; stringGet((unsigned char **)(&(expressionPtr->value)), field, match->params);
;
	ldy     #$11
	jsr     ldaxysp
	ldy     #$0C
	jsr     incaxy
	jsr     pushax
	ldy     #$0D
	jsr     pushwysp
	ldy     #$13
	jsr     ldaxysp
	jsr     ldaxi
	jsr     _stringGet
;
; break;
;
	jmp     L000B
;
; else if(column->groupText != NULL) {
;
L003F:	ldy     #$0B
	jsr     ldaxysp
	ldy     #$09
	jsr     ldaxidx
	cpx     #$00
	bne     L14A2
	cmp     #$00
	beq     L004F
;
; expressionPtr->value = strdup(column->groupText);
;
L14A2:	ldy     #$13
	jsr     pushwysp
	ldy     #$0D
	jsr     ldaxysp
	ldy     #$09
	jsr     ldaxidx
	jsr     _strdup
	ldy     #$0C
	jsr     staxspidx
;
; break;
;
	jmp     L000B
;
; expressionPtr->leftNull = TRUE;
;
L004F:	ldy     #$11
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$01
	ldy     #$08
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; expressionPtr->value = strdup("");
;
	ldy     #$13
	jsr     pushwysp
	lda     #<(L0059)
	ldx     #>(L0059)
	jsr     _strdup
	ldy     #$0C
	jsr     staxspidx
;
; } break;
;
	jmp     L000B
;
; expressionPtr->unionPtrs.leaves.leftPtr,
;
L005C:	ldy     #$11
	jsr     ldaxysp
	ldy     #$0F
	jsr     pushwidx
;
; );
;
	ldy     #$11
	jsr     ldaxysp
	jsr     _getValue
;
; if(expressionPtr->unionPtrs.leaves.leftPtr->leftNull) {
;
	ldy     #$11
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	ldy     #$08
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	iny
	ora     (ptr1),y
	beq     L0060
;
; expressionPtr->leftNull = TRUE;
;
	ldy     #$11
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$01
	ldy     #$08
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; expressionPtr->value = strdup("");
;
	ldy     #$13
	jsr     pushwysp
	lda     #<(L0066)
	ldx     #>(L0066)
	jsr     _strdup
	ldy     #$0C
	jsr     staxspidx
;
; else {
;
	jmp     L0068
;
; temp1 = strtod(expressionPtr->unionPtrs.leaves.leftPtr->value, NULL);
;
L0060:	ldy     #$11
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	ldy     #$0D
	jsr     pushwidx
	ldx     #$00
	txa
	jsr     _strtod
	ldy     #$04
	jsr     steaxysp
;
; ftostr(&(expressionPtr->value), temp1);
;
	ldy     #$11
	jsr     ldaxysp
	ldy     #$0C
	jsr     incaxy
	jsr     pushax
	ldx     #$00
	lda     #$21
	jsr     _reallocMsg
	ldy     #$11
	jsr     ldaxysp
	ldy     #$0C
	jsr     incaxy
	jsr     pushw
	ldy     #$09
	jsr     ldeaxysp
	jsr     __ftostr
	ldy     #$11
	jsr     ldaxysp
	ldy     #$0C
	jsr     incaxy
	jsr     pushax
	ldy     #$13
	jsr     ldaxysp
	ldy     #$0C
	jsr     incaxy
	jsr     ldaxi
	jsr     _strlen
	jsr     incax1
	jsr     _reallocMsg
;
; freeAndZero(expressionPtr->unionPtrs.leaves.leftPtr->value);
;
L0068:	ldy     #$11
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	ldy     #$0D
	jsr     ldaxidx
	jsr     _free
	ldy     #$11
	jsr     ldaxysp
	ldy     #$0F
;
; } break;
;
	jmp     L14AA
;
; expressionPtr->unionPtrs.leaves.leftPtr,
;
L0082:	ldy     #$11
	jsr     ldaxysp
	ldy     #$0F
	jsr     pushwidx
;
; );
;
	ldy     #$11
	jsr     ldaxysp
	jsr     _getValue
;
; if(expressionPtr->unionPtrs.leaves.leftPtr->leftNull) {
;
	ldy     #$11
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	ldy     #$08
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	iny
	ora     (ptr1),y
	beq     L0086
;
; expressionPtr->leftNull = TRUE;
;
	ldy     #$11
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$01
	ldy     #$08
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; expressionPtr->value = strdup("");
;
	ldy     #$13
	jsr     pushwysp
	lda     #<(L008C)
	ldx     #>(L008C)
	jsr     _strdup
	ldy     #$0C
	jsr     staxspidx
;
; else {
;
	jmp     L008E
;
; &(expressionPtr->value),
;
L0086:	ldy     #$11
	jsr     ldaxysp
	ldy     #$0C
	jsr     incaxy
	jsr     pushax
;
; strtod(expressionPtr->unionPtrs.leaves.leftPtr->value, NULL)
;
	ldy     #$13
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	ldy     #$0D
	jsr     pushwidx
	ldx     #$00
	txa
;
; );
;
	jsr     _strtod
	jsr     _exp_uminus
;
; freeAndZero(expressionPtr->unionPtrs.leaves.leftPtr->value);
;
L008E:	ldy     #$11
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	ldy     #$0D
	jsr     ldaxidx
	jsr     _free
	ldy     #$11
	jsr     ldaxysp
	ldy     #$0F
;
; } break;
;
	jmp     L14AA
;
; if(expressionPtr->type > EXP_CONCAT) {
;
L0099:	ldy     #$11
	jsr     ldaxysp
	jsr     ldaxi
	cmp     #$09
	txa
	sbc     #$00
	bvs     L009C
	eor     #$80
L009C:	bpl     L009A
;
; expressionPtr->value = strdup("");
;
	ldy     #$13
	jsr     pushwysp
	lda     #<(L009F)
	ldx     #>(L009F)
	jsr     _strdup
	ldy     #$0C
	jsr     staxspidx
;
; break;
;
	jmp     L000B
;
; expressionPtr->unionPtrs.leaves.leftPtr,
;
L009A:	ldy     #$11
	jsr     ldaxysp
	ldy     #$0F
	jsr     pushwidx
;
; );
;
	ldy     #$11
	jsr     ldaxysp
	jsr     _getValue
;
; expressionPtr->unionPtrs.leaves.rightPtr,
;
	ldy     #$11
	jsr     ldaxysp
	ldy     #$11
	jsr     pushwidx
;
; );
;
	ldy     #$11
	jsr     ldaxysp
	jsr     _getValue
;
; expressionPtr->unionPtrs.leaves.leftPtr->leftNull ||
;
	ldy     #$11
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	ldy     #$08
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	iny
	ora     (ptr1),y
	bne     L00A8
;
; expressionPtr->unionPtrs.leaves.rightPtr->leftNull
;
	ldy     #$11
	jsr     ldaxysp
;
; ) {
;
	ldy     #$11
	jsr     ldaxidx
	ldy     #$08
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	iny
	ora     (ptr1),y
	beq     L00A7
;
; expressionPtr->leftNull = TRUE;
;
L00A8:	ldy     #$11
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$01
	ldy     #$08
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; expressionPtr->value = strdup("");
;
	ldy     #$13
	jsr     pushwysp
	lda     #<(L00AE)
	ldx     #>(L00AE)
	jsr     _strdup
	ldy     #$0C
	jsr     staxspidx
;
; else {
;
	jmp     L00B3
;
; switch(expressionPtr->type){
;
L00A7:	ldy     #$11
	jsr     ldaxysp
	jsr     ldaxi
;
; }
;
	cpx     #$00
	jne     L00B3
	cmp     #$04
	beq     L00B5
	cmp     #$05
	jeq     L00D3
	cmp     #$06
	jeq     L00F1
	cmp     #$07
	jeq     L010F
	cmp     #$08
	jeq     L011A
	jmp     L00B3
;
; temp1 = strtod(expressionPtr->unionPtrs.leaves.leftPtr->value, NULL);
;
L00B5:	ldy     #$11
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	ldy     #$0D
	jsr     pushwidx
	ldx     #$00
	txa
	jsr     _strtod
	ldy     #$04
	jsr     steaxysp
;
; temp2 = fadd(temp1, strtod(expressionPtr->unionPtrs.leaves.rightPtr->value, NULL));
;
	ldy     #$07
	jsr     ldeaxysp
	jsr     pusheax
	ldy     #$15
	jsr     ldaxysp
	ldy     #$11
	jsr     ldaxidx
	ldy     #$0D
	jsr     pushwidx
	ldx     #$00
	txa
	jsr     _strtod
	jsr     __fadd
	jsr     steax0sp
;
; ftostr(&(expressionPtr->value), temp2);
;
	ldy     #$11
	jsr     ldaxysp
	ldy     #$0C
	jsr     incaxy
	jsr     pushax
	ldx     #$00
	lda     #$21
	jsr     _reallocMsg
	ldy     #$11
	jsr     ldaxysp
	ldy     #$0C
	jsr     incaxy
	jsr     pushw
	ldy     #$05
	jsr     ldeaxysp
	jsr     __ftostr
	ldy     #$11
	jsr     ldaxysp
	ldy     #$0C
	jsr     incaxy
	jsr     pushax
	ldy     #$13
	jsr     ldaxysp
	ldy     #$0C
	jsr     incaxy
	jsr     ldaxi
	jsr     _strlen
	jsr     incax1
	jsr     _reallocMsg
;
; break;
;
	jmp     L00B3
;
; temp1 = strtod(expressionPtr->unionPtrs.leaves.leftPtr->value, NULL);
;
L00D3:	ldy     #$11
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	ldy     #$0D
	jsr     pushwidx
	ldx     #$00
	txa
	jsr     _strtod
	ldy     #$04
	jsr     steaxysp
;
; temp2 = fsub(temp1, strtod(expressionPtr->unionPtrs.leaves.rightPtr->value, NULL));
;
	ldy     #$07
	jsr     ldeaxysp
	jsr     pusheax
	ldy     #$15
	jsr     ldaxysp
	ldy     #$11
	jsr     ldaxidx
	ldy     #$0D
	jsr     pushwidx
	ldx     #$00
	txa
	jsr     _strtod
	jsr     __fsub
	jsr     steax0sp
;
; ftostr(&(expressionPtr->value), temp2);
;
	ldy     #$11
	jsr     ldaxysp
	ldy     #$0C
	jsr     incaxy
	jsr     pushax
	ldx     #$00
	lda     #$21
	jsr     _reallocMsg
	ldy     #$11
	jsr     ldaxysp
	ldy     #$0C
	jsr     incaxy
	jsr     pushw
	ldy     #$05
	jsr     ldeaxysp
	jsr     __ftostr
	ldy     #$11
	jsr     ldaxysp
	ldy     #$0C
	jsr     incaxy
	jsr     pushax
	ldy     #$13
	jsr     ldaxysp
	ldy     #$0C
	jsr     incaxy
	jsr     ldaxi
	jsr     _strlen
	jsr     incax1
	jsr     _reallocMsg
;
; break;
;
	jmp     L00B3
;
; temp1 = strtod(expressionPtr->unionPtrs.leaves.leftPtr->value, NULL);
;
L00F1:	ldy     #$11
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	ldy     #$0D
	jsr     pushwidx
	ldx     #$00
	txa
	jsr     _strtod
	ldy     #$04
	jsr     steaxysp
;
; temp2 = fmul(temp1, strtod(expressionPtr->unionPtrs.leaves.rightPtr->value, NULL));
;
	ldy     #$07
	jsr     ldeaxysp
	jsr     pusheax
	ldy     #$15
	jsr     ldaxysp
	ldy     #$11
	jsr     ldaxidx
	ldy     #$0D
	jsr     pushwidx
	ldx     #$00
	txa
	jsr     _strtod
	jsr     __fmul
	jsr     steax0sp
;
; ftostr(&(expressionPtr->value), temp2);
;
	ldy     #$11
	jsr     ldaxysp
	ldy     #$0C
	jsr     incaxy
	jsr     pushax
	ldx     #$00
	lda     #$21
	jsr     _reallocMsg
	ldy     #$11
	jsr     ldaxysp
	ldy     #$0C
	jsr     incaxy
	jsr     pushw
	ldy     #$05
	jsr     ldeaxysp
	jsr     __ftostr
	ldy     #$11
	jsr     ldaxysp
	ldy     #$0C
	jsr     incaxy
	jsr     pushax
	ldy     #$13
	jsr     ldaxysp
	ldy     #$0C
	jsr     incaxy
	jsr     ldaxi
	jsr     _strlen
	jsr     incax1
	jsr     _reallocMsg
;
; break;
;
	jmp     L00B3
;
; &(expressionPtr->value),
;
L010F:	ldy     #$11
	jsr     ldaxysp
	ldy     #$0C
	jsr     incaxy
	jsr     pushax
;
; strtod(expressionPtr->unionPtrs.leaves.leftPtr->value, NULL),
;
	ldy     #$13
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	ldy     #$0D
	jsr     pushwidx
	ldx     #$00
	txa
	jsr     _strtod
	jsr     pusheax
;
; strtod(expressionPtr->unionPtrs.leaves.rightPtr->value, NULL)
;
	ldy     #$17
	jsr     ldaxysp
	ldy     #$11
	jsr     ldaxidx
	ldy     #$0D
	jsr     pushwidx
	ldx     #$00
	txa
;
; );
;
	jsr     _strtod
	jsr     _exp_divide
;
; break;
;
	jmp     L00B3
;
; &(expressionPtr->value),
;
L011A:	ldy     #$11
	jsr     ldaxysp
	ldy     #$0C
	jsr     incaxy
	jsr     pushax
;
; "%s%s",
;
	lda     #<(L011E)
	ldx     #>(L011E)
	jsr     pushax
;
; expressionPtr->unionPtrs.leaves.leftPtr->value,
;
	ldy     #$15
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	ldy     #$0D
	jsr     pushwidx
;
; expressionPtr->unionPtrs.leaves.rightPtr->value
;
	ldy     #$17
	jsr     ldaxysp
;
; );
;
	ldy     #$11
	jsr     ldaxidx
	ldy     #$0D
	jsr     pushwidx
	ldy     #$08
	jsr     _d_sprintf
;
; freeAndZero(expressionPtr->unionPtrs.leaves.leftPtr->value);
;
L00B3:	ldy     #$11
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	ldy     #$0D
	jsr     ldaxidx
	jsr     _free
	ldy     #$11
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$0C
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; freeAndZero(expressionPtr->unionPtrs.leaves.rightPtr->value);
;
	ldy     #$11
	jsr     ldaxysp
	ldy     #$11
	jsr     ldaxidx
	ldy     #$0D
	jsr     ldaxidx
	jsr     _free
	ldy     #$11
	jsr     ldaxysp
	ldy     #$11
L14AA:	jsr     ldaxidx
L14A9:	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$0C
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; }
;
L000B:	ldy     #$12
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; void __near__ parse_orderingSpec (__near__ struct qryData *, __near__ struct expression *, int)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_parse_orderingSpec: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; struct sortingList *sortingListPtr = NULL;
;
	jsr     push0
;
; if(queryData->parseMode != 1) {
;
	ldy     #$07
	jsr     ldaxysp
	jsr     ldaxi
	cpx     #$00
	jne     L013E
	cmp     #$01
;
; return;
;
	jne     L013E
;
; (void**)&(sortingListPtr),
;
	lda     sp
	ldx     sp+1
	jsr     pushax
;
; );
;
	ldx     #$00
	lda     #$06
	jsr     _reallocMsg
;
; sortingListPtr->expressionPtr = expressionPtr;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$05
	jsr     ldaxysp
	ldy     #$00
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; sortingListPtr->isDescending = isDescending;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$03
	jsr     ldaxysp
	ldy     #$02
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; if(queryData->orderByClause == NULL) {
;
	ldy     #$07
	jsr     ldaxysp
	ldy     #$21
	jsr     ldaxidx
	cpx     #$00
	bne     L0137
	cmp     #$00
	bne     L0137
;
; sortingListPtr->nextInList = sortingListPtr;
;
	jsr     ldax0sp
;
; else {
;
	jmp     L14BF
;
; sortingListPtr->nextInList = queryData->orderByClause->nextInList;
;
L0137:	jsr     ldax0sp
	sta     sreg
	stx     sreg+1
	ldy     #$07
	jsr     ldaxysp
	ldy     #$21
	jsr     ldaxidx
	ldy     #$05
	jsr     ldaxidx
	ldy     #$04
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; queryData->orderByClause->nextInList = sortingListPtr;
;
	ldy     #$07
	jsr     ldaxysp
	ldy     #$21
	jsr     ldaxidx
L14BF:	sta     ptr1
	stx     ptr1+1
	jsr     ldax0sp
	ldy     #$04
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; queryData->orderByClause = sortingListPtr;
;
	ldy     #$07
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	jsr     ldax0sp
	ldy     #$20
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; }
;
L013E:	jsr     incsp8
	jmp     farret

.endproc

; ---------------------------------------------------------------
; __near__ struct expression * __near__ parse_scalarExpColumnRef (__near__ struct qryData *, __near__ struct columnReference *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_parse_scalarExpColumnRef: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; struct expression *expressionPtr = NULL, *expressionColumnPtr;
;
	jsr     push0
;
; struct inputColumn *columnPtr = NULL;
;
	jsr     decsp2
	jsr     push0
;
; if(queryData->parseMode != 1) {
;
	ldy     #$09
	jsr     ldaxysp
	jsr     ldaxi
	cpx     #$00
	bne     L14C1
	cmp     #$01
	beq     L0148
;
; return NULL;
;
L14C1:	ldx     #$00
	txa
	jmp     L0145
;
; reallocMsg((void**)(&expressionPtr), sizeof(struct expression));
;
L0148:	lda     #$04
	jsr     leaa0sp
	jsr     pushax
	ldx     #$00
	lda     #$12
	jsr     _reallocMsg
;
; expressionPtr->value = NULL;
;
	ldy     #$05
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$0C
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; if(referencePtr->referenceType == REF_COLUMN) {
;
	ldy     #$07
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	cpx     #$00
	jne     L0152
	cmp     #$01
	bne     L0152
;
; expressionPtr->type = EXP_COLUMN;
;
	ldy     #$05
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$01
	ldy     #$00
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; columnPtr = referencePtr->reference.columnPtr;
;
	ldy     #$07
	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	jsr     stax0sp
;
; expressionPtr->unionPtrs.voidPtr = (void *)(columnPtr);
;
	ldy     #$05
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	jsr     ldax0sp
	ldy     #$0E
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; expressionPtr->minColumn = columnPtr->columnIndex;
;
	ldy     #$05
	jsr     ldaxysp
	sta     sreg
	stx     sreg+1
	jsr     ldax0sp
	jsr     ldaxi
	ldy     #$04
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; expressionPtr->minTable = ((struct inputTable*)columnPtr->inputTablePtr)->fileIndex;
;
	jsr     ldaxysp
	sta     sreg
	stx     sreg+1
	jsr     ldax0sp
	ldy     #$05
	jsr     ldaxidx
	jsr     ldaxi
	ldy     #$02
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; expressionPtr->containsAggregates = FALSE;
;
	ldy     #$05
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$06
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; else {
;
	jmp     L14C0
;
; expressionPtr->type = EXP_CALCULATED;
;
L0152:	ldy     #$05
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$03
	ldy     #$00
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; expressionColumnPtr = referencePtr->reference.calculatedPtr.expressionPtr;
;
	ldy     #$07
	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	ldy     #$02
	jsr     staxysp
;
; expressionPtr->unionPtrs.voidPtr = (void *)(expressionColumnPtr);
;
	ldy     #$05
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$03
	jsr     ldaxysp
	ldy     #$0E
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; expressionPtr->minColumn = expressionColumnPtr->minColumn;
;
	ldy     #$05
	jsr     ldaxysp
	sta     sreg
	stx     sreg+1
	ldy     #$03
	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	ldy     #$04
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; expressionPtr->minTable = expressionColumnPtr->minTable;
;
	jsr     ldaxysp
	sta     sreg
	stx     sreg+1
	ldy     #$03
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	ldy     #$02
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; expressionPtr->containsAggregates = expressionColumnPtr->containsAggregates;
;
	ldy     #$05
	jsr     ldaxysp
	sta     sreg
	stx     sreg+1
	ldy     #$03
	jsr     ldaxysp
	ldy     #$07
	jsr     ldaxidx
	ldy     #$06
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; return expressionPtr;
;
L14C0:	ldy     #$05
	jsr     ldaxysp
;
; }
;
L0145:	ldy     #$0A
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; int __near__ parse_columnRefUnsuccessful (__near__ struct qryData *, __near__ __near__ struct columnReference * *, __near__ unsigned char *, __near__ unsigned char *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_parse_columnRefUnsuccessful: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; struct columnReference *currentReference = NULL;
;
	jsr     push0
;
; if(queryData->parseMode != 1) {
;
	ldy     #$09
	jsr     ldaxysp
	jsr     ldaxi
	cpx     #$00
	bne     L14C4
	cmp     #$01
	beq     L0174
;
; free(tableName);
;
L14C4:	ldy     #$05
	jsr     ldaxysp
	jsr     _free
;
; free(columnName);
;
	ldy     #$03
	jsr     ldaxysp
	jsr     _free
;
; *result = NULL;
;
	ldy     #$07
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	tay
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; return FALSE; /* successful, but only because we don't really care about getting column references when in parse mode 0 */
;
	tax
	jmp     L0172
;
; currentReference = hash_lookupString(queryData->columnReferenceHashTable, columnName);
;
L0174:	ldy     #$09
	jsr     ldaxysp
	ldy     #$17
	jsr     pushwidx
	ldy     #$05
	jsr     ldaxysp
	jsr     _hash_lookupString
	jsr     stax0sp
;
; if(tableName != NULL) {
;
	ldy     #$04
	lda     (sp),y
	iny
	ora     (sp),y
	beq     L0182
;
; while (currentReference != NULL) {
;
	jmp     L0187
;
; currentReference->referenceType == 1 &&
;
L14C3:	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	cpx     #$00
	bne     L018A
	cmp     #$01
	bne     L018A
;
; strcmp(tableName, ((struct inputTable*)(currentReference->reference.columnPtr->inputTablePtr))->queryTableName) == 0
;
	ldy     #$07
	jsr     pushwysp
	ldy     #$03
	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	ldy     #$05
	jsr     ldaxidx
	ldy     #$0D
	jsr     ldaxidx
	jsr     _strcmp
;
; ) {
;
	cpx     #$00
	bne     L018A
	cmp     #$00
	beq     L0197
;
; currentReference = currentReference->nextReferenceWithName;
;
L018A:	jsr     ldax0sp
	ldy     #$09
	jsr     ldaxidx
	jsr     stax0sp
;
; while (currentReference != NULL) {
;
L0187:	ldy     #$00
	lda     (sp),y
	iny
	ora     (sp),y
	bne     L14C3
;
; else if(
;
	jmp     L0197
;
; currentReference != NULL &&
;
L0182:	tay
	lda     (sp),y
	iny
	ora     (sp),y
	beq     L0197
;
; currentReference->nextReferenceWithName != NULL &&
;
	jsr     ldax0sp
	ldy     #$09
	jsr     ldaxidx
	cpx     #$00
	bne     L14C5
	cmp     #$00
	beq     L0197
;
; currentReference->nextReferenceWithName->referenceType == currentReference->referenceType
;
L14C5:	jsr     ldax0sp
	ldy     #$09
	jsr     ldaxidx
	ldy     #$03
	jsr     ldaxidx
	sta     sreg
	stx     sreg+1
;
; ) {
;
	jsr     ldax0sp
	ldy     #$03
	jsr     ldaxidx
	cpx     sreg+1
	bne     L0197
	cmp     sreg
	bne     L0197
;
; currentReference = NULL;
;
	ldx     #$00
	txa
	jsr     stax0sp
;
; free(tableName);
;
L0197:	ldy     #$05
	jsr     ldaxysp
	jsr     _free
;
; free(columnName);
;
	ldy     #$03
	jsr     ldaxysp
	jsr     _free
;
; currentReference != NULL &&
;
	ldy     #$00
	lda     (sp),y
	iny
	ora     (sp),y
	beq     L01A3
;
; currentReference->referenceType == REF_COLUMN &&
;
	jsr     ldax0sp
	ldy     #$03
	jsr     ldaxidx
	cpx     #$00
	bne     L01A3
	cmp     #$01
	bne     L01A3
;
; currentReference->reference.columnPtr->firstResultColumn == NULL
;
	jsr     ldax0sp
	ldy     #$05
	jsr     ldaxidx
	ldy     #$07
	jsr     ldaxidx
;
; ) {
;
	cpx     #$00
	bne     L01A3
	cmp     #$00
	bne     L01A3
;
; currentReference->reference.columnPtr->firstResultColumn = parse_newOutputColumn(
;
	jsr     ldax0sp
	ldy     #$05
	jsr     pushwidx
;
; queryData,
;
	ldy     #$0D
	jsr     pushwysp
;
; /*isHidden = */TRUE,
;
	lda     #$01
	jsr     pusha0
;
; /*isCalculated = */FALSE,
;
	jsr     push0
;
; /*resultColumnName = */NULL,
;
	jsr     push0
;
; );
;
	jsr     _parse_newOutputColumn
	ldy     #$06
	jsr     staxspidx
;
; *result = currentReference;
;
L01A3:	ldy     #$07
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	jsr     ldax0sp
	ldy     #$00
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; return currentReference == NULL;
;
	jsr     ldax0sp
	cpx     #$00
	bne     L01B4
	cmp     #$00
L01B4:	jsr     booleq
;
; }
;
L0172:	ldy     #$0A
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; __near__ struct columnReferenceHash * __near__ hash_createTable (int)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_hash_createTable: near

.segment	"CODE"

;
; struct columnReferenceHash *hash_createTable(int size) {
;
	jsr     pushax
;
; if (size < 1) {
;
	jsr     decsp4
	ldy     #$05
	jsr     ldaxysp
	cmp     #$01
	txa
	sbc     #$00
	bvc     L01B8
	eor     #$80
L01B8:	asl     a
	ldx     #$00
	bcc     L14C8
;
; return NULL; /* invalid size for table */
;
	txa
	jmp     L01B5
;
; if ((new_table = malloc(sizeof(struct columnReferenceHash))) == NULL) {
;
L14C8:	lda     #$04
	jsr     _malloc
	ldy     #$02
	jsr     staxysp
	cpx     #$00
	bne     L01BA
	cmp     #$00
;
; return NULL;
;
	jeq     L01B5
;
; if ((new_table->table = malloc(sizeof(struct columnReference *) * size)) == NULL) {
;
L01BA:	ldy     #$05
	jsr     pushwysp
	ldy     #$07
	jsr     ldaxysp
	jsr     shlax1
	jsr     _malloc
	ldy     #$02
	jsr     staxspidx
	cpx     #$00
	bne     L01C1
	cmp     #$00
	bne     L14CA
;
; return NULL;
;
	jmp     L01B5
;
; for(i=0; i<size; i++) {
;
L01C1:	ldx     #$00
L14CA:	txa
L14CB:	jsr     stax0sp
	ldy     #$04
	cmp     (sp),y
	txa
	iny
	sbc     (sp),y
	bvc     L14C7
	eor     #$80
L14C7:	bpl     L01C9
;
; new_table->table[i] = NULL;
;
	ldy     #$03
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	sta     ptr1
	stx     ptr1+1
	jsr     ldax0sp
	jsr     aslax1
	clc
	adc     ptr1
	sta     ptr1
	txa
	adc     ptr1+1
	sta     ptr1+1
	lda     #$00
	tay
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; for(i=0; i<size; i++) {
;
	jsr     ldax0sp
	jsr     incax1
	jmp     L14CB
;
; new_table->size = size;
;
L01C9:	ldy     #$03
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$05
	jsr     ldaxysp
	ldy     #$00
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; return new_table;
;
	ldy     #$03
	jsr     ldaxysp
;
; }
;
L01B5:	jsr     incsp6
	jmp     farret

.endproc

; ---------------------------------------------------------------
; void __near__ parse_tableFactor (__near__ struct qryData *, int, __near__ unsigned char *, __near__ unsigned char *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_parse_tableFactor: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; struct inputTable *newTable = NULL;
;
	jsr     decsp2
	jsr     push0
;
; struct columnReference *currentReference = NULL;
;
	jsr     push0
;
; char *columnText = NULL;
;
	jsr     decsp4
	jsr     push0
;
; char *columnText2 = NULL;
;
	jsr     push0
;
; size_t columnLength = 0;
;
	jsr     push0
;
; int recordContinues = TRUE;
;
	lda     #$01
	jsr     pusha0
;
; long headerByteLength = 0;
;
	jsr     pushl0
;
; if(queryData->parseMode != 0) {
;
	ldy     #$1D
	jsr     ldaxysp
	jsr     ldaxi
	cpx     #$00
	bne     L14D1
	cmp     #$00
	beq     L01DE
;
; free(fileName);
;
L14D1:	ldy     #$19
	jsr     ldaxysp
	jsr     _free
;
; free(tableName);
;
	ldy     #$17
	jsr     ldaxysp
	jsr     _free
;
; return;
;
	jmp     L01D6
;
; csvFile = fopen(fileName, "rb");
;
L01DE:	ldy     #$1B
	jsr     pushwysp
	lda     #<(L01E8)
	ldx     #>(L01E8)
	jsr     _fopen
	ldy     #$14
	jsr     staxysp
;
; columnText = strdup(tableName);
;
	ldy     #$17
	jsr     ldaxysp
	jsr     _strdup
	ldy     #$0A
	jsr     staxysp
;
; columnText2 = strdup(fileName);
;
	ldy     #$19
	jsr     ldaxysp
	jsr     _strdup
	ldy     #$08
	jsr     staxysp
;
; if(csvFile == NULL || columnText == NULL || columnText2 == NULL) {
;
	ldy     #$14
	lda     (sp),y
	iny
	ora     (sp),y
	beq     L01F1
	ldy     #$0A
	lda     (sp),y
	iny
	ora     (sp),y
	beq     L01F1
	ldy     #$08
	lda     (sp),y
	iny
	ora     (sp),y
	bne     L01F0
;
; fputs(TDB_COULDNT_OPEN_INPUT, stderr);
;
L01F1:	lda     #<(L01F7)
	ldx     #>(L01F7)
	jsr     pushax
	lda     _stderr
	ldx     _stderr+1
	jsr     _fputs
;
; exit(EXIT_FAILURE);
;
	ldx     #$00
	lda     #$01
	jsr     _exit
;
; free(fileName);
;
L01F0:	ldy     #$19
	jsr     ldaxysp
	jsr     _free
;
; free(tableName);
;
	ldy     #$17
	jsr     ldaxysp
	jsr     _free
;
; fclose(csvFile);
;
	ldy     #$15
	jsr     ldaxysp
	jsr     _fclose
;
; csvFile = skipBom(columnText2, &headerByteLength);
;
	ldy     #$0B
	jsr     pushwysp
	lda     #$02
	jsr     leaa0sp
	jsr     _skipBom
	ldy     #$14
	jsr     staxysp
;
; tableName = strdup(columnText);
;
	ldy     #$0B
	jsr     ldaxysp
	jsr     _strdup
	ldy     #$16
	jsr     staxysp
;
; fileName = strdup(columnText2);
;
	ldy     #$09
	jsr     ldaxysp
	jsr     _strdup
	ldy     #$18
	jsr     staxysp
;
; free(columnText);
;
	ldy     #$0B
	jsr     ldaxysp
	jsr     _free
;
; free(columnText2);  /* free the filename string data as we don't need it any more */
;
	ldy     #$09
	jsr     ldaxysp
	jsr     _free
;
; columnText = NULL;
;
	ldx     #$00
	txa
	ldy     #$0A
	jsr     staxysp
;
; if(csvFile == NULL || tableName == NULL || fileName == NULL) {
;
	ldy     #$14
	lda     (sp),y
	iny
	ora     (sp),y
	beq     L14CF
	iny
	lda     (sp),y
	iny
	ora     (sp),y
	beq     L14CF
	iny
	lda     (sp),y
	iny
	ora     (sp),y
	bne     L0212
;
; fputs(TDB_COULDNT_OPEN_INPUT, stderr);
;
L14CF:	lda     #<(L0219)
	ldx     #>(L0219)
	jsr     pushax
	lda     _stderr
	ldx     _stderr+1
	jsr     _fputs
;
; exit(EXIT_FAILURE);
;
	ldx     #$00
	lda     #$01
	jsr     _exit
;
; reallocMsg((void**)(&newTable), sizeof(struct inputTable));
;
L0212:	lda     #$12
	jsr     leaa0sp
	jsr     pushax
	ldx     #$00
	lda     #$14
	jsr     _reallocMsg
;
; newTable->queryTableName = tableName;
;
	ldy     #$13
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$17
	jsr     ldaxysp
	ldy     #$0C
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; newTable->fileStream = csvFile;
;
	ldy     #$13
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$15
	jsr     ldaxysp
	ldy     #$0E
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; newTable->firstInputColumn = NULL;  /* the table initially has no columns */
;
	ldy     #$13
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$12
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; newTable->isLeftJoined = FALSE;
;
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$04
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; newTable->noLeftRecord = TRUE;   /* set just for initialsation purposes */
;
	ldy     #$13
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$01
	ldy     #$06
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; if(queryData->firstInputTable == NULL) {
;
	ldy     #$1D
	jsr     ldaxysp
	ldy     #$19
	jsr     ldaxidx
	cpx     #$00
	bne     L022C
	cmp     #$00
	bne     L022C
;
; newTable->fileIndex = 1;
;
	ldy     #$13
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$01
	ldy     #$00
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; newTable->nextInputTable = newTable;
;
	ldy     #$13
	jsr     ldaxysp
;
; else {
;
	jmp     L150B
;
; newTable->fileIndex = 0; /*  we have to fill the file indexes in afterwards because of left join reordering (queryData->firstInputTable->fileIndex)+1; */
;
L022C:	ldy     #$13
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	tay
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; if(isLeftJoin) {
;
	ldy     #$1B
	lda     (sp),y
	dey
	ora     (sp),y
	jeq     L0238
;
; newTable->isLeftJoined = TRUE;
;
	ldy     #$13
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$01
	ldy     #$04
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; if(queryData->secondaryInputTable == NULL) {
;
	ldy     #$1D
	jsr     ldaxysp
	ldy     #$1B
	jsr     ldaxidx
	cpx     #$00
	bne     L023C
	cmp     #$00
	bne     L023C
;
; queryData->secondaryInputTable = newTable;
;
	ldy     #$1D
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$13
	jsr     ldaxysp
	ldy     #$1A
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; newTable->nextInputTable = queryData->firstInputTable->nextInputTable;
;
	ldy     #$13
	jsr     ldaxysp
	sta     sreg
	stx     sreg+1
	ldy     #$1D
	jsr     ldaxysp
	ldy     #$19
	jsr     ldaxidx
	ldy     #$11
	jsr     ldaxidx
	ldy     #$10
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; queryData->firstInputTable->nextInputTable = newTable;
;
	ldy     #$1D
	jsr     ldaxysp
	ldy     #$19
	jsr     ldaxidx
	sta     ptr1
	stx     ptr1+1
	ldy     #$13
	jsr     ldaxysp
	ldy     #$10
;
; else {
;
	jmp     L150F
;
; newTable->nextInputTable = queryData->secondaryInputTable->nextInputTable;
;
L023C:	ldy     #$13
	jsr     ldaxysp
	sta     sreg
	stx     sreg+1
	ldy     #$1D
	jsr     ldaxysp
	ldy     #$1B
	jsr     ldaxidx
	ldy     #$11
	jsr     ldaxidx
	ldy     #$10
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; queryData->secondaryInputTable->nextInputTable = newTable;
;
	ldy     #$1D
	jsr     ldaxysp
	ldy     #$1B
	jsr     ldaxidx
	sta     ptr1
	stx     ptr1+1
	ldy     #$13
	jsr     ldaxysp
	ldy     #$10
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; queryData->secondaryInputTable = newTable;
;
	ldy     #$1D
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$13
	jsr     ldaxysp
	ldy     #$1A
;
; else {
;
	jmp     L150F
;
; newTable->nextInputTable = queryData->firstInputTable->nextInputTable;  /* this is a circularly linked list until we've finished adding records */
;
L0238:	ldy     #$13
	jsr     ldaxysp
	sta     sreg
	stx     sreg+1
	ldy     #$1D
	jsr     ldaxysp
	ldy     #$19
	jsr     ldaxidx
	ldy     #$11
	jsr     ldaxidx
	ldy     #$10
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; queryData->firstInputTable->nextInputTable = newTable;
;
	ldy     #$1D
	jsr     ldaxysp
	ldy     #$19
	jsr     ldaxidx
L150B:	sta     ptr1
	stx     ptr1+1
	ldy     #$13
	jsr     ldaxysp
	ldy     #$10
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; queryData->firstInputTable = newTable;
;
	ldy     #$1D
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$13
	jsr     ldaxysp
	ldy     #$18
L150F:	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; newReference = NULL;
;
	ldx     #$00
L14D0:	txa
	ldy     #$0E
	jsr     staxysp
;
; newColumn = NULL;
;
	ldy     #$0C
	jsr     staxysp
;
; &(newTable->fileStream),
;
	ldy     #$13
	jsr     ldaxysp
	ldy     #$0E
	jsr     incaxy
	jsr     pushax
;
; &columnText,
;
	lda     #$0C
	jsr     leaa0sp
	jsr     pushax
;
; &columnLength,
;
	lda     #$0A
	jsr     leaa0sp
	jsr     pushax
;
; NULL,
;
	jsr     push0
;
; &headerByteLength,
;
	lda     #$08
	jsr     leaa0sp
	jsr     pushax
;
; (queryData->params & PRM_TRIM
;
	ldy     #$27
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
;
; ) == 0);
;
	and     #$01
	jsr     booleq
	jsr     _getCsvColumn
	ldy     #$04
	jsr     staxysp
;
; d_sprintf(&columnText, "_%s", columnText);
;
	lda     #$0A
	jsr     leaa0sp
	jsr     pushax
	lda     #<(L0267)
	ldx     #>(L0267)
	jsr     pushax
	ldy     #$11
	jsr     pushwysp
	ldy     #$06
	jsr     _d_sprintf
;
; currentReference = hash_lookupString(queryData->columnReferenceHashTable, columnText);
;
	ldy     #$1D
	jsr     ldaxysp
	ldy     #$17
	jsr     pushwidx
	ldy     #$0D
	jsr     ldaxysp
	jsr     _hash_lookupString
	ldy     #$10
	jsr     staxysp
;
; if(currentReference == NULL) {
;
	cpx     #$00
	bne     L026E
	cmp     #$00
	bne     L026E
;
; reallocMsg((void**)(&newReference), sizeof(struct columnReference));
;
	lda     #$0E
	jsr     leaa0sp
	jsr     pushax
	ldx     #$00
	lda     #$0A
	jsr     _reallocMsg
;
; newReference->referenceName = columnText;
;
	ldy     #$0F
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$0B
	jsr     ldaxysp
	ldy     #$00
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; newReference->nextReferenceWithName = NULL;
;
	ldy     #$0F
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$08
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; hash_addString(queryData->columnReferenceHashTable, columnText, newReference);  
;
	ldy     #$1D
	jsr     ldaxysp
	ldy     #$17
	jsr     pushwidx
	ldy     #$0F
	jsr     pushwysp
	ldy     #$13
	jsr     ldaxysp
	jsr     _hash_addString
;
; else {
;
	jmp     L028D
;
; free(columnText);
;
L026E:	ldy     #$0B
	jsr     ldaxysp
	jsr     _free
;
; reallocMsg((void**)(&newReference), sizeof(struct columnReference));
;
	lda     #$0E
	jsr     leaa0sp
	jsr     pushax
	ldx     #$00
	lda     #$0A
	jsr     _reallocMsg
;
; newReference->referenceName = currentReference->referenceName;
;
	ldy     #$0F
	jsr     ldaxysp
	sta     sreg
	stx     sreg+1
	ldy     #$11
	jsr     ldaxysp
	jsr     ldaxi
	ldy     #$00
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; if(currentReference->nextReferenceWithName == NULL) {
;
	ldy     #$11
	jsr     ldaxysp
	ldy     #$09
	jsr     ldaxidx
	cpx     #$00
	bne     L0286
	cmp     #$00
	bne     L0286
;
; newReference->nextReferenceWithName = newReference;
;
	ldy     #$0F
	jsr     ldaxysp
;
; else {
;
	jmp     L150C
;
; newReference->nextReferenceWithName = currentReference->nextReferenceWithName->nextReferenceWithName;
;
L0286:	ldy     #$0F
	jsr     ldaxysp
	sta     sreg
	stx     sreg+1
	ldy     #$11
	jsr     ldaxysp
	ldy     #$09
	jsr     ldaxidx
	ldy     #$09
	jsr     ldaxidx
	ldy     #$08
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; currentReference->nextReferenceWithName->nextReferenceWithName = newReference;
;
	ldy     #$11
	jsr     ldaxysp
	ldy     #$09
	jsr     ldaxidx
L150C:	sta     ptr1
	stx     ptr1+1
	ldy     #$0F
	jsr     ldaxysp
	ldy     #$08
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; currentReference->nextReferenceWithName = newReference;
;
	ldy     #$11
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$0F
	jsr     ldaxysp
	ldy     #$08
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; newReference->referenceType = REF_COLUMN;
;
L028D:	ldy     #$0F
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$01
	ldy     #$02
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; reallocMsg((void**)(&newColumn), sizeof(struct inputColumn));
;
	lda     #$0C
	jsr     leaa0sp
	jsr     pushax
	ldx     #$00
	lda     #$0A
	jsr     _reallocMsg
;
; newReference->reference.columnPtr = newColumn;
;
	ldy     #$0F
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$0D
	jsr     ldaxysp
	ldy     #$04
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; newColumn->fileColumnName = newReference->referenceName;
;
	ldy     #$0D
	jsr     ldaxysp
	sta     sreg
	stx     sreg+1
	ldy     #$0F
	jsr     ldaxysp
	jsr     ldaxi
	ldy     #$02
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; newColumn->inputTablePtr = (void*)newTable;
;
	ldy     #$0D
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$13
	jsr     ldaxysp
	ldy     #$04
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; newColumn->firstResultColumn = NULL;
;
	ldy     #$0D
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$06
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; if(newTable->firstInputColumn == NULL) {
;
	ldy     #$13
	jsr     ldaxysp
	ldy     #$13
	jsr     ldaxidx
	cpx     #$00
	bne     L02A2
	cmp     #$00
	bne     L02A2
;
; newColumn->columnIndex = 1;
;
	ldy     #$0D
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$01
	ldy     #$00
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; newColumn->nextColumnInTable = newColumn;
;
	ldy     #$0D
	jsr     ldaxysp
;
; else {
;
	jmp     L150D
;
; newColumn->columnIndex = (newTable->firstInputColumn->columnIndex)+1;
;
L02A2:	ldy     #$0D
	jsr     ldaxysp
	sta     sreg
	stx     sreg+1
	ldy     #$13
	jsr     ldaxysp
	ldy     #$13
	jsr     ldaxidx
	jsr     ldaxi
	jsr     incax1
	ldy     #$00
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; newColumn->nextColumnInTable = newTable->firstInputColumn->nextColumnInTable;  /* this is a circularly linked list until we've finished adding records */
;
	ldy     #$0D
	jsr     ldaxysp
	sta     sreg
	stx     sreg+1
	ldy     #$13
	jsr     ldaxysp
	ldy     #$13
	jsr     ldaxidx
	ldy     #$09
	jsr     ldaxidx
	ldy     #$08
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; newTable->firstInputColumn->nextColumnInTable = newColumn;
;
	ldy     #$13
	jsr     ldaxysp
	ldy     #$13
	jsr     ldaxidx
L150D:	sta     ptr1
	stx     ptr1+1
	ldy     #$0D
	jsr     ldaxysp
	ldy     #$08
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; newTable->firstInputColumn = newColumn;
;
	ldy     #$13
	jsr     ldaxysp
	sta     sreg
	stx     sreg+1
	ldy     #$0D
	jsr     ldaxysp
	ldy     #$12
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; columnText = NULL;
;
	ldx     #$00
	txa
	ldy     #$0A
	jsr     staxysp
;
; columnLength = 0;
;
	ldy     #$06
	jsr     staxysp
;
; } while(recordContinues);
;
	ldy     #$05
	lda     (sp),y
	dey
	ora     (sp),y
	jne     L14D0
;
; newTable->firstRecordOffset = headerByteLength;
;
	ldy     #$15
	jsr     pushwysp
	ldy     #$05
	jsr     ldeaxysp
	ldy     #$08
	jsr     steaxspidx
;
; newTable->columnCount = newTable->firstInputColumn->columnIndex;
;
	ldy     #$13
	jsr     ldaxysp
	sta     sreg
	stx     sreg+1
	ldy     #$13
	jsr     ldaxysp
	ldy     #$13
	jsr     ldaxidx
	jsr     ldaxi
	ldy     #$02
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; newColumn = newTable->firstInputColumn->nextColumnInTable;
;
	ldy     #$13
	jsr     ldaxysp
	ldy     #$13
	jsr     ldaxidx
	ldy     #$09
	jsr     ldaxidx
	ldy     #$0C
	jsr     staxysp
;
; newTable->firstInputColumn->nextColumnInTable = NULL;
;
	ldy     #$13
	jsr     ldaxysp
	ldy     #$13
	jsr     ldaxidx
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$08
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; newTable->firstInputColumn = newColumn;
;
	ldy     #$13
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$0D
	jsr     ldaxysp
	ldy     #$12
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; }
;
L01D6:	ldy     #$1E
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; void __near__ readParams (__near__ unsigned char *, __near__ int *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_readParams: near

.segment	"CODE"

;
; void readParams(char *string, int *params) {
;
	jsr     pushax
;
; if(string && params) {
;
	ldy     #$03
	lda     (sp),y
	dey
	ora     (sp),y
	jeq     L02CA
	dey
	lda     (sp),y
	dey
	ora     (sp),y
	jne     L02CB
	jmp     L02CA
;
; switch(*string) {
;
L02C9:	ldy     #$03
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
;
; }
;
	cmp     #$42
	beq     L02E9
	cmp     #$45
	beq     L02E3
	cmp     #$49
	beq     L02DD
	cmp     #$50
	beq     L02D1
	cmp     #$54
	beq     L02D7
	cmp     #$C2
	beq     L02E9
	cmp     #$C5
	beq     L02E3
	cmp     #$C9
	beq     L02DD
	cmp     #$D0
	beq     L02D1
	cmp     #$D4
	beq     L02D7
	jmp     L02CF
;
; *params |= PRM_TRIM;
;
L02D1:	jsr     ldax0sp
	jsr     pushax
	jsr     ldaxi
	ora     #$01
;
; break;
;
	jmp     L1511
;
; *params |= PRM_SPACE;
;
L02D7:	jsr     ldax0sp
	jsr     pushax
	jsr     ldaxi
	ora     #$02
;
; break;
;
	jmp     L1511
;
; *params |= PRM_IMPORT;
;
L02DD:	jsr     ldax0sp
	jsr     pushax
	jsr     ldaxi
	ora     #$04
;
; break;
;
	jmp     L1511
;
; *params |= PRM_EXPORT;
;
L02E3:	jsr     ldax0sp
	jsr     pushax
	jsr     ldaxi
	ora     #$08
;
; break;
;
	jmp     L1511
;
; *params |= PRM_BOM;
;
L02E9:	jsr     ldax0sp
	jsr     pushax
	jsr     ldaxi
	ora     #$10
L1511:	ldy     #$00
	jsr     staxspidx
;
; string++;
;
L02CF:	ldy     #$03
	jsr     ldaxysp
	jsr     incax1
	ldy     #$02
	jsr     staxysp
;
; while(*string) {
;
L02CB:	ldy     #$03
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	jne     L02C9
;
; }
;
L02CA:	jsr     incsp4
	jmp     farret

.endproc

; ---------------------------------------------------------------
; int __near__ endOfFile (__near__ struct _FILE *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_endOfFile: near

.segment	"CODE"

;
; int endOfFile(FILE* stream) {
;
	jsr     pushax
;
; c = fgetc(stream);
;
	jsr     decsp2
	ldy     #$03
	jsr     ldaxysp
	jsr     _fgetc
	jsr     stax0sp
;
; ungetc(c, stream);
;
	jsr     pushax
	ldy     #$05
	jsr     ldaxysp
	jsr     _ungetc
;
; return c != EOF;
;
	jsr     ldax0sp
	cpx     #$FF
	bne     L02F7
	cmp     #$FF
L02F7:	jsr     boolne
;
; }
;
	jsr     incsp4
	jmp     farret

.endproc

; ---------------------------------------------------------------
; int __near__ strNumberCompare (__near__ unsigned char *, __near__ unsigned char *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_strNumberCompare: near

.segment	"CODE"

;
; int strNumberCompare(char *input1, char *input2) {
;
	jsr     pushax
;
; char* string1 = input1;
;
	ldy     #$05
	jsr     pushwysp
;
; char* string2 = input2;
;
	ldy     #$05
	jsr     pushwysp
;
; int decimalNotFound1 = TRUE;
;
	lda     #$01
	jsr     pusha0
;
; int decimalNotFound2 = TRUE;
;
	jsr     pusha0
;
; int compare = 0;
;
	jsr     push0
;
; int negate = 1;
;
	lda     #$01
	jsr     pusha0
;
; int do1 = TRUE;
;
	jsr     pusha0
;
; int do2 = TRUE;
;
	jsr     pusha0
;
; if(*string1 == '-') {
;
	ldy     #$0F
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$2D
	bne     L0301
;
; string1++;
;
	ldy     #$0F
	jsr     ldaxysp
	jsr     incax1
	ldy     #$0E
	jsr     staxysp
;
; if(*string2 != '-') {
;
	ldy     #$0D
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$2D
	beq     L0304
;
; if(*string2 == '+') {
;
	ldy     #$0D
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$2B
	bne     L0306
;
; string2++;
;
	ldy     #$0D
	jsr     ldaxysp
	jsr     incax1
	ldy     #$0C
	jsr     staxysp
;
; compare = -1;
;
L0306:	ldx     #$FF
	txa
	ldy     #$06
;
; else {
;
	jmp     L152D
;
; negate = -1;
;
L0304:	ldx     #$FF
	txa
	ldy     #$04
	jsr     staxysp
;
; else {
;
	jmp     L1538
;
; if(*string1 == '+') {
;
L0301:	ldy     #$0F
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$2B
	bne     L0310
;
; string1++;
;
	ldy     #$0F
	jsr     ldaxysp
	jsr     incax1
	ldy     #$0E
	jsr     staxysp
;
; if(*string2 == '-') {
;
L0310:	ldy     #$0D
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$2D
	bne     L0313
;
; string2++;
;
	ldy     #$0D
	jsr     ldaxysp
	jsr     incax1
	ldy     #$0C
	jsr     staxysp
;
; compare = 1;
;
	ldx     #$00
	lda     #$01
	ldy     #$06
;
; else if(*string2 == '+') {
;
	jmp     L152D
L0313:	ldy     #$0D
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$2B
	bne     L0319
;
; string2++;
;
L1538:	ldy     #$0D
	jsr     ldaxysp
	jsr     incax1
	ldy     #$0C
L152D:	jsr     staxysp
;
; if(compare == 0) {
;
L0319:	ldy     #$06
	lda     (sp),y
	iny
	ora     (sp),y
	jne     L152C
;
; while(*string1 == '0') {
;
	jmp     L0321
;
; string1++;
;
L031F:	ldy     #$0F
	jsr     ldaxysp
	jsr     incax1
	ldy     #$0E
	jsr     staxysp
;
; while(*string1 == '0') {
;
L0321:	ldy     #$0F
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$30
	beq     L031F
;
; while(*string2 == '0') {
;
	jmp     L0326
;
; string2++;
;
L0324:	ldy     #$0D
	jsr     ldaxysp
	jsr     incax1
	ldy     #$0C
	jsr     staxysp
;
; while(*string2 == '0') {
;
L0326:	ldy     #$0D
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$30
	beq     L0324
;
; input1 = string1;
;
	ldy     #$0F
	jsr     ldaxysp
	ldy     #$12
	jsr     staxysp
;
; input2 = string2;
;
	ldy     #$0D
	jsr     ldaxysp
	ldy     #$10
;
; while(compare == 0) {
;
	jmp     L152E
;
; if(*string1 > '9' || *string1 < '0') {
;
L032D:	ldy     #$0F
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$3A
	bcs     L1514
	ldy     #$0F
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$30
	jcs     L0332
;
; if(*string2 > '9' || *string2 < '0') {
;
L1514:	ldy     #$0D
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$3A
	bcs     L1515
	ldy     #$0D
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$30
	jcs     L0335
;
; string1 = input1;
;
L1515:	ldy     #$13
	jsr     ldaxysp
	ldy     #$0E
	jsr     staxysp
;
; string2 = input2;
;
	ldy     #$11
	jsr     ldaxysp
L1535:	ldy     #$0C
L1530:	jsr     staxysp
;
; if(do1) {
;
	ldy     #$03
	lda     (sp),y
	dey
	ora     (sp),y
	beq     L0351
;
; if(decimalNotFound1 && (*string1 == '.' || *string1 == ',')) {
;
	ldy     #$0B
	lda     (sp),y
	dey
	ora     (sp),y
	beq     L0342
	ldy     #$0F
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     (ptr1,x)
	cmp     #$2E
	beq     L151B
	ldy     #$0F
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     (ptr1,x)
	cmp     #$2C
	bne     L0342
;
; decimalNotFound1 = FALSE;
;
L151B:	txa
	ldy     #$0A
	jsr     staxysp
;
; else if(*string1 > '9' || *string1 < '0') {
;
	jmp     L0351
L0342:	ldy     #$0F
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$3A
	bcs     L151C
	ldy     #$0F
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$30
	bcs     L151D
;
; do1 = FALSE;
;
L151C:	ldx     #$00
	txa
	ldy     #$02
	jsr     staxysp
;
; else if (do2 == FALSE && *string1 != '0') {
;
	jmp     L0351
L151D:	lda     (sp),y
	iny
	ora     (sp),y
	bne     L1531
	ldy     #$0F
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$30
;
; break;
;
	jne     L0335
;
; if(do2) {
;
L0351:	ldy     #$01
L1531:	lda     (sp),y
	dey
	ora     (sp),y
	jeq     L0369
;
; if(decimalNotFound2 && (*string2 == '.' || *string2 == ',')) {
;
	ldy     #$09
	lda     (sp),y
	dey
	ora     (sp),y
	beq     L035A
	ldy     #$0D
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     (ptr1,x)
	cmp     #$2E
	beq     L1525
	ldy     #$0D
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     (ptr1,x)
	cmp     #$2C
	bne     L035A
;
; decimalNotFound2 = FALSE;
;
L1525:	txa
	ldy     #$08
	jsr     staxysp
;
; else if(*string2 > '9' || *string2 < '0') {
;
	jmp     L0369
L035A:	ldy     #$0D
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$3A
	bcs     L1526
	ldy     #$0D
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$30
	bcs     L0363
;
; do2 = FALSE;
;
L1526:	ldx     #$00
	txa
	jsr     stax0sp
;
; else if (do1 == FALSE && *string2 != '0') {
;
	jmp     L0369
L0363:	ldy     #$02
	lda     (sp),y
	iny
	ora     (sp),y
	bne     L1532
	ldy     #$0D
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$30
	beq     L0369
;
; compare = 1;
;
	ldx     #$00
	lda     #$01
;
; break;
;
	jmp     L152F
;
; if(do1) {
;
L0369:	ldy     #$03
L1532:	lda     (sp),y
	dey
	ora     (sp),y
	jeq     L0370
;
; if(do2) {
;
	dey
	lda     (sp),y
	dey
	ora     (sp),y
	jeq     L0372
;
; if(*string1 >= '0' &&
;
	ldy     #$0F
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$30
	jcc     L0374
;
; *string1 <= '9' &&
;
	ldy     #$0F
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$3A
	bcs     L0374
;
; *string2 >= '0' &&
;
	ldy     #$0D
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$30
	bcc     L0374
;
; *string2 <= '9' &&
;
	ldy     #$0D
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$3A
	bcs     L0374
;
; *string1 != *string2) {
;
	ldy     #$0F
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     (ptr1,x)
	jsr     pusha0
	ldy     #$0F
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     (ptr1,x)
	jsr     tosicmp0
	beq     L0374
;
; compare = *string1 < *string2?-1:1;
;
	ldy     #$0F
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     (ptr1,x)
	jsr     pusha0
	ldy     #$0F
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     (ptr1,x)
	jsr     tosicmp0
	bcc     L0335
	ldx     #$00
	lda     #$01
;
; break;
;
	jmp     L152F
;
; string2++;
;
L0374:	ldy     #$0D
	jsr     ldaxysp
	jsr     incax1
	ldy     #$0C
	jsr     staxysp
;
; string1++;
;
L0372:	ldy     #$0F
	jsr     ldaxysp
	jsr     incax1
	ldy     #$0E
;
; else if(do2) {
;
	jmp     L1530
L0370:	dey
	lda     (sp),y
	dey
	ora     (sp),y
	beq     L0381
;
; string2++;
;
	ldy     #$0D
	jsr     ldaxysp
	jsr     incax1
;
; else {
;
	jmp     L1535
;
; return 0;
;
L0381:	tax
	jmp     L02F8
;
; compare = -1;
;
L0335:	ldx     #$FF
	txa
L152F:	ldy     #$06
;
; else if(*string2 > '9' || *string2 < '0') {
;
	jmp     L152E
L0332:	ldy     #$0D
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$3A
	bcs     L152B
	ldy     #$0D
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$30
	bcs     L038A
;
; compare = 1;
;
L152B:	ldx     #$00
	lda     #$01
	ldy     #$06
;
; else {
;
	jmp     L152E
;
; string1++;
;
L038A:	ldy     #$0F
	jsr     ldaxysp
	jsr     incax1
	ldy     #$0E
	jsr     staxysp
;
; string2++;
;
	ldy     #$0D
	jsr     ldaxysp
	jsr     incax1
	ldy     #$0C
L152E:	jsr     staxysp
;
; while(compare == 0) {
;
	ldy     #$06
	lda     (sp),y
	iny
	ora     (sp),y
	jeq     L032D
;
; return compare * negate;
;
L152C:	ldy     #$09
	jsr     pushwysp
	ldy     #$07
	jsr     ldaxysp
	jsr     tosmulax
;
; }
;
L02F8:	ldy     #$14
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; long __near__ getUnicodeChar (__near__ __near__ unsigned char * *, __near__ __near__ unsigned char * *, int, __near__ int *, __near__ __near__ function returning void *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_getUnicodeChar: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; struct hash2Entry* entry = NULL;
;
	jsr     push0
;
; int bytesread = 0;
;
	jsr     push0
;
; unsigned char *temp = (unsigned char *)((*offset) + plusBytes);
;
	jsr     decsp4
	ldy     #$11
	jsr     ldaxysp
	jsr     ldaxi
	sta     ptr1
	stx     ptr1+1
	ldy     #$0D
	jsr     ldaxysp
	clc
	adc     ptr1
	pha
	txa
	adc     ptr1+1
	tax
	pla
	jsr     pushax
;
; if(*temp < 0x80) {
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$80
	bcs     L0399
;
; *bytesMatched = 1;
;
	ldy     #$0D
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$01
	ldy     #$00
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; return (long)(*temp);
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	ldx     #$00
	lda     (ptr1),y
	jsr     aulong
	jsr     axulong
	jmp     L0393
;
; else if(*temp > 0xC1) {
;
L0399:	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$C2
	jcc     L040A
;
; if (*temp < 0xE0) { 
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$E0
	jcs     L03A2
;
; (*(temp+1) & 0xC0) == 0x80
;
	jsr     ldax0sp
	jsr     incax1
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	and     #$C0
;
; ) {
;
	cmp     #$80
	jne     L040A
;
; codepoint = ((long)(*(temp)) << 6) + *(temp+1) - 0x3080;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	ldx     #$00
	lda     (ptr1),y
	jsr     aulong
	jsr     axulong
	jsr     asleax4
	jsr     asleax2
	jsr     pusheax
	ldy     #$05
	jsr     ldaxysp
	jsr     incax1
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	ldx     #$00
	lda     (ptr1),y
	jsr     axulong
	jsr     tosaddeax
	jsr     pusheax
	ldx     #$30
	lda     #$80
	jsr     tossub0ax
	ldy     #$02
	jsr     steaxysp
;
; if((entry = isInHash2(codepoint))) {
;
	ldy     #$05
	jsr     ldeaxysp
	jsr     _isInHash2
	ldy     #$08
	jsr     staxysp
	stx     tmp1
	ora     tmp1
	beq     L03AF
;
; bytesread = 2;
;
	ldx     #$00
	lda     #$02
	ldy     #$06
	jsr     staxysp
;
; else {
;
	jmp     L040A
;
; *bytesMatched = 2;
;
L03AF:	ldy     #$0D
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$02
	ldy     #$00
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; return codepoint;
;
	ldy     #$05
	jsr     ldeaxysp
	jmp     L0393
;
; else if (*temp < 0xF0) {
;
L03A2:	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$F0
	jcs     L03BB
;
; (*(temp+1) & 0xC0) == 0x80 &&
;
	jsr     ldax0sp
	jsr     incax1
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	and     #$C0
	cmp     #$80
	jne     L040A
;
; (*(temp) != 0xE0 || *(temp+1) > 0x9F) &&
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$E0
	bne     L1539
	jsr     ldax0sp
	jsr     incax1
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$A0
	jcc     L040A
;
; (*(temp+2) & 0xC0) == 0x80
;
L1539:	jsr     ldax0sp
	jsr     incax2
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	and     #$C0
;
; ) {
;
	cmp     #$80
	jne     L040A
;
; codepoint = ((long)(*(temp)) << 12) + ((long)(*(temp+1)) << 6) + (*(temp+2)) - 0xE2080;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	ldx     #$00
	lda     (ptr1),y
	jsr     aulong
	jsr     axulong
	ldy     sreg
	sty     sreg+1
	stx     sreg
	tax
	lda     #$00
	jsr     asleax4
	jsr     pusheax
	ldy     #$05
	jsr     ldaxysp
	jsr     incax1
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	ldx     #$00
	lda     (ptr1),y
	jsr     aulong
	jsr     axulong
	jsr     asleax4
	jsr     asleax2
	jsr     tosaddeax
	jsr     pusheax
	ldy     #$05
	jsr     ldaxysp
	jsr     incax2
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	ldx     #$00
	lda     (ptr1),y
	jsr     axulong
	jsr     tosaddeax
	jsr     pusheax
	ldx     #$20
	lda     #$0E
	sta     sreg
	lda     #$00
	sta     sreg+1
	lda     #$80
	jsr     tossubeax
	ldy     #$02
	jsr     steaxysp
;
; if((entry = isInHash2(codepoint))) {
;
	ldy     #$05
	jsr     ldeaxysp
	jsr     _isInHash2
	ldy     #$08
	jsr     staxysp
	stx     tmp1
	ora     tmp1
	beq     L03D5
;
; bytesread = 3;
;
	ldx     #$00
	lda     #$03
	ldy     #$06
	jsr     staxysp
;
; else {
;
	jmp     L040A
;
; *bytesMatched = 3;
;
L03D5:	ldy     #$0D
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$03
	ldy     #$00
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; return codepoint;
;
	ldy     #$05
	jsr     ldeaxysp
	jmp     L0393
;
; else if (*temp < 0xF5) {
;
L03BB:	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$F5
	jcs     L040A
;
; (*(temp+1) & 0xC0) == 0x80 &&
;
	jsr     ldax0sp
	jsr     incax1
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	and     #$C0
	cmp     #$80
	jne     L040A
;
; (*temp != 0xF0 || *(temp+1) > 0x8F) &&
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$F0
	bne     L153D
	jsr     ldax0sp
	jsr     incax1
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$90
	jcc     L040A
;
; (*temp != 0xF4 || *(temp+1) < 0x90) &&
;
L153D:	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$F4
	bne     L153E
	jsr     ldax0sp
	jsr     incax1
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$90
	jcs     L040A
;
; (*(temp+2) & 0xC0) == 0x80 &&
;
L153E:	jsr     ldax0sp
	jsr     incax2
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	and     #$C0
	cmp     #$80
	jne     L040A
;
; (*(temp+3) & 0xC0) == 0x80
;
	jsr     ldax0sp
	jsr     incax3
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	and     #$C0
;
; ) {
;
	cmp     #$80
	jne     L040A
;
; codepoint = (((long)(*temp)) << 18) + ((long)(*(temp+1)) << 12) + ((long)(*(temp+2)) << 6) + (*(temp+3)) - 0x3C82080;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	ldx     #$00
	lda     (ptr1),y
	jsr     aulong
	jsr     axulong
	stx     sreg+1
	sta     sreg
	lda     #$00
	tax
	jsr     asleax2
	jsr     pusheax
	ldy     #$05
	jsr     ldaxysp
	jsr     incax1
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	ldx     #$00
	lda     (ptr1),y
	jsr     aulong
	jsr     axulong
	ldy     sreg
	sty     sreg+1
	stx     sreg
	tax
	lda     #$00
	jsr     asleax4
	jsr     tosaddeax
	jsr     pusheax
	ldy     #$05
	jsr     ldaxysp
	jsr     incax2
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	ldx     #$00
	lda     (ptr1),y
	jsr     aulong
	jsr     axulong
	jsr     asleax4
	jsr     asleax2
	jsr     tosaddeax
	jsr     pusheax
	ldy     #$05
	jsr     ldaxysp
	jsr     incax3
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	ldx     #$00
	lda     (ptr1),y
	jsr     axulong
	jsr     tosaddeax
	jsr     pusheax
	ldx     #$20
	lda     #$C8
	sta     sreg
	lda     #$03
	sta     sreg+1
	lda     #$80
	jsr     tossubeax
	ldy     #$02
	jsr     steaxysp
;
; if((entry = isInHash2(codepoint))) {
;
	ldy     #$05
	jsr     ldeaxysp
	jsr     _isInHash2
	ldy     #$08
	jsr     staxysp
	stx     tmp1
	ora     tmp1
	beq     L0403
;
; bytesread = 4;
;
	ldx     #$00
	lda     #$04
	ldy     #$06
	jsr     staxysp
;
; else {
;
	jmp     L040A
;
; *bytesMatched = 4;
;
L0403:	ldy     #$0D
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$04
	ldy     #$00
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; return codepoint;
;
	ldy     #$05
	jsr     ldeaxysp
	jmp     L0393
;
; get = (void (*)())&getUnicodeCharFast;
;
L040A:	lda     #<(_getUnicodeCharFast)
	ldx     #>(_getUnicodeCharFast)
	ldy     #$0A
	jsr     staxysp
;
; return normaliseAndGet(offset, str, plusBytes, bytesMatched, bytesread, entry);
;
	ldy     #$15
	jsr     pushwysp
	ldy     #$15
	jsr     pushwysp
	ldy     #$15
	jsr     pushwysp
	ldy     #$15
	jsr     pushwysp
	ldy     #$11
	jsr     pushwysp
	ldy     #$13
	jsr     ldaxysp
	jsr     _normaliseAndGet
	jsr     axlong
;
; }
;
L0393:	ldy     #$14
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; void __near__ outputHeader (__near__ struct qryData *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_outputHeader: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; int firstColumn = TRUE;
;
	lda     #$01
	jsr     pusha0
;
; char *separator = (((query->params) & PRM_SPACE) != 0)?",":", ";
;
	jsr     decsp4
	ldy     #$07
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	and     #$02
	beq     L041F
	lda     #<(L041E)
	ldx     #>(L041E)
	jmp     L0422
L041F:	lda     #<(L0421)
	ldx     #>(L0421)
L0422:	jsr     pushax
;
; if(query->intoFileName) {
;
	ldy     #$09
	jsr     ldaxysp
	ldy     #$10
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	iny
	ora     (ptr1),y
	beq     L0424
;
; query->newLine = "\r\n";
;
	ldy     #$09
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #<(L0427)
	ldy     #$12
	sta     (ptr1),y
	iny
	lda     #>(L0427)
	sta     (ptr1),y
;
; query->outputFile = fopen(query->intoFileName, "wb");
;
	ldy     #$0B
	jsr     pushwysp
	ldy     #$0B
	jsr     ldaxysp
	ldy     #$11
	jsr     pushwidx
	lda     #<(L042C)
	ldx     #>(L042C)
	jsr     _fopen
	ldy     #$14
	jsr     staxspidx
;
; if (query->outputFile == NULL) {
;
	ldy     #$09
	jsr     ldaxysp
	ldy     #$15
	jsr     ldaxidx
	cpx     #$00
	bne     L0435
	cmp     #$00
	bne     L0435
;
; fputs("opening output file failed", stderr);
;
	lda     #<(L0432)
	ldx     #>(L0432)
	jsr     pushax
	lda     _stderr
	ldx     _stderr+1
;
; return;
;
	jmp     L1542
;
; query->outputFile = stdout;
;
L0424:	ldy     #$09
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     _stdout
	ldy     #$14
	sta     (ptr1),y
	iny
	lda     _stdout+1
	sta     (ptr1),y
;
; query->newLine = "\n";
;
	ldy     #$09
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #<(L0439)
	ldy     #$12
	sta     (ptr1),y
	iny
	lda     #>(L0439)
	sta     (ptr1),y
;
; outputFile = query->outputFile;
;
L0435:	ldy     #$09
	jsr     ldaxysp
	ldy     #$15
	jsr     ldaxidx
	ldy     #$02
	jsr     staxysp
;
; if(((query->params) & PRM_BOM) != 0) {
;
	ldy     #$09
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	and     #$10
	beq     L043D
;
; fputs("\xEF\xBB\xBF", outputFile);
;
	lda     #<(L0443)
	ldx     #>(L0443)
	jsr     pushax
	ldy     #$05
	jsr     ldaxysp
	jsr     _fputs
;
; currentResultColumn = query->firstResultColumn;
;
L043D:	ldy     #$09
	jsr     ldaxysp
	ldy     #$1D
L1546:	jsr     ldaxidx
	ldy     #$04
	jsr     staxysp
;
; currentResultColumn != NULL;
;
	ldy     #$04
	lda     (sp),y
	iny
	ora     (sp),y
	beq     L0447
;
; if(currentResultColumn->isHidden == FALSE) {
;
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	cpx     #$00
	bne     L0448
	cmp     #$00
	bne     L0448
;
; if (!firstColumn) {
;
	ldy     #$07
	lda     (sp),y
	dey
	ora     (sp),y
	bne     L1545
;
; fputs(separator, outputFile);
;
	jsr     pushw0sp
	ldy     #$05
	jsr     ldaxysp
	jsr     _fputs
;
; else {
;
	jmp     L0458
;
; firstColumn = FALSE;
;
L1545:	txa
	jsr     staxysp
;
; fputs((currentResultColumn->resultColumnName)+1, outputFile);
;
L0458:	ldy     #$05
	jsr     ldaxysp
	ldy     #$13
	jsr     ldaxidx
	jsr     incax1
	jsr     pushax
	ldy     #$05
	jsr     ldaxysp
	jsr     _fputs
;
; ) {
;
L0448:	ldy     #$05
	jsr     ldaxysp
	ldy     #$17
	jmp     L1546
;
; fputs(query->newLine, outputFile);
;
L0447:	ldy     #$09
	jsr     ldaxysp
	ldy     #$13
	jsr     pushwidx
	ldy     #$05
	jsr     ldaxysp
L1542:	jsr     _fputs
;
; }
;
	ldy     #$0A
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; int __near__ combiningCharCompare (__near__ const void *, __near__ const void *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_combiningCharCompare: near

.segment	"CODE"

;
; int combiningCharCompare(const void *a, const void *b) {
;
	jsr     pushax
;
; return (*((long*)a) < *((long*)b)) ? -1 : (*((long*)a) != *((long*)b) ? 1 : 0);
;
	ldy     #$03
	jsr     ldaxysp
	jsr     ldeaxi
	jsr     pusheax
	ldy     #$05
	jsr     ldaxysp
	jsr     ldeaxi
	jsr     toslteax
	beq     L0467
	ldx     #$FF
	jmp     L1547
L0467:	ldy     #$03
	jsr     ldaxysp
	jsr     ldeaxi
	jsr     pusheax
	ldy     #$05
	jsr     ldaxysp
	jsr     ldeaxi
	jsr     tosneeax
	beq     L046E
	ldx     #$00
	lda     #$01
	jmp     L0462
L046E:	ldx     #$00
L1547:	txa
;
; }
;
L0462:	jsr     incsp4
	jmp     farret

.endproc

; ---------------------------------------------------------------
; void __near__ getCalculatedColumns (__near__ struct qryData *, __near__ struct resultColumnValue *, int)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_getCalculatedColumns: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; matchParams.ptr = match;
;
	ldy     #$0E
	jsr     subysp
	ldy     #$11
	jsr     ldaxysp
	ldy     #$02
	jsr     staxysp
;
; matchParams.params = query->params;
;
	ldy     #$13
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	jsr     stax0sp
;
; for(i = 0; i < query->columnReferenceHashTable->size; i++) {
;
	ldx     #$00
	txa
L1552:	ldy     #$0C
	jsr     staxysp
	jsr     pushax
	ldy     #$15
	jsr     ldaxysp
	ldy     #$17
	jsr     ldaxidx
	jsr     ldaxi
	jsr     tosicmp
	jpl     L0478
;
; currentHashEntry = query->columnReferenceHashTable->table[i];
;
	ldy     #$13
	jsr     ldaxysp
	ldy     #$17
	jsr     ldaxidx
	ldy     #$03
	jsr     ldaxidx
	sta     ptr1
	stx     ptr1+1
	ldy     #$0D
	jsr     ldaxysp
	jsr     aslax1
	clc
	adc     ptr1
	pha
	txa
	adc     ptr1+1
	tax
	pla
	ldy     #$01
;
; while(currentHashEntry != NULL) {
;
	jmp     L1550
;
; currentReference = currentHashEntry->content;
;
L154B:	jsr     ldaxysp
	ldy     #$03
;
; while(currentReference != NULL) {
;
	jmp     L1551
;
; currentReference->referenceType == REF_EXPRESSION &&
;
L154C:	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	cpx     #$00
	jne     L048E
	cmp     #$02
	jne     L048E
;
; currentReference->reference.calculatedPtr.expressionPtr->containsAggregates == runAggregates &&
;
	ldy     #$09
	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	ldy     #$07
	jsr     ldaxidx
	ldy     #$0E
	cmp     (sp),y
	jne     L048E
	txa
	iny
	cmp     (sp),y
	jne     L048E
;
; (currentResultColumn = currentReference->reference.calculatedPtr.firstResultColumn) != NULL
;
	ldy     #$09
	jsr     ldaxysp
	ldy     #$07
	jsr     ldaxidx
	ldy     #$06
	jsr     staxysp
;
; ) {
;
	cpx     #$00
	bne     L048F
	cmp     #$00
	jeq     L048E
;
; j = currentResultColumn->resultColumnIndex;
;
L048F:	ldy     #$07
	jsr     ldaxysp
	jsr     ldaxi
	ldy     #$0A
	jsr     staxysp
;
; match[j].isQuoted = FALSE;
;
	ldy     #$13
	jsr     pushwysp
	ldy     #$0F
	jsr     pushwysp
	lda     #$0E
	jsr     tosmula0
	jsr     tosaddax
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$04
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; match[j].isNormalized = FALSE;
;
	ldy     #$13
	jsr     pushwysp
	ldy     #$0F
	jsr     pushwysp
	lda     #$0E
	jsr     tosmula0
	jsr     tosaddax
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$06
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; match[j].startOffset = 0;   /* ftell(query->scratchpad); */
;
	ldy     #$13
	jsr     pushwysp
	ldy     #$0F
	jsr     pushwysp
	lda     #$0E
	jsr     tosmula0
	jsr     tosaddax
	jsr     pushax
	ldx     #$00
	stx     sreg
	stx     sreg+1
	txa
	tay
	jsr     steaxspidx
;
; getValue(currentReference->reference.calculatedPtr.expressionPtr, &matchParams);
;
	ldy     #$09
	jsr     ldaxysp
	ldy     #$05
	jsr     pushwidx
	lda     #$02
	jsr     leaa0sp
	jsr     _getValue
;
; if(currentReference->reference.calculatedPtr.expressionPtr->leftNull) {
;
	ldy     #$09
	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	ldy     #$08
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	iny
	ora     (ptr1),y
	beq     L04A4
;
; match[j].length = 0;
;
	ldy     #$13
	jsr     pushwysp
	ldy     #$0F
	jsr     pushwysp
	lda     #$0E
	jsr     tosmula0
	jsr     tosaddax
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$0A
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; match[j].leftNull = TRUE;
;
	ldy     #$13
	jsr     pushwysp
	ldy     #$0F
	jsr     pushwysp
	lda     #$0E
	jsr     tosmula0
	jsr     tosaddax
	sta     ptr1
	stx     ptr1+1
	lda     #$01
	ldy     #$08
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; match[j].value = strdup("");
;
	ldy     #$13
	jsr     pushwysp
	ldy     #$0F
	jsr     pushwysp
	lda     #$0E
	jsr     tosmula0
	jsr     tosaddax
	jsr     pushax
	lda     #<(L04AF)
	ldx     #>(L04AF)
	jsr     _strdup
	ldy     #$0C
	jsr     staxspidx
;
; else {
;
	jmp     L04B1
;
; match[j].leftNull = FALSE;
;
L04A4:	ldy     #$13
	jsr     pushwysp
	ldy     #$0F
	jsr     pushwysp
	lda     #$0E
	jsr     tosmula0
	jsr     tosaddax
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$08
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; match[j].length = strlen(currentReference->reference.calculatedPtr.expressionPtr->value);
;
	ldy     #$13
	jsr     pushwysp
	ldy     #$0F
	jsr     pushwysp
	lda     #$0E
	jsr     tosmula0
	jsr     tosaddax
	jsr     pushax
	ldy     #$0B
	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	ldy     #$0D
	jsr     ldaxidx
	jsr     _strlen
	ldy     #$0A
	jsr     staxspidx
;
; match[j].value = currentReference->reference.calculatedPtr.expressionPtr->value;
;
	ldy     #$13
	jsr     pushwysp
	ldy     #$0F
	jsr     pushwysp
	lda     #$0E
	jsr     tosmula0
	jsr     tosaddax
	sta     sreg
	stx     sreg+1
	ldy     #$09
	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	ldy     #$0D
	jsr     ldaxidx
	ldy     #$0C
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; currentReference->reference.calculatedPtr.expressionPtr->value = NULL;
;
L04B1:	ldy     #$09
	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$0C
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; currentReference = currentReference->nextReferenceWithName;
;
L048E:	ldy     #$09
	jsr     ldaxysp
	ldy     #$09
L1551:	jsr     ldaxidx
	ldy     #$08
	jsr     staxysp
;
; while(currentReference != NULL) {
;
	ldy     #$08
	lda     (sp),y
	iny
	ora     (sp),y
	jne     L154C
;
; currentHashEntry = currentHashEntry->nextReferenceInHash;
;
	ldy     #$05
	jsr     ldaxysp
	ldy     #$05
L1550:	jsr     ldaxidx
	ldy     #$04
	jsr     staxysp
;
; while(currentHashEntry != NULL) {
;
	ldy     #$04
	lda     (sp),y
	iny
	ora     (sp),y
	jne     L154B
;
; for(i = 0; i < query->columnReferenceHashTable->size; i++) {
;
	ldy     #$0D
	jsr     ldaxysp
	jsr     incax1
	jmp     L1552
;
; }
;
L0478:	ldy     #$14
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; int __near__ __cdecl__ main (int, __near__ unsigned char * *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

.segment	"CODE"

;
; argc2 = argc;
;
	jsr     decsp4
	ldy     #$07
	jsr     ldaxysp
	ldy     #$02
	jsr     staxysp
;
; argv2 = argv;
;
	ldy     #$05
	jsr     ldaxysp
	jsr     stax0sp
;
; if(getenv(TEMP_VAR) == NULL) {
;
	lda     #<(L04C9)
	ldx     #>(L04C9)
	jsr     _getenv
	cpx     #$00
	bne     L04C7
	cmp     #$00
	bne     L04C7
;
; putenv(DEFAULT_TEMP);
;
	lda     #<(L04CD)
	ldx     #>(L04CD)
	jsr     _putenv
;
; if(getenv("TZ") == NULL) {
;
L04C7:	lda     #<(L04D1)
	ldx     #>(L04D1)
	jsr     _getenv
	cpx     #$00
	bne     L1553
	cmp     #$00
	bne     L1553
;
; putenv(TDB_DEFAULT_TZ);
;
	lda     #<(L04D5)
	ldx     #>(L04D5)
	jsr     _putenv
;
; setlocale(LC_ALL, TDB_LOCALE);
;
L1553:	jsr     push0
	lda     #<(L04D9)
	ldx     #>(L04D9)
	jsr     _setlocale
;
; if(argc2 == 2) {
;
	ldy     #$03
	lda     (sp),y
	bne     L04DB
	dey
	lda     (sp),y
	cmp     #$02
	bne     L04DB
;
; return runQuery(argv2[1]);
;
	jsr     ldax0sp
	ldy     #$03
	jsr     ldaxidx
	jsr     _runQuery
	jmp     L04C2
;
; fputs(TDB_INVALID_COMMAND_LINE, stderr);
;
L04DB:	lda     #<(L04E2)
	ldx     #>(L04E2)
	jsr     pushax
	lda     _stderr
	ldx     _stderr+1
	jsr     _fputs
;
; return -1;
;
	ldx     #$FF
	txa
;
; }
;
L04C2:	jsr     incsp8
	jmp     farret

.endproc

; ---------------------------------------------------------------
; void __near__ groupResults (__near__ struct qryData *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_groupResults: near

.segment	"CODE"

;
; void groupResults(struct qryData *query) {
;
	jsr     pushax
;
; resultsOrig = query->resultSet;
;
	jsr     decsp4
	ldy     #$05
	jsr     ldaxysp
	ldy     #$25
	jsr     ldaxidx
	ldy     #$02
	jsr     staxysp
;
; query->resultSet = NULL;
;
	ldy     #$05
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$24
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; query->match = getFirstRecord(
;
	ldy     #$07
	jsr     pushwysp
;
; resultsOrig,
;
	ldy     #$07
	jsr     pushwysp
;
; );
;
	ldy     #$09
	jsr     ldaxysp
	jsr     _getFirstRecord
	ldy     #$26
	jsr     staxspidx
;
; updateRunningCounts(query, query->match);
;
	ldy     #$07
	jsr     pushwysp
	ldy     #$07
	jsr     ldaxysp
	ldy     #$27
	jsr     ldaxidx
	jsr     _updateRunningCounts
;
; query,
;
	ldy     #$07
	jsr     pushwysp
;
; &(resultsOrig),
;
	lda     #$04
	jsr     leaa0sp
	jsr     pushax
;
; );
;
	lda     #<(_groupResultsInner)
	ldx     #>(_groupResultsInner)
	jsr     _tree_walkAndCleanup
;
; currentResultColumn = query->firstResultColumn;
;
	ldy     #$05
	jsr     ldaxysp
	ldy     #$1D
;
; while(currentResultColumn != NULL) {
;
	jmp     L1557
;
; currentResultColumn->groupingDone = TRUE;
;
L1555:	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$01
	ldy     #$10
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; currentResultColumn = currentResultColumn->nextColumnInResults;
;
	jsr     ldax0sp
	ldy     #$17
L1557:	jsr     ldaxidx
	jsr     stax0sp
;
; while(currentResultColumn != NULL) {
;
	ldy     #$00
	lda     (sp),y
	iny
	ora     (sp),y
	bne     L1555
;
; }
;
	jsr     incsp6
	jmp     farret

.endproc

; ---------------------------------------------------------------
; int __near__ getCsvColumn (__near__ __near__ struct _FILE * *, __near__ __near__ unsigned char * *, __near__ unsigned int *, __near__ int *, __near__ long *, int)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_getCsvColumn: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; char *tempString = NULL;
;
	jsr     decsp2
	jsr     push0
;
; int canEnd = TRUE;
;
	lda     #$01
	jsr     pusha0
;
; int quotePossible = TRUE;
;
	jsr     pusha0
;
; int exitCode = 0;
;
	jsr     push0
;
; char *minSize = NULL;
;
	jsr     push0
;
; long offset = 0;
;
	jsr     pushl0
;
; if(quotedValue != NULL) {
;
	ldy     #$14
	lda     (sp),y
	iny
	ora     (sp),y
	beq     L0509
;
; *quotedValue = FALSE;
;
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	tay
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; if(strSize != NULL) {
;
L0509:	ldy     #$16
	lda     (sp),y
	iny
	ora     (sp),y
	beq     L050E
;
; *strSize = 0;
;
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	tay
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; if(value == NULL) {
;
L050E:	ldy     #$18
	lda     (sp),y
	iny
	ora     (sp),y
	bne     L0513
;
; value = &tempString;
;
	lda     #$0C
	jsr     leaa0sp
	dey
	jsr     staxysp
;
; if(startPosition != NULL) {
;
L0513:	ldy     #$12
	lda     (sp),y
	iny
	ora     (sp),y
	beq     L0518
;
; offset = *startPosition;
;
	jsr     ldaxysp
	jsr     ldeaxi
	jsr     steax0sp
;
; if(feof(*inputFile) != 0) {
;
L0518:	ldy     #$1B
	jsr     ldaxysp
	jsr     ldaxi
	jsr     _feof
	cpx     #$00
	bne     L1561
	cmp     #$00
	beq     L051D
;
; return FALSE;
;
L1561:	ldx     #$00
	txa
	jmp     L0502
;
; offset++;
;
L051D:	jsr     ldeax0sp
	jsr     saveeax
	ldy     #$01
	jsr     inceaxy
	jsr     steax0sp
	jsr     resteax
;
; c = fgetc(*inputFile);
;
	ldy     #$1B
	jsr     ldaxysp
	jsr     ldaxi
	jsr     _fgetc
	ldy     #$0E
	jsr     staxysp
;
; }
;
	cpx     #$00
	bne     L05BE
	cmp     #$00
	jeq     L0564
	cmp     #$0A
	beq     L053A
	cmp     #$0D
	jeq     L054A
	cmp     #$20
	beq     L052D
	cmp     #$22
	jeq     L1559
	cmp     #$2C
	jeq     L05A9
	jmp     L05AA
L05BE:	cpx     #$FF
	jne     L05AA
	cmp     #$FF
	jeq     L056B
	jmp     L05AA
;
; if(!canEnd) {
;
L052D:	ldy     #$0B
	lda     (sp),y
	dey
	ora     (sp),y
	bne     L052E
;
; minSize = &((*value)[*strSize]);
;
	ldy     #$19
	jsr     ldaxysp
	jsr     ldaxi
	sta     sreg
	stx     sreg+1
	ldy     #$17
	jsr     ldaxysp
	jsr     ldaxi
	clc
	adc     sreg
	pha
	txa
	adc     sreg+1
	tax
	pla
	ldy     #$04
	jsr     staxysp
;
; strAppend(' ', value, strSize);
;
L052E:	lda     #$20
;
; break;
;
	jmp     L1569
;
; offset++;
;
L053A:	jsr     ldeax0sp
	jsr     saveeax
	ldy     #$01
	jsr     inceaxy
	jsr     steax0sp
	jsr     resteax
;
; if((c = fgetc(*inputFile)) != '\n' && c != EOF) {
;
	ldy     #$1B
	jsr     ldaxysp
	jsr     ldaxi
	jsr     _fgetc
	ldy     #$0E
	jsr     staxysp
	cpx     #$00
	bne     L1562
	cmp     #$0D
	beq     L053C
L1562:	ldy     #$0F
	lda     (sp),y
	cmp     #$FF
	bne     L053D
	dey
	lda     (sp),y
	cmp     #$FF
	beq     L053C
;
; offset--;
;
L053D:	jsr     ldeax0sp
	jsr     saveeax
	ldy     #$01
	jsr     deceaxy
	jsr     steax0sp
	jsr     resteax
;
; ungetc(c, *inputFile);
;
	ldy     #$11
	jsr     pushwysp
	ldy     #$1D
	jsr     ldaxysp
	jsr     ldaxi
	jsr     _ungetc
;
; else if (c == EOF) {
;
	jmp     L054A
L053C:	ldy     #$0F
	lda     (sp),y
	cmp     #$FF
	bne     L054A
	dey
	lda     (sp),y
	cmp     #$FF
	bne     L054A
;
; exitCode = 2;
;
	ldx     #$00
	lda     #$02
	ldy     #$06
	jsr     staxysp
;
; break;
;
	jmp     L052B
;
; if(canEnd) {
;
L054A:	ldy     #$0B
	lda     (sp),y
	dey
	ora     (sp),y
	beq     L0551
;
; exitCode = 2;
;
	ldx     #$00
	lda     #$02
	ldy     #$06
	jsr     staxysp
;
; break;
;
	jmp     L052B
;
; if (quotedValue != NULL) {
;
L0551:	ldy     #$14
	lda     (sp),y
	iny
	ora     (sp),y
	beq     L0556
;
; *quotedValue = TRUE;
;
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$01
	ldy     #$00
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; strAppend('\r', value, strSize);
;
L0556:	lda     #$0A
	jsr     pusha
	ldy     #$1C
	jsr     pushwysp
	ldy     #$1A
	jsr     ldaxysp
	jsr     _strAppend
;
; strAppend('\n', value, strSize);
;
	lda     #$0D
;
; break;
;
	jmp     L1569
;
; if (quotedValue != NULL) {
;
L0564:	ldy     #$14
	lda     (sp),y
	iny
	ora     (sp),y
	jeq     L052B
;
; *quotedValue = TRUE;
;
	jsr     ldaxysp
	sta     sreg
	stx     sreg+1
	lda     #$01
	ldy     #$00
	sta     (sreg),y
	iny
	lda     #$00
	sta     (sreg),y
;
; break;
;
	jmp     L052B
;
; exitCode = 2;
;
L056B:	inx
	lda     #$02
	ldy     #$06
	jsr     staxysp
;
; break;
;
	jmp     L052B
;
; canEnd = FALSE;
;
L1559:	txa
	ldy     #$0A
	jsr     staxysp
;
; if (quotedValue != NULL) {
;
	ldy     #$14
	lda     (sp),y
	iny
	ora     (sp),y
	beq     L0572
;
; *quotedValue = TRUE;
;
	jsr     ldaxysp
	sta     sreg
	stx     sreg+1
	ldx     #$00
	lda     #$01
	ldy     #$00
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; if(quotePossible) {
;
L0572:	ldy     #$09
	lda     (sp),y
	dey
	ora     (sp),y
	beq     L0577
;
; if(strSize != NULL) {
;
	ldy     #$16
	lda     (sp),y
	iny
	ora     (sp),y
	beq     L155B
;
; *strSize = 0;
;
	jsr     ldaxysp
	sta     sreg
	stx     sreg+1
	lda     #$00
	tay
	sta     (sreg),y
	iny
	sta     (sreg),y
;
; quotePossible = FALSE;
;
	tax
L155B:	ldy     #$08
	jsr     staxysp
;
; else {
;
	jmp     L052B
;
; offset++;
;
L0577:	jsr     ldeax0sp
	jsr     saveeax
	ldy     #$01
	jsr     inceaxy
	jsr     steax0sp
	jsr     resteax
;
; c = fgetc(*inputFile);
;
	ldy     #$1B
	jsr     ldaxysp
	jsr     ldaxi
	jsr     _fgetc
	ldy     #$0E
	jsr     staxysp
;
; }
;
	cpx     #$00
	bne     L05A7
	cmp     #$0A
	beq     L155C
	cmp     #$0D
	beq     L155C
	cmp     #$20
	beq     L155C
	cmp     #$22
	jeq     L1569
	cmp     #$2C
	beq     L155C
	jmp     L059E
L05A7:	cpx     #$FF
	bne     L059E
	cmp     #$FF
	bne     L059E
;
; canEnd = TRUE;
;
	inx
L155C:	lda     #$01
	ldy     #$0A
	jsr     staxysp
;
; offset--;
;
	jsr     ldeax0sp
	jsr     saveeax
	ldy     #$01
	jsr     deceaxy
	jsr     steax0sp
	jsr     resteax
;
; ungetc(c, *inputFile);
;
	ldy     #$11
	jsr     pushwysp
	ldy     #$1D
	jsr     ldaxysp
	jsr     ldaxi
	jsr     _ungetc
;
; break;
;
	jmp     L052B
;
; strAppend('"', value, strSize);
;
L059E:	lda     #$22
	jsr     pusha
	ldy     #$1C
	jsr     pushwysp
	ldy     #$1A
	jsr     ldaxysp
	jsr     _strAppend
;
; offset--;
;
	jsr     ldeax0sp
	jsr     saveeax
	ldy     #$01
	jsr     deceaxy
	jsr     steax0sp
	jsr     resteax
;
; ungetc(c, *inputFile);
;
	ldy     #$11
	jsr     pushwysp
	ldy     #$1D
	jsr     ldaxysp
	jsr     ldaxi
	jsr     _ungetc
;
; break;
;
	jmp     L052B
;
; if(canEnd) {
;
L05A9:	ldy     #$0B
	lda     (sp),y
	dey
	ora     (sp),y
	beq     L05AA
;
; exitCode = 1;
;
	lda     #$01
	ldy     #$06
	jsr     staxysp
;
; break;
;
	jmp     L052B
;
; if(doTrim && quotePossible) {
;
L05AA:	ldy     #$11
	lda     (sp),y
	dey
	ora     (sp),y
	beq     L1564
	ldy     #$09
	lda     (sp),y
	dey
	ora     (sp),y
	beq     L1564
	ldx     #$00
;
; if(strSize != NULL) {
;
	ldy     #$16
	lda     (sp),y
	iny
	ora     (sp),y
	beq     L155F
;
; *strSize = 0;
;
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	tay
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; quotePossible = FALSE;
;
L1564:	tax
L155F:	ldy     #$08
	jsr     staxysp
;
; strAppend(c, value, strSize);
;
	ldy     #$0E
	lda     (sp),y
L1569:	jsr     pusha
	ldy     #$1C
	jsr     pushwysp
	ldy     #$1A
	jsr     ldaxysp
	jsr     _strAppend
;
; } while (exitCode == 0);
;
L052B:	ldy     #$06
	lda     (sp),y
	iny
	ora     (sp),y
	jeq     L051D
;
; if(doTrim) {
;
	ldy     #$11
	lda     (sp),y
	dey
	ora     (sp),y
	beq     L1560
;
; strRTrim(value, strSize, minSize);
;
	ldy     #$1B
	jsr     pushwysp
	ldy     #$1B
	jsr     pushwysp
	ldy     #$09
	jsr     ldaxysp
	jsr     _strRTrim
;
; strAppend('\0', value, strSize);
;
	lda     #$00
L1560:	jsr     pusha
	ldy     #$1C
	jsr     pushwysp
	ldy     #$1A
	jsr     ldaxysp
	jsr     _strAppend
;
; if(strSize != NULL) {
;
	ldy     #$16
	lda     (sp),y
	iny
	ora     (sp),y
	beq     L05CB
;
; (*strSize)--;
;
	jsr     ldaxysp
	jsr     pushax
	jsr     ldaxi
	sta     regsave
	stx     regsave+1
	jsr     decax1
	ldy     #$00
	jsr     staxspidx
;
; if(startPosition != NULL) {
;
L05CB:	ldy     #$12
	lda     (sp),y
	iny
	ora     (sp),y
	beq     L05D0
;
; *startPosition = offset;
;
	ldy     #$15
	jsr     pushwysp
	ldy     #$05
	jsr     ldeaxysp
	ldy     #$00
	jsr     steaxspidx
;
; free(tempString);
;
L05D0:	ldy     #$0D
	jsr     ldaxysp
	jsr     _free
;
; return exitCode == 1;
;
	ldy     #$07
	jsr     ldaxysp
	cpx     #$00
	bne     L05D8
	cmp     #$01
L05D8:	jsr     booleq
;
; }
;
L0502:	ldy     #$1C
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; void __near__ parse_whereClause (__near__ struct qryData *, __near__ struct expression *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_parse_whereClause: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; if(queryData->parseMode != 1) {
;
	jsr     decsp4
	ldy     #$07
	jsr     ldaxysp
	jsr     ldaxi
	cpx     #$00
	jne     L05E2
	cmp     #$01
;
; return;
;
	jne     L05E2
;
; if(queryData->joinsAndWhereClause == NULL) {
;
	ldy     #$07
	jsr     ldaxysp
	ldy     #$1F
	jsr     ldaxidx
	cpx     #$00
	bne     L05DD
	cmp     #$00
	bne     L05DD
;
; queryData->joinsAndWhereClause = expressionPtr;
;
	ldy     #$07
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$05
;
; else {
;
	jmp     L157C
;
; currentClauses = queryData->joinsAndWhereClause;
;
L05DD:	ldy     #$07
	jsr     ldaxysp
	ldy     #$1F
	jsr     ldaxidx
	ldy     #$02
	jsr     staxysp
;
; newClause = NULL;
;
	ldx     #$00
	txa
	jsr     stax0sp
;
; (void**)&(newClause),
;
	lda     sp
	ldx     sp+1
	jsr     pushax
;
; );
;
	ldx     #$00
	lda     #$12
	jsr     _reallocMsg
;
; newClause->type = EXP_AND;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	lda     #$0B
	ldy     #$00
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; newClause->value = NULL;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$0C
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; expressionPtr->minTable < currentClauses->minTable ||
;
	ldy     #$05
	jsr     ldaxysp
	ldy     #$03
	jsr     pushwidx
	ldy     #$05
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	jsr     tosicmp
	bmi     L1571
;
; (expressionPtr->minTable == currentClauses->minTable &&
;
	ldy     #$05
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	sta     sreg
	stx     sreg+1
	ldy     #$03
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	cpx     sreg+1
	bne     L05EF
	cmp     sreg
	bne     L05EF
;
; expressionPtr->minColumn < currentClauses->minColumn)
;
	ldy     #$05
	jsr     ldaxysp
	ldy     #$05
	jsr     pushwidx
	ldy     #$05
	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	jsr     tosicmp
	bpl     L05EF
;
; newClause->unionPtrs.leaves.leftPtr = expressionPtr;
;
L1571:	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$05
	jsr     ldaxysp
	ldy     #$0E
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; newClause->unionPtrs.leaves.rightPtr = currentClauses;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$03
	jsr     ldaxysp
	ldy     #$10
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; newClause->minColumn = currentClauses->minColumn;
;
	jsr     ldax0sp
	sta     sreg
	stx     sreg+1
	ldy     #$03
	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	ldy     #$04
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; newClause->minTable = currentClauses->minTable;
;
	jsr     ldax0sp
	sta     sreg
	stx     sreg+1
	ldy     #$03
;
; else {
;
	jmp     L157F
;
; newClause->unionPtrs.leaves.leftPtr = currentClauses;
;
L05EF:	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$03
	jsr     ldaxysp
	ldy     #$0E
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; newClause->unionPtrs.leaves.rightPtr = expressionPtr;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$05
	jsr     ldaxysp
	ldy     #$10
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; newClause->minColumn = expressionPtr->minColumn;
;
	jsr     ldax0sp
	sta     sreg
	stx     sreg+1
	ldy     #$05
	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	ldy     #$04
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; newClause->minTable = expressionPtr->minTable;
;
	jsr     ldax0sp
	sta     sreg
	stx     sreg+1
	ldy     #$05
L157F:	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	ldy     #$02
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; queryData->joinsAndWhereClause = newClause;
;
	ldy     #$07
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$01
L157C:	jsr     ldaxysp
	ldy     #$1E
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; }
;
L05E2:	jsr     incsp8
	jmp     farret

.endproc

; ---------------------------------------------------------------
; void __near__ parse_groupingSpec (__near__ struct qryData *, __near__ struct expression *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_parse_groupingSpec: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; struct sortingList *sortingListPtr = NULL;
;
	jsr     push0
;
; if(queryData->parseMode != 1) {
;
	ldy     #$05
	jsr     ldaxysp
	jsr     ldaxi
	cpx     #$00
	jne     L061C
	cmp     #$01
;
; return;
;
	jne     L061C
;
; (void**)&(sortingListPtr),
;
	lda     sp
	ldx     sp+1
	jsr     pushax
;
; );
;
	ldx     #$00
	lda     #$06
	jsr     _reallocMsg
;
; sortingListPtr->expressionPtr = expressionPtr;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$03
	jsr     ldaxysp
	ldy     #$00
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; sortingListPtr->isDescending = FALSE;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$02
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; if(queryData->groupByClause == NULL) {
;
	ldy     #$05
	jsr     ldaxysp
	ldy     #$23
	jsr     ldaxidx
	cpx     #$00
	bne     L0615
	cmp     #$00
	bne     L0615
;
; sortingListPtr->nextInList = sortingListPtr;
;
	jsr     ldax0sp
;
; else {
;
	jmp     L1593
;
; sortingListPtr->nextInList = queryData->groupByClause->nextInList;
;
L0615:	jsr     ldax0sp
	sta     sreg
	stx     sreg+1
	ldy     #$05
	jsr     ldaxysp
	ldy     #$23
	jsr     ldaxidx
	ldy     #$05
	jsr     ldaxidx
	ldy     #$04
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; queryData->groupByClause->nextInList = sortingListPtr;
;
	jsr     ldaxysp
	ldy     #$23
	jsr     ldaxidx
L1593:	sta     ptr1
	stx     ptr1+1
	jsr     ldax0sp
	ldy     #$04
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; queryData->groupByClause = sortingListPtr;
;
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	jsr     ldax0sp
	ldy     #$22
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; }
;
L061C:	jsr     incsp6
	jmp     farret

.endproc

; ---------------------------------------------------------------
; void __near__ cleanup_inputColumns (__near__ struct inputColumn *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_cleanup_inputColumns: near

.segment	"CODE"

;
; void cleanup_inputColumns(struct inputColumn *currentInputColumn) {
;
	jsr     pushax
;
; while(currentInputColumn != NULL) {
;
	jsr     decsp2
	jmp     L0626
;
; next = currentInputColumn->nextColumnInTable;
;
L1594:	jsr     ldaxysp
	ldy     #$09
	jsr     ldaxidx
	jsr     stax0sp
;
; free(currentInputColumn);
;
	ldy     #$03
	jsr     ldaxysp
	jsr     _free
;
; currentInputColumn = next;
;
	jsr     ldax0sp
	ldy     #$02
	jsr     staxysp
;
; while(currentInputColumn != NULL) {
;
L0626:	ldy     #$02
	lda     (sp),y
	iny
	ora     (sp),y
	bne     L1594
;
; }
;
	jsr     incsp4
	jmp     farret

.endproc

; ---------------------------------------------------------------
; void __near__ cleanup_atomList (__near__ struct atomEntry *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_cleanup_atomList: near

.segment	"CODE"

;
; void cleanup_atomList(struct atomEntry *currentAtom) {
;
	jsr     pushax
;
; while(currentAtom != NULL) {
;
	jsr     decsp2
	jmp     L0632
;
; next = currentAtom->nextInList;
;
L1595:	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	jsr     stax0sp
;
; free(currentAtom->content);
;
	ldy     #$03
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	jsr     _free
;
; free(currentAtom);
;
	ldy     #$03
	jsr     ldaxysp
	jsr     _free
;
; currentAtom = next;
;
	jsr     ldax0sp
	ldy     #$02
	jsr     staxysp
;
; while(currentAtom != NULL) {
;
L0632:	ldy     #$02
	lda     (sp),y
	iny
	ora     (sp),y
	bne     L1595
;
; }
;
	jsr     incsp4
	jmp     farret

.endproc

; ---------------------------------------------------------------
; void __near__ exp_uminus (__near__ __near__ unsigned char * *, unsigned long)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_exp_uminus: near

.segment	"CODE"

;
; void exp_uminus(char **value, double leftVal) {
;
	jsr     pusheax
;
; temp = ctof(0);
;
	jsr     decsp4
	lda     #$00
	jsr     __ctof
	jsr     steax0sp
;
; if(fcmp(leftVal, temp)) {
;
	ldy     #$07
	jsr     ldeaxysp
	jsr     pusheax
	ldy     #$07
	jsr     ldeaxysp
	jsr     __fcmp
	tax
	beq     L0642
;
; temp = fneg(leftVal);
;
	ldy     #$07
	jsr     ldeaxysp
	jsr     __fneg
	jsr     steax0sp
;
; ftostr(value, temp);
;
	ldy     #$0B
	jsr     pushwysp
	ldx     #$00
	lda     #$21
	jsr     _reallocMsg
	ldy     #$09
	jsr     ldaxysp
	jsr     pushw
	ldy     #$05
	jsr     ldeaxysp
	jsr     __ftostr
	ldy     #$0B
	jsr     pushwysp
	ldy     #$0B
	jsr     ldaxysp
	jsr     ldaxi
	jsr     _strlen
	jsr     incax1
	jsr     _reallocMsg
;
; else {
;
	jmp     L0657
;
; *value = strdup("0");
;
L0642:	ldy     #$0B
	jsr     pushwysp
	lda     #<(L065A)
	ldx     #>(L065A)
	jsr     _strdup
	ldy     #$00
	jsr     staxspidx
;
; }
;
L0657:	ldy     #$0A
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; void __near__ hash_freeTable (__near__ struct columnReferenceHash *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_hash_freeTable: near

.segment	"CODE"

;
; void hash_freeTable(struct columnReferenceHash *hashtable) {
;
	jsr     pushax
;
; if (hashtable==NULL) {
;
	jsr     decsp6
	ldy     #$06
	lda     (sp),y
	iny
	ora     (sp),y
;
; return;
;
	jeq     L065C
;
; for(i=0; i<hashtable->size; i++) {
;
	ldx     #$00
	txa
L1598:	ldy     #$04
	jsr     staxysp
	jsr     pushax
	ldy     #$09
	jsr     ldaxysp
	jsr     ldaxi
	jsr     tosicmp
	bpl     L0661
;
; list = hashtable->table[i];
;
	ldy     #$07
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	sta     ptr1
	stx     ptr1+1
	ldy     #$05
	jsr     ldaxysp
	jsr     aslax1
	clc
	adc     ptr1
	pha
	txa
	adc     ptr1+1
	tax
	pla
	jsr     ldaxi
	ldy     #$02
	jsr     staxysp
;
; while(list!=NULL) {
;
	jmp     L066D
;
; temp = list;
;
L1596:	jsr     ldaxysp
	jsr     stax0sp
;
; list = list->nextReferenceInHash;
;
	ldy     #$03
	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	ldy     #$02
	jsr     staxysp
;
; free(temp->referenceName);
;
	jsr     ldax0sp
	jsr     ldaxi
	jsr     _free
;
; free(temp);
;
	jsr     ldax0sp
	jsr     _free
;
; while(list!=NULL) {
;
L066D:	ldy     #$02
	lda     (sp),y
	iny
	ora     (sp),y
	bne     L1596
;
; for(i=0; i<hashtable->size; i++) {
;
	ldy     #$05
	jsr     ldaxysp
	jsr     incax1
	jmp     L1598
;
; free(hashtable->table);
;
L0661:	ldy     #$07
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	jsr     _free
;
; free(hashtable);
;
	ldy     #$07
	jsr     ldaxysp
	jsr     _free
;
; }
;
L065C:	jsr     incsp8
	jmp     farret

.endproc

; ---------------------------------------------------------------
; __near__ struct expression * __near__ parse_scalarExp (__near__ struct qryData *, __near__ struct expression *, int, __near__ struct expression *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_parse_scalarExp: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; struct expression *expressionPtr = NULL;
;
	jsr     push0
;
; if(queryData->parseMode != 1) {
;
	ldy     #$09
	jsr     ldaxysp
	jsr     ldaxi
	cpx     #$00
	bne     L15A3
	cmp     #$01
	beq     L067E
;
; return NULL;
;
L15A3:	ldx     #$00
	txa
	jmp     L067C
;
; reallocMsg((void**)(&expressionPtr), sizeof(struct expression));
;
L067E:	lda     sp
	ldx     sp+1
	jsr     pushax
	ldx     #$00
	lda     #$12
	jsr     _reallocMsg
;
; expressionPtr->type = operator;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$05
	jsr     ldaxysp
	ldy     #$00
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; expressionPtr->value = NULL;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$0C
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; if(rightPtr == NULL) {
;
	ldy     #$02
	lda     (sp),y
	iny
	ora     (sp),y
	bne     L159D
;
; expressionPtr->unionPtrs.leaves.leftPtr = leftPtr;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$07
	jsr     ldaxysp
	ldy     #$0E
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; expressionPtr->unionPtrs.leaves.rightPtr = NULL;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$10
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; expressionPtr->minColumn = leftPtr->minColumn;
;
	jsr     ldax0sp
	sta     sreg
	stx     sreg+1
	ldy     #$07
	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	ldy     #$04
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; expressionPtr->minTable = leftPtr->minTable;
;
	jsr     ldax0sp
	sta     sreg
	stx     sreg+1
	ldy     #$07
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	ldy     #$02
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; expressionPtr->containsAggregates = leftPtr->containsAggregates;
;
	jsr     ldax0sp
	sta     sreg
	stx     sreg+1
	ldy     #$07
	jsr     ldaxysp
	ldy     #$07
	jsr     ldaxidx
	ldy     #$06
	sta     (sreg),y
	iny
	txa
;
; else if(rightPtr->minTable < leftPtr->minTable ||
;
	jmp     L15A8
L159D:	jsr     ldaxysp
	ldy     #$03
	jsr     pushwidx
	ldy     #$09
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	jsr     tosicmp
	bmi     L15A1
;
; (rightPtr->minTable == leftPtr->minTable &&
;
	ldy     #$03
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	sta     sreg
	stx     sreg+1
	ldy     #$07
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	cpx     sreg+1
	jne     L0698
	cmp     sreg
	jne     L0698
;
; rightPtr->minColumn < leftPtr->minColumn)
;
	ldy     #$03
	jsr     ldaxysp
	ldy     #$05
	jsr     pushwidx
	ldy     #$09
	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	jsr     tosicmp
	jpl     L0698
;
; operator == EXP_PLUS ||
;
L15A1:	ldy     #$05
	lda     (sp),y
	bne     L15AA
	dey
	lda     (sp),y
	cmp     #$04
	beq     L15A2
;
; operator == EXP_MULTIPLY ||
;
	iny
L15AA:	lda     (sp),y
	bne     L15AB
	dey
	lda     (sp),y
	cmp     #$06
	beq     L15A2
;
; operator == EXP_AND ||
;
	iny
L15AB:	lda     (sp),y
	bne     L15AC
	dey
	lda     (sp),y
	cmp     #$0B
	beq     L15A2
;
; operator == EXP_OR
;
	iny
L15AC:	lda     (sp),y
;
; ) {
;
	bne     L069E
;
; operator == EXP_OR
;
	dey
	lda     (sp),y
;
; ) {
;
	cmp     #$0C
	bne     L069E
;
; expressionPtr->unionPtrs.leaves.leftPtr = rightPtr;
;
L15A2:	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$03
	jsr     ldaxysp
	ldy     #$0E
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; expressionPtr->unionPtrs.leaves.rightPtr = leftPtr;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$07
;
; else {
;
	jmp     L15B4
;
; expressionPtr->unionPtrs.leaves.leftPtr = leftPtr;
;
L069E:	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$07
	jsr     ldaxysp
	ldy     #$0E
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; expressionPtr->unionPtrs.leaves.rightPtr = rightPtr;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$03
L15B4:	jsr     ldaxysp
	ldy     #$10
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; expressionPtr->minColumn = leftPtr->minColumn;
;
	jsr     ldax0sp
	sta     sreg
	stx     sreg+1
	ldy     #$07
	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	ldy     #$04
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; expressionPtr->minTable = leftPtr->minTable;
;
	jsr     ldax0sp
	sta     sreg
	stx     sreg+1
	ldy     #$07
;
; else {
;
	jmp     L15D2
;
; expressionPtr->unionPtrs.leaves.leftPtr = leftPtr;
;
L0698:	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$07
	jsr     ldaxysp
	ldy     #$0E
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; expressionPtr->unionPtrs.leaves.rightPtr = rightPtr;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$03
	jsr     ldaxysp
	ldy     #$10
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; expressionPtr->minColumn = rightPtr->minColumn;
;
	jsr     ldax0sp
	sta     sreg
	stx     sreg+1
	ldy     #$03
	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	ldy     #$04
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; expressionPtr->minTable = rightPtr->minTable;
;
	jsr     ldax0sp
	sta     sreg
	stx     sreg+1
	ldy     #$03
L15D2:	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	ldy     #$02
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; expressionPtr->containsAggregates = (leftPtr->containsAggregates) || (rightPtr->containsAggregates);
;
	jsr     ldax0sp
	sta     sreg
	stx     sreg+1
	ldy     #$07
	jsr     ldaxysp
	ldy     #$06
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	iny
	ora     (ptr1),y
	bne     L06C1
	ldy     #$03
	jsr     ldaxysp
	ldy     #$06
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	iny
	ora     (ptr1),y
	beq     L06C4
L06C1:	lda     #$01
L06C4:	dey
	sta     (sreg),y
	iny
	lda     #$00
L15A8:	sta     (sreg),y
;
; return expressionPtr;
;
	jsr     ldax0sp
;
; }
;
L067C:	ldy     #$0A
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; void __near__ cleanup_columnReferences (__near__ struct columnReferenceHash *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_cleanup_columnReferences: near

.segment	"CODE"

;
; void cleanup_columnReferences(struct columnReferenceHash *table) {
;
	jsr     pushax
;
; for(i=0; i<table->size; i++) {
;
	ldy     #$0A
	jsr     subysp
	ldx     #$00
	txa
L15D8:	ldy     #$08
	jsr     staxysp
	jsr     pushax
	ldy     #$0D
	jsr     ldaxysp
	jsr     ldaxi
	jsr     tosicmp
	jpl     L06C8
;
; currentHashEntry = table->table[i];
;
	ldy     #$0B
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	sta     ptr1
	stx     ptr1+1
	ldy     #$09
	jsr     ldaxysp
	jsr     aslax1
	clc
	adc     ptr1
	pha
	txa
	adc     ptr1+1
	tax
	pla
	jsr     ldaxi
;
; while(currentHashEntry != NULL) {
;
	jmp     L15D6
;
; nextHashEntry = currentHashEntry->nextReferenceInHash;
;
L15D4:	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	ldy     #$04
	jsr     staxysp
;
; free(currentHashEntry->referenceName);
;
	ldy     #$07
	jsr     ldaxysp
	jsr     ldaxi
	jsr     _free
;
; currentReference = currentHashEntry->content;
;
	ldy     #$07
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	ldy     #$02
	jsr     staxysp
;
; free(currentHashEntry);
;
	ldy     #$07
	jsr     ldaxysp
	jsr     _free
;
; while(currentReference != NULL) {
;
	jmp     L06E1
;
; nextReference = currentReference->nextReferenceWithName;
;
L15D5:	jsr     ldaxysp
	ldy     #$09
	jsr     ldaxidx
	jsr     stax0sp
;
; if(currentReference->referenceType == REF_COLUMN) {
;
	ldy     #$03
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	cpx     #$00
	bne     L06E6
	cmp     #$01
	bne     L06E6
;
; free(currentReference->reference.columnPtr);
;
	ldy     #$03
	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	jsr     _free
;
; if(currentReference->referenceType == REF_EXPRESSION) {
;
L06E6:	ldy     #$03
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	cpx     #$00
	bne     L06EB
	cmp     #$02
	bne     L06EB
;
; cleanup_expression(currentReference->reference.calculatedPtr.expressionPtr);
;
	ldy     #$03
	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	jsr     _cleanup_expression
;
; free(currentReference);
;
L06EB:	ldy     #$03
	jsr     ldaxysp
	jsr     _free
;
; currentReference = nextReference;
;
	jsr     ldax0sp
	ldy     #$02
	jsr     staxysp
;
; while(currentReference != NULL) {
;
L06E1:	ldy     #$02
	lda     (sp),y
	iny
	ora     (sp),y
	bne     L15D5
;
; currentHashEntry = nextHashEntry;
;
	ldy     #$05
	jsr     ldaxysp
L15D6:	ldy     #$06
	jsr     staxysp
;
; while(currentHashEntry != NULL) {
;
	ldy     #$06
	lda     (sp),y
	iny
	ora     (sp),y
	jne     L15D4
;
; for(i=0; i<table->size; i++) {
;
	ldy     #$09
	jsr     ldaxysp
	jsr     incax1
	jmp     L15D8
;
; free(table->table);
;
L06C8:	ldy     #$0B
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	jsr     _free
;
; free(table);
;
	ldy     #$0B
	jsr     ldaxysp
	jsr     _free
;
; }
;
	ldy     #$0C
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; __near__ struct expression * __near__ parse_inPredicate (__near__ struct qryData *, __near__ struct expression *, int, __near__ struct atomEntry *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_parse_inPredicate: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; struct expression *expressionPtr = NULL;
;
	jsr     push0
;
; if(queryData->parseMode != 1) {
;
	ldy     #$09
	jsr     ldaxysp
	jsr     ldaxi
	cpx     #$00
	bne     L15D9
	cmp     #$01
	beq     L06FC
;
; return NULL;
;
L15D9:	ldx     #$00
	txa
	jmp     L06FA
;
; reallocMsg((void**)(&expressionPtr), sizeof(struct expression));
;
L06FC:	lda     sp
	ldx     sp+1
	jsr     pushax
	ldx     #$00
	lda     #$12
	jsr     _reallocMsg
;
; expressionPtr->type = isNotIn==TRUE?EXP_NOTIN:EXP_IN;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$05
	lda     (sp),y
	bne     L0707
	dey
	lda     (sp),y
	cmp     #$01
	bne     L0707
	lda     #$15
	jmp     L0709
L0707:	lda     #$14
L0709:	ldy     #$00
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; expressionPtr->value = NULL;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$0C
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; expressionPtr->unionPtrs.inLeaves.leftPtr = leftPtr;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$07
	jsr     ldaxysp
	ldy     #$0E
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; expressionPtr->unionPtrs.inLeaves.lastEntryPtr = lastEntryPtr;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$03
	jsr     ldaxysp
	ldy     #$10
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; expressionPtr->minColumn = leftPtr->minColumn;
;
	jsr     ldax0sp
	sta     sreg
	stx     sreg+1
	ldy     #$07
	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	ldy     #$04
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; expressionPtr->minTable = leftPtr->minTable;
;
	jsr     ldax0sp
	sta     sreg
	stx     sreg+1
	ldy     #$07
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	ldy     #$02
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; expressionPtr->containsAggregates = leftPtr->containsAggregates;
;
	jsr     ldax0sp
	sta     sreg
	stx     sreg+1
	ldy     #$07
	jsr     ldaxysp
	ldy     #$07
	jsr     ldaxidx
	ldy     #$06
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; return expressionPtr;
;
	jsr     ldax0sp
;
; }
;
L06FA:	ldy     #$0A
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; void __near__ exp_divide (__near__ __near__ unsigned char * *, unsigned long, unsigned long)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_exp_divide: near

.segment	"CODE"

;
; void exp_divide(char **value, double leftVal, double rightVal) {
;
	jsr     pusheax
;
; temp = ctof(0);
;
	jsr     decsp4
	lda     #$00
	jsr     __ctof
	jsr     steax0sp
;
; if(fcmp(rightVal, temp)) {
;
	ldy     #$07
	jsr     ldeaxysp
	jsr     pusheax
	ldy     #$07
	jsr     ldeaxysp
	jsr     __fcmp
	tax
	beq     L071D
;
; temp = fdiv(leftVal, rightVal);
;
	ldy     #$0B
	jsr     ldeaxysp
	jsr     pusheax
	ldy     #$0B
	jsr     ldeaxysp
	jsr     __fdiv
	jsr     steax0sp
;
; ftostr(value, temp);
;
	ldy     #$0F
	jsr     pushwysp
	ldx     #$00
	lda     #$21
	jsr     _reallocMsg
	ldy     #$0D
	jsr     ldaxysp
	jsr     pushw
	ldy     #$05
	jsr     ldeaxysp
	jsr     __ftostr
	ldy     #$0F
	jsr     pushwysp
	ldy     #$0F
	jsr     ldaxysp
	jsr     ldaxi
	jsr     _strlen
	jsr     incax1
	jsr     _reallocMsg
;
; else {
;
	jmp     L0735
;
; *value = strdup("Infinity");
;
L071D:	ldy     #$0F
	jsr     pushwysp
	lda     #<(L0738)
	ldx     #>(L0738)
	jsr     _strdup
	ldy     #$00
	jsr     staxspidx
;
; }
;
L0735:	ldy     #$0E
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; int __near__ strCompare (__near__ __near__ unsigned char * *, __near__ __near__ unsigned char * *, int, __near__ __near__ function returning void *, __near__ __near__ function returning void *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_strCompare: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; unsigned char *offset1 = *str1, *offset2 = *str2;
;
	ldy     #$09
	jsr     ldaxysp
	jsr     pushw
	ldy     #$09
	jsr     ldaxysp
	jsr     pushw
;
; long char1 = 0, char2 = 0;
;
	ldx     #$00
	stx     sreg
	stx     sreg+1
	jsr     pushl0
	jsr     pushl0
;
; int firstChar = TRUE, comparison = 0, char1found = FALSE;
;
	jsr     decsp4
	lda     #$01
	jsr     pusha0
	jsr     push0
	jsr     push0
;
; int bytesMatched1 = 0, bytesMatched2 = 0;
;
	jsr     push0
	jsr     push0
;
; int accentcheck = 0, combinerResult;
;
	jsr     push0
;
; for( ; ; ) {  /* we'll quit from this function via other means */
;
	jsr     decsp2
;
; if (*offset2 == 0) {
;
L0748:	ldy     #$1B
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	bne     L0749
;
; if(*offset1 == 0) {
;
	ldy     #$1D
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     (ptr1,x)
	bne     L15DF
;
; if(accentcheck == 0) {
;
	ldy     #$02
	lda     (sp),y
	iny
	ora     (sp),y
;
; return 0;
;
	jeq     L0746
;
; accentcheck = 2;
;
	lda     #$02
	dey
	jsr     staxysp
;
; if(caseSensitive == 2) {
;
	ldy     #$23
	lda     (sp),y
	bne     L0754
	dey
	lda     (sp),y
	cmp     #$02
	bne     L0754
;
; caseSensitive = 1;
;
	lda     #$01
	jsr     staxysp
;
; offset1 = *str1;
;
L0754:	ldy     #$27
	jsr     ldaxysp
	jsr     ldaxi
	ldy     #$1C
	jsr     staxysp
;
; offset2 = *str2;
;
	ldy     #$25
	jsr     ldaxysp
	jsr     ldaxi
	ldy     #$1A
	jsr     staxysp
;
; continue;
;
	jmp     L0748
;
; return 1;
;
L15DF:	lda     #$01
	jmp     L0746
;
; else if(*offset1 == 0) {
;
L0749:	ldy     #$1D
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	bne     L075F
;
; return -1;
;
	ldx     #$FF
	txa
	jmp     L0746
;
; else if (char1found == 0) {
;
L075F:	ldy     #$08
	lda     (sp),y
	iny
	ora     (sp),y
	jne     L15E0
;
; char1 = (*((int (*)(unsigned char **, unsigned char **, int,  int *, void (*)()))get1))(&offset1, str1, 0, &bytesMatched1, get1);
;
	ldy     #$23
	jsr     pushwysp
	lda     #$1E
	jsr     leaa0sp
	jsr     pushax
	ldy     #$2D
	jsr     pushwysp
	jsr     push0
	lda     #$0E
	jsr     leaa0sp
	jsr     pushax
	ldy     #$2B
	jsr     ldaxysp
	pha
	ldy     #$08
	lda     (sp),y
	sta     jmpvec+1
	iny
	lda     (sp),y
	sta     jmpvec+2
	pla
	jsr     jmpvec
	jsr     incsp2
	jsr     axlong
	ldy     #$16
	jsr     steaxysp
;
; if (char1 != 0x34F) {
;
	ldy     #$19
	jsr     ldeaxysp
	jsr     pusheax
	ldx     #$03
	lda     #$00
	sta     sreg
	sta     sreg+1
	lda     #$4F
	jsr     tosneeax
	jeq     L076F
;
; char2 = (*((int (*)(unsigned char **, unsigned char **, int,  int *, void (*)()))get2))(&offset2, str2, 0, &bytesMatched2, get2);
;
	ldy     #$21
	jsr     pushwysp
	lda     #$1C
	jsr     leaa0sp
	jsr     pushax
	ldy     #$2B
	jsr     pushwysp
	jsr     push0
	lda     #$0C
	jsr     leaa0sp
	jsr     pushax
	ldy     #$29
	jsr     ldaxysp
	pha
	ldy     #$08
	lda     (sp),y
	sta     jmpvec+1
	iny
	lda     (sp),y
	sta     jmpvec+2
	pla
	jsr     jmpvec
	jsr     incsp2
	jsr     axlong
	ldy     #$12
	jsr     steaxysp
;
; if((entry1 = getLookupTableEntry(&offset1, str1, &bytesMatched1, get1, firstChar))) {
;
	lda     #$1C
	jsr     leaa0sp
	jsr     pushax
	ldy     #$2B
	jsr     pushwysp
	lda     #$0A
	jsr     leaa0sp
	jsr     pushax
	ldy     #$29
	jsr     pushwysp
	ldy     #$15
	jsr     ldaxysp
	jsr     _getLookupTableEntry
	ldy     #$10
	jsr     staxysp
	stx     tmp1
	ora     tmp1
	jeq     L077A
;
; if(char2 != 0x34F) {
;
	ldy     #$15
	jsr     ldeaxysp
	jsr     pusheax
	ldx     #$03
	lda     #$00
	sta     sreg
	sta     sreg+1
	lda     #$4F
	jsr     tosneeax
	jeq     L0783
;
; if((entry2 = getLookupTableEntry(&offset2, str2, &bytesMatched2, get2, firstChar))) {
;
	lda     #$1A
	jsr     leaa0sp
	jsr     pushax
	ldy     #$29
	jsr     pushwysp
	lda     #$08
	jsr     leaa0sp
	jsr     pushax
	ldy     #$27
	jsr     pushwysp
	ldy     #$15
	jsr     ldaxysp
	jsr     _getLookupTableEntry
	ldy     #$0E
	jsr     staxysp
	stx     tmp1
	ora     tmp1
	jeq     L0785
;
; if(entry1->script == entry2->script) {
;
	ldy     #$11
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	sta     sreg
	stx     sreg+1
	ldy     #$0F
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	cpx     sreg+1
	jne     L078E
	cmp     sreg
	jne     L078E
;
; if(entry1->index == 0 && entry2->index == 0) {
;
	ldy     #$11
	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	cpx     #$00
	bne     L0790
	cmp     #$00
	bne     L0790
	ldy     #$0F
	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	cpx     #$00
	bne     L0790
	cmp     #$00
	bne     L0790
;
; comparison = strNumberCompare((char *)offset1, (char *)offset2);
;
	ldy     #$1F
	jsr     pushwysp
	ldy     #$1D
	jsr     ldaxysp
	jsr     _strNumberCompare
	ldy     #$0A
;
; else if(caseSensitive == 1) {
;
	jmp     L15DC
L0790:	ldy     #$23
	lda     (sp),y
	bne     L079B
	dey
	lda     (sp),y
	cmp     #$01
	bne     L079B
;
; comparison = entry1->index - entry2->index;
;
	ldy     #$11
	jsr     ldaxysp
	ldy     #$05
	jsr     pushwidx
	ldy     #$11
	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	jsr     tossubax
	ldy     #$0A
;
; else {
;
	jmp     L15DC
;
; comparison = (entry1->index - (entry1->islower)) - (entry2->index - (entry2->islower));
;
L079B:	ldy     #$11
	jsr     ldaxysp
	ldy     #$05
	jsr     pushwidx
	ldy     #$13
	jsr     ldaxysp
	ldy     #$07
	jsr     ldaxidx
	jsr     tossubax
	jsr     pushax
	ldy     #$11
	jsr     ldaxysp
	ldy     #$05
	jsr     pushwidx
	ldy     #$13
	jsr     ldaxysp
	ldy     #$07
	jsr     ldaxidx
	jsr     tossubax
	jsr     tossubax
	ldy     #$0A
	jsr     staxysp
;
; if((entry1->index - entry2->index) != 0 && caseSensitive == 2) {
;
	ldy     #$11
	jsr     ldaxysp
	ldy     #$05
	jsr     pushwidx
	ldy     #$11
	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	jsr     tossubax
	cpx     #$00
	bne     L15E1
	cmp     #$00
	beq     L07A7
L15E1:	ldy     #$23
	lda     (sp),y
	bne     L07A7
	dey
	lda     (sp),y
	cmp     #$02
	bne     L07A7
;
; accentcheck = 1;
;
	ldx     #$00
	lda     #$01
	ldy     #$02
L15DC:	jsr     staxysp
;
; if(comparison != 0) {
;
L07A7:	ldy     #$0A
	lda     (sp),y
	iny
	ora     (sp),y
	jeq     L07C0
;
; return comparison > 0 ? 1 : -1;
;
	jsr     ldaxysp
	cmp     #$01
	txa
	sbc     #$00
	bvs     L07B4
	eor     #$80
L07B4:	bpl     L07B5
	ldx     #$00
	lda     #$01
	jmp     L0746
L07B5:	ldx     #$FF
	txa
	jmp     L0746
;
; return entry1->script > entry2->script ? 1 : -1;
;
L078E:	ldy     #$11
	jsr     ldaxysp
	ldy     #$03
	jsr     pushwidx
	ldy     #$11
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	jsr     tosicmp
	bmi     L07BB
	beq     L07BB
	ldx     #$00
	lda     #$01
	jmp     L0746
L07BB:	ldx     #$FF
	txa
	jmp     L0746
;
; else if(entry1->script != char2) {
;
L0785:	ldy     #$11
	jsr     ldaxysp
	ldy     #$03
	jsr     pushwidx
	ldy     #$17
	jsr     ldeaxysp
	jsr     toslong
	jsr     tosneeax
	beq     L07C0
;
; return (entry1->script > char2) ? 1 : -1;
;
	ldy     #$11
	jsr     ldaxysp
	ldy     #$03
	jsr     pushwidx
	ldy     #$17
	jsr     ldeaxysp
	jsr     toslong
	jsr     tosgteax
	beq     L07C4
	ldx     #$00
	lda     #$01
	jmp     L0746
L07C4:	ldx     #$FF
	txa
	jmp     L0746
;
; str1, str2,
;
L07C0:	ldy     #$29
	jsr     pushwysp
	ldy     #$29
	jsr     pushwysp
;
; &offset1, &offset2,
;
	lda     #$20
	jsr     leaa0sp
	jsr     pushax
	lda     #$20
	jsr     leaa0sp
	jsr     pushax
;
; get1, get2,
;
	ldy     #$2B
	jsr     pushwysp
	ldy     #$2B
	jsr     pushwysp
;
; &bytesMatched1, &bytesMatched2,
;
	lda     #$12
	jsr     leaa0sp
	jsr     pushax
	lda     #$12
	jsr     leaa0sp
	jsr     pushax
;
; &accentcheck)) != 0) {
;
	lda     #$12
	jsr     leaa0sp
	jsr     _consumeCombiningChars
	jsr     stax0sp
	cpx     #$00
	bne     L15E3
	cmp     #$00
	beq     L07C8
;
; return combinerResult;
;
L15E3:	jsr     ldax0sp
	jmp     L0746
;
; if(firstChar) {
;
L07C8:	ldy     #$0D
	lda     (sp),y
	dey
	ora     (sp),y
	jeq     L0748
;
; firstChar = FALSE;
;
	txa
	jsr     staxysp
;
; else {
;
	jmp     L0748
;
; char1found = 1;   /* in lookup */
;
L0783:	ldx     #$00
	lda     #$01
	ldy     #$08
	jsr     staxysp
;
; offset2 += bytesMatched2;
;
	ldy     #$05
	jsr     ldaxysp
	ldy     #$1A
	jsr     addeqysp
;
; else if(char2 != 0x34F) {
;
	jmp     L0748
L077A:	ldy     #$15
	jsr     ldeaxysp
	jsr     pusheax
	ldx     #$03
	lda     #$00
	sta     sreg
	sta     sreg+1
	lda     #$4F
	jsr     tosneeax
	jeq     L07E1
;
; if((entry2 = getLookupTableEntry(&offset2, str2, &bytesMatched2, get2, firstChar))){
;
	lda     #$1A
	jsr     leaa0sp
	jsr     pushax
	ldy     #$29
	jsr     pushwysp
	lda     #$08
	jsr     leaa0sp
	jsr     pushax
	ldy     #$27
	jsr     pushwysp
	ldy     #$15
	jsr     ldaxysp
	jsr     _getLookupTableEntry
	ldy     #$0E
	jsr     staxysp
	stx     tmp1
	ora     tmp1
	beq     L07E3
;
; if(char1 != entry2->script) {
;
	ldy     #$19
	jsr     ldeaxysp
	jsr     pusheax
	ldy     #$13
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	jsr     axlong
	jsr     tosneeax
	beq     L07F5
;
; return (char1 > entry2->script) ? 1: -1;
;
	ldy     #$19
	jsr     ldeaxysp
	jsr     pusheax
	ldy     #$13
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	jsr     axlong
	jsr     tosgteax
	beq     L07F0
	ldx     #$00
	lda     #$01
	jmp     L0746
L07F0:	ldx     #$FF
	txa
	jmp     L0746
;
; else if(char1 != char2) {
;
L07E3:	ldy     #$19
	jsr     ldeaxysp
	jsr     pusheax
	ldy     #$19
	jsr     ldeaxysp
	jsr     tosneeax
	beq     L07F5
;
; return (char1 > char2) ? 1: -1; 
;
	ldy     #$19
	jsr     ldeaxysp
	jsr     pusheax
	ldy     #$19
	jsr     ldeaxysp
	jsr     tosgteax
	beq     L07F9
	ldx     #$00
	lda     #$01
	jmp     L0746
L07F9:	ldx     #$FF
	txa
	jmp     L0746
;
; str1, str2,
;
L07F5:	ldy     #$29
	jsr     pushwysp
	ldy     #$29
	jsr     pushwysp
;
; &offset1, &offset2,
;
	lda     #$20
	jsr     leaa0sp
	jsr     pushax
	lda     #$20
	jsr     leaa0sp
	jsr     pushax
;
; get1, get2,
;
	ldy     #$2B
	jsr     pushwysp
	ldy     #$2B
	jsr     pushwysp
;
; &bytesMatched1, &bytesMatched2,
;
	lda     #$12
	jsr     leaa0sp
	jsr     pushax
	lda     #$12
	jsr     leaa0sp
	jsr     pushax
;
; &accentcheck)) != 0) {
;
	lda     #$12
	jsr     leaa0sp
	jsr     _consumeCombiningChars
	jsr     stax0sp
	cpx     #$00
	bne     L15E4
	cmp     #$00
	beq     L07FD
;
; return combinerResult;
;
L15E4:	jsr     ldax0sp
	jmp     L0746
;
; if(firstChar) {
;
L07FD:	ldy     #$0D
	lda     (sp),y
	dey
	ora     (sp),y
	jeq     L0748
;
; firstChar = FALSE;
;
	txa
	jsr     staxysp
;
; else {
;
	jmp     L0748
;
; char1found = 2;   /* in lookup */
;
L07E1:	ldx     #$00
	lda     #$02
	ldy     #$08
	jsr     staxysp
;
; offset2 += bytesMatched2;
;
	ldy     #$05
	jsr     ldaxysp
	ldy     #$1A
	jsr     addeqysp
;
; else {
;
	jmp     L0748
;
; offset1 += bytesMatched1;
;
L076F:	ldy     #$07
	jsr     ldaxysp
	ldy     #$1C
	jsr     addeqysp
;
; else if (char1found == 1) {
;
	jmp     L0748
L15E0:	lda     (sp),y
	jne     L0819
	dey
	lda     (sp),y
	cmp     #$01
	jne     L0819
;
; char2 = (*((int (*)(unsigned char **, unsigned char **, int,  int *, void (*)()))get2))(&offset1, str1, 0, &bytesMatched2, get2);
;
	ldy     #$21
	jsr     pushwysp
	lda     #$1E
	jsr     leaa0sp
	jsr     pushax
	ldy     #$2D
	jsr     pushwysp
	jsr     push0
	lda     #$0C
	jsr     leaa0sp
	jsr     pushax
	ldy     #$29
	jsr     ldaxysp
	pha
	ldy     #$08
	lda     (sp),y
	sta     jmpvec+1
	iny
	lda     (sp),y
	sta     jmpvec+2
	pla
	jsr     jmpvec
	jsr     incsp2
	jsr     axlong
	ldy     #$12
	jsr     steaxysp
;
; if(char2 != 0x34F) {
;
	ldy     #$15
	jsr     ldeaxysp
	jsr     pusheax
	ldx     #$03
	lda     #$00
	sta     sreg
	sta     sreg+1
	lda     #$4F
	jsr     tosneeax
	jeq     L0825
;
; if((entry2 = getLookupTableEntry(&offset2, str2, &bytesMatched2, get2, firstChar))) {
;
	lda     #$1A
	jsr     leaa0sp
	jsr     pushax
	ldy     #$29
	jsr     pushwysp
	lda     #$08
	jsr     leaa0sp
	jsr     pushax
	ldy     #$27
	jsr     pushwysp
	ldy     #$15
	jsr     ldaxysp
	jsr     _getLookupTableEntry
	ldy     #$0E
	jsr     staxysp
	stx     tmp1
	ora     tmp1
	jeq     L0827
;
; if(entry1->script == entry2->script) {
;
	ldy     #$11
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	sta     sreg
	stx     sreg+1
	ldy     #$0F
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	cpx     sreg+1
	jne     L0830
	cmp     sreg
	jne     L0830
;
; if(entry1->index == 0 && entry2->index == 0) {
;
	ldy     #$11
	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	cpx     #$00
	bne     L0832
	cmp     #$00
	bne     L0832
	ldy     #$0F
	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	cpx     #$00
	bne     L0832
	cmp     #$00
	bne     L0832
;
; comparison = strNumberCompare((char *)offset1, (char *)offset2);
;
	ldy     #$1F
	jsr     pushwysp
	ldy     #$1D
	jsr     ldaxysp
	jsr     _strNumberCompare
	ldy     #$0A
;
; else if(caseSensitive == 1) {
;
	jmp     L15DD
L0832:	ldy     #$23
	lda     (sp),y
	bne     L083D
	dey
	lda     (sp),y
	cmp     #$01
	bne     L083D
;
; comparison = entry1->index - entry2->index;
;
	ldy     #$11
	jsr     ldaxysp
	ldy     #$05
	jsr     pushwidx
	ldy     #$11
	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	jsr     tossubax
	ldy     #$0A
;
; else {
;
	jmp     L15DD
;
; comparison = (entry1->index - (entry1->islower)) - (entry2->index - (entry2->islower));
;
L083D:	ldy     #$11
	jsr     ldaxysp
	ldy     #$05
	jsr     pushwidx
	ldy     #$13
	jsr     ldaxysp
	ldy     #$07
	jsr     ldaxidx
	jsr     tossubax
	jsr     pushax
	ldy     #$11
	jsr     ldaxysp
	ldy     #$05
	jsr     pushwidx
	ldy     #$13
	jsr     ldaxysp
	ldy     #$07
	jsr     ldaxidx
	jsr     tossubax
	jsr     tossubax
	ldy     #$0A
	jsr     staxysp
;
; if((entry1->index - entry2->index) != 0 && caseSensitive == 2) {
;
	ldy     #$11
	jsr     ldaxysp
	ldy     #$05
	jsr     pushwidx
	ldy     #$11
	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	jsr     tossubax
	cpx     #$00
	bne     L15E5
	cmp     #$00
	beq     L0849
L15E5:	ldy     #$23
	lda     (sp),y
	bne     L0849
	dey
	lda     (sp),y
	cmp     #$02
	bne     L0849
;
; accentcheck = 1;
;
	ldx     #$00
	lda     #$01
	ldy     #$02
L15DD:	jsr     staxysp
;
; if(comparison != 0) {
;
L0849:	ldy     #$0A
	lda     (sp),y
	iny
	ora     (sp),y
	jeq     L0862
;
; return comparison > 0 ? 1 : -1;
;
	jsr     ldaxysp
	cmp     #$01
	txa
	sbc     #$00
	bvs     L0856
	eor     #$80
L0856:	bpl     L0857
	ldx     #$00
	lda     #$01
	jmp     L0746
L0857:	ldx     #$FF
	txa
	jmp     L0746
;
; return entry1->script > entry2->script ? 1 : -1;
;
L0830:	ldy     #$11
	jsr     ldaxysp
	ldy     #$03
	jsr     pushwidx
	ldy     #$11
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	jsr     tosicmp
	bmi     L085D
	beq     L085D
	ldx     #$00
	lda     #$01
	jmp     L0746
L085D:	ldx     #$FF
	txa
	jmp     L0746
;
; else if(entry1->script != char2) {
;
L0827:	ldy     #$11
	jsr     ldaxysp
	ldy     #$03
	jsr     pushwidx
	ldy     #$17
	jsr     ldeaxysp
	jsr     toslong
	jsr     tosneeax
	beq     L0862
;
; return (entry1->script > char2) ? 1: -1; 
;
	ldy     #$11
	jsr     ldaxysp
	ldy     #$03
	jsr     pushwidx
	ldy     #$17
	jsr     ldeaxysp
	jsr     toslong
	jsr     tosgteax
	beq     L0866
	ldx     #$00
	lda     #$01
	jmp     L0746
L0866:	ldx     #$FF
	txa
	jmp     L0746
;
; str1, str2,
;
L0862:	ldy     #$29
	jsr     pushwysp
	ldy     #$29
	jsr     pushwysp
;
; &offset1, &offset2,
;
	lda     #$20
	jsr     leaa0sp
	jsr     pushax
	lda     #$20
	jsr     leaa0sp
	jsr     pushax
;
; get1, get2,
;
	ldy     #$2B
	jsr     pushwysp
	ldy     #$2B
	jsr     pushwysp
;
; &bytesMatched1, &bytesMatched2,
;
	lda     #$12
	jsr     leaa0sp
	jsr     pushax
	lda     #$12
	jsr     leaa0sp
	jsr     pushax
;
; &accentcheck)) != 0) {
;
	lda     #$12
	jsr     leaa0sp
	jsr     _consumeCombiningChars
	jsr     stax0sp
	cpx     #$00
	bne     L15E7
	cmp     #$00
	beq     L086A
;
; return combinerResult;
;
L15E7:	jsr     ldax0sp
	jmp     L0746
;
; if(firstChar) {
;
L086A:	ldy     #$0D
	lda     (sp),y
	dey
	ora     (sp),y
	beq     L15E9
;
; firstChar = FALSE;
;
	txa
	jsr     staxysp
;
; char1found = 0;
;
L15E9:	ldy     #$08
	jsr     staxysp
;
; else {
;
	jmp     L0748
;
; offset2 += bytesMatched2;
;
L0825:	ldy     #$05
	jsr     ldaxysp
	ldy     #$1A
	jsr     addeqysp
;
; else {  
;
	jmp     L0748
;
; char2 = (*((int (*)(unsigned char **, unsigned char **, int,  int *, void (*)()))get2))(&offset2, str2, 0, &bytesMatched2, get2);
;
L0819:	ldy     #$21
	jsr     pushwysp
	lda     #$1C
	jsr     leaa0sp
	jsr     pushax
	ldy     #$2B
	jsr     pushwysp
	jsr     push0
	lda     #$0C
	jsr     leaa0sp
	jsr     pushax
	ldy     #$29
	jsr     ldaxysp
	pha
	ldy     #$08
	lda     (sp),y
	sta     jmpvec+1
	iny
	lda     (sp),y
	sta     jmpvec+2
	pla
	jsr     jmpvec
	jsr     incsp2
	jsr     axlong
	ldy     #$12
	jsr     steaxysp
;
; if(char2 != 0x34F) {
;
	ldy     #$15
	jsr     ldeaxysp
	jsr     pusheax
	ldx     #$03
	lda     #$00
	sta     sreg
	sta     sreg+1
	lda     #$4F
	jsr     tosneeax
	jeq     L088C
;
; if((entry2 = getLookupTableEntry(&offset2, str2, &bytesMatched2, get2, firstChar)) && char1 != entry2->script) {
;
	lda     #$1A
	jsr     leaa0sp
	jsr     pushax
	ldy     #$29
	jsr     pushwysp
	lda     #$08
	jsr     leaa0sp
	jsr     pushax
	ldy     #$27
	jsr     pushwysp
	ldy     #$15
	jsr     ldaxysp
	jsr     _getLookupTableEntry
	ldy     #$0E
	jsr     staxysp
	stx     tmp1
	ora     tmp1
	beq     L088E
	ldy     #$19
	jsr     ldeaxysp
	jsr     pusheax
	ldy     #$13
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	jsr     axlong
	jsr     tosneeax
	beq     L088E
;
; return (char1 > entry2->script) ? 1: -1; 
;
	ldy     #$19
	jsr     ldeaxysp
	jsr     pusheax
	ldy     #$13
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	jsr     axlong
	jsr     tosgteax
	beq     L089B
	ldx     #$00
	lda     #$01
	jmp     L0746
L089B:	ldx     #$FF
	txa
	jmp     L0746
;
; else if(char1 != char2) {
;
L088E:	ldy     #$19
	jsr     ldeaxysp
	jsr     pusheax
	ldy     #$19
	jsr     ldeaxysp
	jsr     tosneeax
	beq     L08A0
;
; return (char1 > char2) ? 1: -1; 
;
	ldy     #$19
	jsr     ldeaxysp
	jsr     pusheax
	ldy     #$19
	jsr     ldeaxysp
	jsr     tosgteax
	beq     L08A4
	ldx     #$00
	lda     #$01
	jmp     L0746
L08A4:	ldx     #$FF
	txa
	jmp     L0746
;
; str1, str2,
;
L08A0:	ldy     #$29
	jsr     pushwysp
	ldy     #$29
	jsr     pushwysp
;
; &offset1, &offset2,
;
	lda     #$20
	jsr     leaa0sp
	jsr     pushax
	lda     #$20
	jsr     leaa0sp
	jsr     pushax
;
; get1, get2,
;
	ldy     #$2B
	jsr     pushwysp
	ldy     #$2B
	jsr     pushwysp
;
; &bytesMatched1, &bytesMatched2,
;
	lda     #$12
	jsr     leaa0sp
	jsr     pushax
	lda     #$12
	jsr     leaa0sp
	jsr     pushax
;
; &accentcheck)) != 0) {
;
	lda     #$12
	jsr     leaa0sp
	jsr     _consumeCombiningChars
	jsr     stax0sp
	cpx     #$00
	bne     L15E8
	cmp     #$00
	beq     L15EA
;
; return combinerResult;
;
L15E8:	jsr     ldax0sp
	jmp     L0746
;
; char1found = 0;
;
L15EA:	ldy     #$08
	jsr     staxysp
;
; if(firstChar) {
;
	ldy     #$0D
	lda     (sp),y
	dey
	ora     (sp),y
	jeq     L0748
;
; firstChar = FALSE;
;
	txa
	jsr     staxysp
;
; else {
;
	jmp     L0748
;
; offset2 += bytesMatched2;
;
L088C:	ldy     #$05
	jsr     ldaxysp
	ldy     #$1A
	jsr     addeqysp
;
; } 
;
	jmp     L0748
;
; }
;
L0746:	ldy     #$28
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; __near__ unsigned char * __near__ strReplace (__near__ unsigned char *, __near__ unsigned char *, __near__ unsigned char *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_strReplace: near

.segment	"CODE"

;
; char *strReplace(char *search, char *replace, char *subject) {
;
	jsr     pushax
;
; char *replaced = (char*)calloc(1, 1), *temp = NULL;
;
	lda     #$01
	jsr     pusha0
	jsr     _calloc
	jsr     pushax
	jsr     push0
;
; char *p = subject, *p3 = subject, *p2;
;
	ldy     #$07
	jsr     pushwysp
	ldy     #$09
	jsr     pushwysp
;
; int found = 0;
;
	jsr     decsp2
	jsr     push0
;
; search == NULL ||
;
	ldy     #$10
	lda     (sp),y
	iny
	ora     (sp),y
	jeq     L08C0
;
; replace == NULL ||
;
	ldy     #$0E
	lda     (sp),y
	iny
	ora     (sp),y
	jeq     L08C0
;
; subject == NULL ||
;
	ldy     #$0C
	lda     (sp),y
	iny
	ora     (sp),y
	jeq     L08C0
;
; strlen(search) == 0 ||
;
	ldy     #$11
	jsr     ldaxysp
	jsr     _strlen
	cpx     #$00
	bne     L15EC
	cmp     #$00
	jeq     L08C0
;
; strlen(replace) == 0 ||
;
L15EC:	ldy     #$0F
	jsr     ldaxysp
	jsr     _strlen
	cpx     #$00
	bne     L15ED
	cmp     #$00
	jeq     L08C0
;
; strlen(subject) == 0
;
L15ED:	ldy     #$0D
	jsr     ldaxysp
	jsr     _strlen
;
; ) {
;
	cpx     #$00
	jne     L08D7
	cmp     #$00
	jeq     L08C0
	jmp     L08D7
;
; found = 1;
;
L08D5:	ldx     #$00
L15F2:	lda     #$01
	jsr     stax0sp
;
; temp = realloc(replaced, strlen(replaced) + (p - p3) + strlen(replace));
;
	ldy     #$0D
	jsr     pushwysp
	ldy     #$0D
	jsr     ldaxysp
	jsr     _strlen
	jsr     pushax
	ldy     #$0B
	jsr     ldaxysp
	sec
	ldy     #$08
	sbc     (sp),y
	pha
	txa
	iny
	sbc     (sp),y
	tax
	pla
	jsr     tosaddax
	jsr     pushax
	ldy     #$13
	jsr     ldaxysp
	jsr     _strlen
	jsr     tosaddax
	jsr     _realloc
	ldy     #$08
	jsr     staxysp
;
; if(temp == NULL) {
;
	cpx     #$00
	bne     L08E7
	cmp     #$00
	bne     L08E7
;
; free(replaced);
;
	ldy     #$0B
	jsr     ldaxysp
	jsr     _free
;
; return NULL;
;
	ldx     #$00
	txa
	jmp     L08C0
;
; replaced = temp;
;
L08E7:	ldy     #$09
	jsr     ldaxysp
	ldy     #$0A
	jsr     staxysp
;
; strncat(replaced, p - (p - p3), p - p3);
;
	jsr     pushax
	ldy     #$0B
	jsr     pushwysp
	ldy     #$0B
	jsr     ldaxysp
	sec
	ldy     #$08
	sbc     (sp),y
	pha
	txa
	iny
	sbc     (sp),y
	tax
	pla
	jsr     tossubax
	jsr     pushax
	ldy     #$0B
	jsr     ldaxysp
	sec
	ldy     #$08
	sbc     (sp),y
	pha
	txa
	iny
	sbc     (sp),y
	tax
	pla
	jsr     _strncat
;
; strcat(replaced, replace);
;
	ldy     #$0D
	jsr     pushwysp
	ldy     #$11
	jsr     ldaxysp
	jsr     _strcat
;
; p3 = p + strlen(search);
;
	ldy     #$09
	jsr     pushwysp
	ldy     #$13
	jsr     ldaxysp
	jsr     _strlen
	jsr     tosaddax
	ldy     #$04
	jsr     staxysp
;
; p += strlen(search);
;
	ldy     #$11
	jsr     ldaxysp
	jsr     _strlen
	ldy     #$06
	jsr     addeqysp
;
; p2 = p;
;
	ldy     #$07
	jsr     ldaxysp
	ldy     #$02
	jsr     staxysp
;
; while((p = strstr(p, search)) != NULL) {
;
L08D7:	ldy     #$09
	jsr     pushwysp
	ldy     #$13
	jsr     ldaxysp
	jsr     _strstr
	ldy     #$06
	jsr     staxysp
	cpx     #$00
	jne     L08D5
	cmp     #$00
	jne     L15F2
;
; if (found == 1) {
;
	ldy     #$01
	lda     (sp),y
	bne     L08FF
	lda     (sp,x)
	cmp     #$01
	bne     L08FF
;
; if (strlen(p2) > 0) {
;
	ldy     #$03
	jsr     ldaxysp
	jsr     _strlen
	cpx     #$00
	bne     L15EF
	cmp     #$00
	jeq     L091D
;
; temp = realloc(replaced, strlen(replaced) + strlen(p2) + 1);
;
L15EF:	ldy     #$0D
	jsr     pushwysp
	ldy     #$0D
	jsr     ldaxysp
	jsr     _strlen
	jsr     pushax
	ldy     #$07
	jsr     ldaxysp
	jsr     _strlen
	jsr     tosaddax
	jsr     incax1
	jsr     _realloc
	ldy     #$08
	jsr     staxysp
;
; if (temp == NULL) {
;
	cpx     #$00
	bne     L090C
	cmp     #$00
	bne     L090C
;
; free(replaced);
;
	ldy     #$0B
	jsr     ldaxysp
	jsr     _free
;
; return NULL;
;
	ldx     #$00
	txa
	jmp     L08C0
;
; replaced = temp;
;
L090C:	ldy     #$09
	jsr     ldaxysp
	ldy     #$0A
	jsr     staxysp
;
; strcat(replaced, p2);
;
	jsr     pushax
	ldy     #$05
	jsr     ldaxysp
	jsr     _strcat
;
; else {
;
	jmp     L091D
;
; temp = realloc(replaced, strlen(subject) + 1);
;
L08FF:	ldy     #$0D
	jsr     pushwysp
	ldy     #$0F
	jsr     ldaxysp
	jsr     _strlen
	jsr     incax1
	jsr     _realloc
	ldy     #$08
	jsr     staxysp
;
; if (temp != NULL) {
;
	cpx     #$00
	bne     L15F0
	cmp     #$00
	beq     L091D
;
; replaced = temp;
;
L15F0:	ldy     #$09
	jsr     ldaxysp
	ldy     #$0A
	jsr     staxysp
;
; strcpy(replaced, subject);
;
	jsr     pushax
	ldy     #$0F
	jsr     ldaxysp
	jsr     _strcpy
;
; return replaced;
;
L091D:	ldy     #$0B
	jsr     ldaxysp
;
; }
;
L08C0:	ldy     #$12
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; __near__ struct expression * __near__ parse_functionRef (__near__ struct qryData *, long, __near__ struct expression *, int)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_parse_functionRef: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; struct expression *expressionPtr2 = NULL;
;
	jsr     push0
;
; struct resultColumn *columnPtr = NULL;
;
	jsr     push0
;
; if(queryData->parseMode != 1) {
;
	ldy     #$0D
	jsr     ldaxysp
	jsr     ldaxi
	cpx     #$00
	bne     L15F3
	cmp     #$01
	beq     L0929
;
; return NULL;
;
L15F3:	ldx     #$00
	txa
	jmp     L0926
;
; if(isDistinct) {
;
L0929:	ldy     #$05
	lda     (sp),y
	dey
	ora     (sp),y
	beq     L092D
;
; aggregationType+=GRP_STAR;
;
	stx     sreg
	stx     sreg+1
	lda     #$07
	ldy     #$08
	jsr     laddeqysp
;
; if(expressionPtr->containsAggregates) {
;
L092D:	ldy     #$07
	jsr     ldaxysp
	ldy     #$06
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	iny
	ora     (ptr1),y
	beq     L0931
;
; fputs("can't aggregate an aggregate", stderr);
;
	lda     #<(L0934)
	ldx     #>(L0934)
	jsr     pushax
	lda     _stderr
	ldx     _stderr+1
	jsr     _fputs
;
; exit(EXIT_FAILURE);
;
	ldx     #$00
	lda     #$01
	jsr     _exit
;
; queryData->hasGrouping = TRUE;  /* at least one, perhaps more */
;
L0931:	ldy     #$0D
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$01
	ldy     #$02
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; columnPtr = parse_expCommaList(queryData, expressionPtr, NULL, aggregationType);   /* parse_exp_commalist returns an output column pointer */
;
	ldy     #$0F
	jsr     pushwysp
	ldy     #$0B
	jsr     pushwysp
	jsr     push0
	ldy     #$0F
	jsr     ldaxysp
	jsr     _parse_expCommaList
	jsr     stax0sp
;
; reallocMsg((void**)(&expressionPtr2), sizeof(struct expression));
;
	lda     #$02
	jsr     leaa0sp
	jsr     pushax
	ldx     #$00
	lda     #$12
	jsr     _reallocMsg
;
; expressionPtr2->type = EXP_GROUP;
;
	ldy     #$03
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$16
	ldy     #$00
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; expressionPtr2->value = NULL;
;
	ldy     #$03
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$0C
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; expressionPtr2->unionPtrs.voidPtr = (void *)(columnPtr);  /* the expression nodes reference points directly to the hidden column */
;
	ldy     #$03
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	jsr     ldax0sp
	ldy     #$0E
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; expressionPtr2->minColumn = expressionPtr->minColumn;
;
	ldy     #$03
	jsr     ldaxysp
	sta     sreg
	stx     sreg+1
	ldy     #$07
	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	ldy     #$04
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; expressionPtr2->minTable = expressionPtr->minTable;
;
	ldy     #$03
	jsr     ldaxysp
	sta     sreg
	stx     sreg+1
	ldy     #$07
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	ldy     #$02
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; expressionPtr2->containsAggregates = TRUE;
;
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$01
	ldy     #$06
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; return expressionPtr2;
;
	ldy     #$03
	jsr     ldaxysp
;
; }
;
L0926:	ldy     #$0E
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; __near__ struct resultColumn * __near__ parse_newOutputColumn (__near__ struct qryData *, int, int, __near__ unsigned char *, int)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_parse_newOutputColumn: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; struct resultColumn *newResultColumn = NULL;
;
	jsr     push0
;
; reallocMsg((void**)(&newResultColumn), sizeof(struct resultColumn));
;
	lda     sp
	ldx     sp+1
	jsr     pushax
	ldx     #$00
	lda     #$18
	jsr     _reallocMsg
;
; if(queryData->firstResultColumn == NULL) {
;
	ldy     #$0B
	jsr     ldaxysp
	ldy     #$1D
	jsr     ldaxidx
	cpx     #$00
	bne     L0959
	cmp     #$00
	bne     L0959
;
; newResultColumn->resultColumnIndex = 0;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	tay
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; queryData->firstResultColumn = newResultColumn;
;
	ldy     #$0B
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	jsr     ldax0sp
	ldy     #$1C
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; newResultColumn->nextColumnInResults = newResultColumn;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	jsr     ldax0sp
	ldy     #$16
;
; else {
;
	jmp     L15F8
;
; newResultColumn->resultColumnIndex = queryData->firstResultColumn->resultColumnIndex+1;
;
L0959:	jsr     ldax0sp
	sta     sreg
	stx     sreg+1
	ldy     #$0B
	jsr     ldaxysp
	ldy     #$1D
	jsr     ldaxidx
	jsr     ldaxi
	jsr     incax1
	ldy     #$00
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; newResultColumn->nextColumnInResults = queryData->firstResultColumn->nextColumnInResults;   /* maintain circularly linked list for now */
;
	jsr     ldax0sp
	sta     sreg
	stx     sreg+1
	ldy     #$0B
	jsr     ldaxysp
	ldy     #$1D
	jsr     ldaxidx
	ldy     #$17
	jsr     ldaxidx
	ldy     #$16
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; queryData->firstResultColumn->nextColumnInResults = newResultColumn;
;
	ldy     #$0B
	jsr     ldaxysp
	ldy     #$1D
	jsr     ldaxidx
	sta     ptr1
	stx     ptr1+1
	jsr     ldax0sp
	ldy     #$16
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; queryData->firstResultColumn = newResultColumn;
;
	ldy     #$0B
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	jsr     ldax0sp
	ldy     #$1C
L15F8:	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; newResultColumn->isHidden = isHidden2;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$09
	jsr     ldaxysp
	ldy     #$02
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; newResultColumn->isCalculated = isCalculated2;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$07
	jsr     ldaxysp
	ldy     #$04
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; newResultColumn->resultColumnName = resultColumnName2;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$05
	jsr     ldaxysp
	ldy     #$12
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; newResultColumn->nextColumnInstance = NULL;   /* TODO: this field needs to be filled out properly */
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$14
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; newResultColumn->groupType = aggregationType;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$03
	jsr     ldaxysp
	ldy     #$06
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; newResultColumn->groupText = NULL;
;
	jsr     ldax0sp
	sta     sreg
	stx     sreg+1
	lda     #$00
	ldy     #$08
	sta     (sreg),y
	iny
	sta     (sreg),y
;
; newResultColumn->groupNum = 0.0;
;
	jsr     pushw0sp
	ldx     #$00
	stx     sreg
	stx     sreg+1
	txa
	ldy     #$0A
	jsr     steaxspidx
;
; newResultColumn->groupCount = 0;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$0E
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; newResultColumn->groupingDone = FALSE;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$10
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; return newResultColumn;
;
	jsr     ldax0sp
;
; }
;
	ldy     #$0C
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; int __near__ d_strftime (__near__ __near__ unsigned char * *, __near__ unsigned char *, __near__ struct tm *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_d_strftime: near

.segment	"CODE"

;
; int d_strftime(char **ptr, char *format, struct tm *timeptr) {
;
	jsr     pushax
;
; size_t length = 32; /* starting value */
;
	lda     #$20
	jsr     pusha0
;
; size_t length2 = 0;
;
	jsr     push0
;
; char *output = NULL;
;
	jsr     push0
;
; char *output2 = NULL;
;
	jsr     push0
;
; if(ptr == NULL || format == NULL) {
;
	ldy     #$0C
	lda     (sp),y
	iny
	ora     (sp),y
	jeq     L097E
	ldy     #$0A
	lda     (sp),y
	iny
	ora     (sp),y
	jeq     L097E
	jmp     L098B
;
; output2 = realloc((void*)output, length*sizeof(char));
;
L0989:	ldy     #$05
	jsr     pushwysp
	ldy     #$09
	jsr     ldaxysp
	jsr     _realloc
	jsr     stax0sp
;
; if(output2 == NULL) {
;
	cpx     #$00
	bne     L0992
	cmp     #$00
	bne     L0992
;
; freeAndZero(output);
;
	ldy     #$03
	jsr     ldaxysp
	jsr     _free
	ldx     #$00
	txa
	ldy     #$02
	jsr     staxysp
;
; return FALSE;
;
	jmp     L097E
;
; output = output2;
;
L0992:	jsr     ldax0sp
	ldy     #$02
	jsr     staxysp
;
; length2 = strftime(output, length, format, timeptr);
;
	jsr     pushax
	ldy     #$0B
	jsr     pushwysp
	ldy     #$11
	jsr     pushwysp
	ldy     #$0F
	jsr     ldaxysp
	jsr     _strftime
	ldy     #$04
	jsr     staxysp
;
; length *= 2;
;
	ldy     #$07
	jsr     ldaxysp
	jsr     shlax1
	ldy     #$06
	jsr     staxysp
;
; while (length2 == 0) {
;
L098B:	ldy     #$04
	lda     (sp),y
	iny
	ora     (sp),y
	beq     L0989
;
; output2 = realloc((void*)output, (length2+1)*sizeof(char));
;
	jsr     pushwysp
	ldy     #$07
	jsr     ldaxysp
	jsr     incax1
	jsr     _realloc
	jsr     stax0sp
;
; if(output2 == NULL) {
;
	cpx     #$00
	bne     L09A9
	cmp     #$00
	bne     L09A9
;
; freeAndZero(output);
;
	ldy     #$03
	jsr     ldaxysp
	jsr     _free
	ldx     #$00
	txa
	ldy     #$02
	jsr     staxysp
;
; return FALSE;
;
	jmp     L097E
;
; freeAndZero(*ptr);
;
L09A9:	ldy     #$0D
	jsr     ldaxysp
	jsr     ldaxi
	jsr     _free
	ldy     #$0D
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	tay
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; *ptr = output2;
;
	ldy     #$0D
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	jsr     ldax0sp
	ldy     #$00
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; return TRUE;
;
	ldx     #$00
	tya
;
; }
;
L097E:	ldy     #$0E
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; int __near__ getColumnValue (__near__ unsigned char *, long, int)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_getColumnValue: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; FILE *inputFile = NULL;
;
	jsr     push0
;
; char *output = (char*)malloc(1);
;
	lda     #$01
	jsr     _malloc
	jsr     pushax
;
; size_t strSize = 0;
;
	jsr     push0
;
; int currentColumn = 0;
;
	jsr     push0
;
; inputFile = skipBom(inputFileName, NULL);
;
	ldy     #$11
	jsr     pushwysp
	ldx     #$00
	txa
	jsr     _skipBom
	ldy     #$06
	jsr     staxysp
;
; if(inputFile == NULL) {
;
	cpx     #$00
	bne     L09C2
	cmp     #$00
	bne     L09C2
;
; fputs(TDB_COULDNT_OPEN_INPUT, stderr);
;
	lda     #<(L09C6)
	ldx     #>(L09C6)
	jsr     pushax
	lda     _stderr
	ldx     _stderr+1
	jsr     _fputs
;
; freeAndZero(output);
;
	ldy     #$05
	jsr     ldaxysp
	jsr     _free
	ldx     #$00
	txa
	ldy     #$04
	jsr     staxysp
;
; return -1;
;
	dex
	jmp     L15FE
;
; if(myfseek(inputFile, offset, SEEK_SET) != 0) {
;
L09C2:	ldy     #$09
	jsr     pushwysp
	ldy     #$0F
	jsr     ldeaxysp
	jsr     pusheax
	ldx     #$00
	lda     #$02
	jsr     _myfseek
	cpx     #$00
	bne     L15FC
	cmp     #$00
	beq     L09DF
;
; fputs(TDB_COULDNT_SEEK, stderr);
;
L15FC:	lda     #<(L09D5)
	ldx     #>(L09D5)
	jsr     pushax
	lda     _stderr
	ldx     _stderr+1
	jsr     _fputs
;
; freeAndZero(output);
;
	ldy     #$05
	jsr     ldaxysp
	jsr     _free
	ldx     #$00
	txa
	ldy     #$04
	jsr     staxysp
;
; return -1;
;
	dex
	jmp     L15FE
;
; ++currentColumn != columnIndex ?
;
L09DF:	ldx     #$00
	lda     #$01
	jsr     addeq0sp
	ldy     #$08
	cmp     (sp),y
	bne     L15FD
	txa
	iny
	cmp     (sp),y
;
; getCsvColumn(&inputFile, NULL, NULL, NULL, NULL, TRUE):
;
	beq     L09E1
L15FD:	lda     #$06
	jsr     leaa0sp
	jsr     pushax
	jsr     push0
	jsr     push0
	jsr     push0
	jsr     push0
	lda     #$01
	jsr     _getCsvColumn
;
; (getCsvColumn(&inputFile, &output, &strSize, NULL, NULL, TRUE) && FALSE)
;
	jmp     L09F3
L09E1:	lda     #$06
	jsr     leaa0sp
	jsr     pushax
	lda     #$06
	jsr     leaa0sp
	jsr     pushax
	lda     #$06
	jsr     leaa0sp
	jsr     pushax
	jsr     push0
	jsr     push0
	lda     #$01
	jsr     _getCsvColumn
	stx     tmp1
	ora     tmp1
	beq     L09F2
	lda     #$00
L09F2:	tax
;
; ) {
;
L09F3:	stx     tmp1
	ora     tmp1
	bne     L09DF
;
; fputs(output, stdout);
;
	ldy     #$07
	jsr     pushwysp
	lda     _stdout
	ldx     _stdout+1
	jsr     _fputs
;
; freeAndZero(output);
;
	ldy     #$05
	jsr     ldaxysp
	jsr     _free
	ldx     #$00
	txa
	ldy     #$04
	jsr     staxysp
;
; fclose(inputFile);
;
	ldy     #$07
	jsr     ldaxysp
	jsr     _fclose
;
; return 0;
;
	ldx     #$00
L15FE:	txa
;
; }
;
	ldy     #$10
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; void __near__ cleanup_expression (__near__ struct expression *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_cleanup_expression: near

.segment	"CODE"

;
; void cleanup_expression(struct expression *currentExpression) {
;
	jsr     pushax
;
; if(currentExpression != NULL) {
;
	ldy     #$00
	lda     (sp),y
	iny
	ora     (sp),y
	beq     L09FF
;
; switch(currentExpression->type) {
;
	jsr     ldax0sp
	jsr     ldaxi
;
; }
;
	cpx     #$00
	bne     L0A1D
	cmp     #$01
	beq     L0A04
	cmp     #$02
	beq     L0A12
	cmp     #$03
	beq     L0A04
	cmp     #$09
	beq     L0A18
	cmp     #$0A
	beq     L0A18
	cmp     #$14
	beq     L0A06
	cmp     #$15
	beq     L0A06
	cmp     #$16
	beq     L0A04
	jmp     L0A1D
;
; cleanup_expression(currentExpression->unionPtrs.inLeaves.leftPtr);
;
L0A06:	jsr     ldax0sp
	ldy     #$0F
	jsr     ldaxidx
	jsr     _cleanup_expression
;
; cleanup_atomList(currentExpression->unionPtrs.inLeaves.lastEntryPtr);
;
	jsr     ldax0sp
	ldy     #$11
	jsr     ldaxidx
	jsr     _cleanup_atomList
;
; break;
;
	jmp     L0A04
;
; free(currentExpression->unionPtrs.voidPtr);
;
L0A12:	jsr     ldax0sp
	ldy     #$0F
	jsr     ldaxidx
	jsr     _free
;
; break;
;
	jmp     L0A04
;
; cleanup_expression(currentExpression->unionPtrs.leaves.leftPtr);
;
L0A18:	jsr     ldax0sp
	ldy     #$0F
;
; break;
;
	jmp     L1600
;
; cleanup_expression(currentExpression->unionPtrs.leaves.leftPtr);
;
L0A1D:	jsr     ldax0sp
	ldy     #$0F
	jsr     ldaxidx
	jsr     _cleanup_expression
;
; cleanup_expression(currentExpression->unionPtrs.leaves.rightPtr);
;
	jsr     ldax0sp
	ldy     #$11
L1600:	jsr     ldaxidx
	jsr     _cleanup_expression
;
; free(currentExpression);
;
L0A04:	jsr     ldax0sp
	jsr     _free
;
; }
;
L09FF:	jsr     incsp2
	jmp     farret

.endproc

; ---------------------------------------------------------------
; __near__ struct atomEntry * __near__ parse_atomCommaList (__near__ struct qryData *, __near__ struct atomEntry *, __near__ unsigned char *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_parse_atomCommaList: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; if(queryData->parseMode != 1) {
;
	jsr     decsp2
	ldy     #$07
	jsr     ldaxysp
	jsr     ldaxi
	cpx     #$00
	bne     L1602
	cmp     #$01
	beq     L0A25
;
; return NULL;
;
L1602:	ldx     #$00
	txa
	jmp     L0A24
;
; reallocMsg((void**)(&newEntryPtr), sizeof(struct atomEntry));
;
L0A25:	lda     sp
	ldx     sp+1
	jsr     pushax
	ldx     #$00
	lda     #$06
	jsr     _reallocMsg
;
; if(lastEntryPtr == NULL) {
;
	ldy     #$04
	lda     (sp),y
	iny
	ora     (sp),y
	bne     L0A2D
;
; newEntryPtr->index = 1;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	lda     #$01
	ldy     #$00
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; else {
;
	jmp     L160C
;
; newEntryPtr->index = lastEntryPtr->index+1;
;
L0A2D:	jsr     ldax0sp
	sta     sreg
	stx     sreg+1
	ldy     #$05
	jsr     ldaxysp
	jsr     ldaxi
	jsr     incax1
	ldy     #$00
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; newEntryPtr->nextInList = lastEntryPtr->nextInList;
;
	jsr     ldax0sp
	sta     sreg
	stx     sreg+1
	ldy     #$05
	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	ldy     #$04
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; lastEntryPtr->nextInList = newEntryPtr;
;
L160C:	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	jsr     ldax0sp
	ldy     #$04
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; newEntryPtr->content = newEntry;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$03
	jsr     ldaxysp
	ldy     #$02
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; return newEntryPtr;
;
	jsr     ldax0sp
;
; }
;
L0A24:	jsr     incsp8
	jmp     farret

.endproc

; ---------------------------------------------------------------
; void __near__ cleanup_query (__near__ struct qryData *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_cleanup_query: near

.segment	"CODE"

;
; void cleanup_query(struct qryData *query) {
;
	jsr     pushax
;
; cleanup_columnReferences(query->columnReferenceHashTable);
;
	jsr     ldax0sp
	ldy     #$17
	jsr     ldaxidx
	jsr     _cleanup_columnReferences
;
; cleanup_resultColumns(query->firstResultColumn);
;
	jsr     ldax0sp
	ldy     #$1D
	jsr     ldaxidx
	jsr     _cleanup_resultColumns
;
; cleanup_orderByClause(query->groupByClause);
;
	jsr     ldax0sp
	ldy     #$23
	jsr     ldaxidx
	jsr     _cleanup_orderByClause
;
; cleanup_orderByClause(query->orderByClause);
;
	jsr     ldax0sp
	ldy     #$21
	jsr     ldaxidx
	jsr     _cleanup_orderByClause
;
; cleanup_expression(query->joinsAndWhereClause);
;
	jsr     ldax0sp
	ldy     #$1F
	jsr     ldaxidx
	jsr     _cleanup_expression
;
; cleanup_inputTables(query->firstInputTable);
;
	jsr     ldax0sp
	ldy     #$19
	jsr     ldaxidx
	jsr     _cleanup_inputTables
;
; free(query->intoFileName);
;
	jsr     ldax0sp
	ldy     #$11
	jsr     ldaxidx
	jsr     _free
;
; }
;
	jsr     incsp2
	jmp     farret

.endproc

; ---------------------------------------------------------------
; int __near__ strRTrim (__near__ __near__ unsigned char * *, __near__ unsigned int *, __near__ unsigned char *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_strRTrim: near

.segment	"CODE"

;
; int strRTrim(char **value, size_t *strSize, char *minSize) {
;
	jsr     pushax
;
; if(value == NULL || strSize == NULL || *value == NULL) {
;
	jsr     decsp6
	ldy     #$0A
	lda     (sp),y
	iny
	ora     (sp),y
	beq     L0A4F
	ldy     #$08
	lda     (sp),y
	iny
	ora     (sp),y
	beq     L0A4F
	ldy     #$0B
	jsr     ldaxysp
	jsr     ldaxi
	cpx     #$00
	bne     L0A4E
	cmp     #$00
	jeq     L0A4D
	jmp     L0A4E
;
; return FALSE;
;
L0A4F:	tax
	jmp     L0A4D
;
; str = *value;
;
L0A4E:	ldy     #$0B
	jsr     ldaxysp
	jsr     ldaxi
	ldy     #$02
	jsr     staxysp
;
; size = *strSize;
;
	ldy     #$09
	jsr     ldaxysp
	jsr     ldaxi
	jsr     stax0sp
;
; end = str + size - 1;
;
	clc
	ldy     #$02
	adc     (sp),y
	pha
	txa
	iny
	adc     (sp),y
	tax
	pla
	jsr     decax1
	iny
;
; while(end > str && end != minSize && (*end == ' ' || *end == '\t')) {
;
	jmp     L1616
;
; end--;
;
L0A5B:	ldy     #$05
	jsr     ldaxysp
	jsr     decax1
	ldy     #$04
	jsr     staxysp
;
; size--;
;
	jsr     ldax0sp
	jsr     decax1
	ldy     #$00
L1616:	jsr     staxysp
;
; while(end > str && end != minSize && (*end == ' ' || *end == '\t')) {
;
	ldy     #$05
	jsr     ldaxysp
	sec
	ldy     #$02
	sbc     (sp),y
	sta     tmp1
	txa
	iny
	sbc     (sp),y
	ora     tmp1
	bcc     L160E
	beq     L160E
	ldy     #$05
	jsr     ldaxysp
	ldy     #$06
	cmp     (sp),y
	bne     L1615
	txa
	iny
	cmp     (sp),y
	beq     L160E
L1615:	ldy     #$05
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$20
	beq     L0A5B
	ldy     #$05
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$09
	beq     L0A5B
;
; *strSize = size;
;
L160E:	ldy     #$09
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	jsr     ldax0sp
	ldy     #$00
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; return TRUE;
;
	ldx     #$00
	tya
;
; }
;
L0A4D:	ldy     #$0C
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; int __near__ walkRejectRecord (int, __near__ struct expression *, __near__ struct resultColumnParam *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_walkRejectRecord: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; if(expressionPtr == NULL || currentTable < expressionPtr->minTable) {
;
	jsr     decsp6
	ldy     #$08
	lda     (sp),y
	iny
	ora     (sp),y
	jeq     L0AD7
	ldy     #$0D
	jsr     pushwysp
	ldy     #$0B
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	jsr     tosicmp
	jmi     L0AD7
;
; if(expressionPtr->type >= EXP_EQ && expressionPtr->type <= EXP_GTE){
;
	ldy     #$09
	jsr     ldaxysp
	jsr     ldaxi
	cmp     #$0E
	txa
	sbc     #$00
	bvs     L0A70
	eor     #$80
L0A70:	jpl     L0A6E
	ldy     #$09
	jsr     ldaxysp
	jsr     ldaxi
	cmp     #$14
	txa
	sbc     #$00
	bvc     L0A72
	eor     #$80
L0A72:	jpl     L0A6E
;
; getValue(expressionPtr->unionPtrs.leaves.leftPtr, match);
;
	ldy     #$09
	jsr     ldaxysp
	ldy     #$0F
	jsr     pushwidx
	ldy     #$09
	jsr     ldaxysp
	jsr     _getValue
;
; getValue(expressionPtr->unionPtrs.leaves.rightPtr, match);
;
	ldy     #$09
	jsr     ldaxysp
	ldy     #$11
	jsr     pushwidx
	ldy     #$09
	jsr     ldaxysp
	jsr     _getValue
;
; expressionPtr->unionPtrs.leaves.leftPtr->leftNull ||
;
	ldy     #$09
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	ldy     #$08
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	iny
	ora     (ptr1),y
	bne     L0A7B
;
; expressionPtr->unionPtrs.leaves.rightPtr->leftNull
;
	jsr     ldaxysp
;
; ) {
;
	ldy     #$11
	jsr     ldaxidx
	ldy     #$08
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	iny
	ora     (ptr1),y
	beq     L161E
;
; freeAndZero(expressionPtr->unionPtrs.leaves.leftPtr->value);
;
L0A7B:	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	ldy     #$0D
	jsr     ldaxidx
	jsr     _free
	ldy     #$09
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$0C
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; freeAndZero(expressionPtr->unionPtrs.leaves.rightPtr->value);
;
	ldy     #$09
	jsr     ldaxysp
	ldy     #$11
	jsr     ldaxidx
	ldy     #$0D
	jsr     ldaxidx
	jsr     _free
	ldy     #$09
	jsr     ldaxysp
	ldy     #$11
	jsr     ldaxidx
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$0C
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; return FALSE;
;
	tax
	jmp     L0A68
;
; (unsigned char **)(&(expressionPtr->unionPtrs.leaves.leftPtr->value)),
;
L161E:	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	ldy     #$0C
	jsr     incaxy
	jsr     pushax
;
; (unsigned char **)(&(expressionPtr->unionPtrs.leaves.rightPtr->value)),
;
	ldy     #$0B
	jsr     ldaxysp
	ldy     #$11
	jsr     ldaxidx
	ldy     #$0C
	jsr     incaxy
	jsr     pushax
;
; expressionPtr->unionPtrs.leaves.leftPtr->caseSensitive,
;
	ldy     #$0D
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	ldy     #$0B
	jsr     pushwidx
;
; (void (*)())&getUnicodeChar,
;
	lda     #<(_getUnicodeChar)
	ldx     #>(_getUnicodeChar)
	jsr     pushax
;
; );
;
	lda     #<(_getUnicodeChar)
	ldx     #>(_getUnicodeChar)
	jsr     _strCompare
	ldy     #$04
	jsr     staxysp
;
; freeAndZero(expressionPtr->unionPtrs.leaves.leftPtr->value);
;
	ldy     #$09
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	ldy     #$0D
	jsr     ldaxidx
	jsr     _free
	ldy     #$09
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$0C
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; freeAndZero(expressionPtr->unionPtrs.leaves.rightPtr->value);
;
	ldy     #$09
	jsr     ldaxysp
	ldy     #$11
	jsr     ldaxidx
	ldy     #$0D
	jsr     ldaxidx
	jsr     _free
	ldy     #$09
	jsr     ldaxysp
	ldy     #$11
	jsr     ldaxidx
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$0C
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; switch(expressionPtr->type) {
;
	ldy     #$09
	jsr     ldaxysp
	jsr     ldaxi
;
; }
;
	cpx     #$00
	jne     L0AD7
	cmp     #$0E
	beq     L0A9D
	cmp     #$0F
	beq     L0AA1
	cmp     #$10
	beq     L0AA5
	cmp     #$11
	beq     L0AAD
	cmp     #$12
	beq     L0AA9
	cmp     #$13
	beq     L0AB1
	jmp     L1619
;
; return retval != 0;
;
L0A9D:	ldy     #$05
	jsr     ldaxysp
	cpx     #$00
	bne     L0A9F
	cmp     #$00
L0A9F:	jsr     boolne
	jmp     L0A68
;
; return retval == 0;
;
L0AA1:	ldy     #$05
	jsr     ldaxysp
	cpx     #$00
	bne     L0AA3
	cmp     #$00
L0AA3:	jsr     booleq
	jmp     L0A68
;
; return retval != -1;
;
L0AA5:	ldy     #$05
	jsr     ldaxysp
	cpx     #$FF
	bne     L0AA7
	cmp     #$FF
L0AA7:	jsr     boolne
	jmp     L0A68
;
; return retval == 1;
;
L0AA9:	ldy     #$05
	jsr     ldaxysp
	cpx     #$00
	bne     L0AAB
	cmp     #$01
L0AAB:	jsr     booleq
	jmp     L0A68
;
; return retval != 1;
;
L0AAD:	ldy     #$05
	jsr     ldaxysp
	cpx     #$00
	bne     L0AAF
	cmp     #$01
L0AAF:	jsr     boolne
	jmp     L0A68
;
; return retval == -1;
;
L0AB1:	ldy     #$05
	jsr     ldaxysp
	cpx     #$FF
	bne     L0AB3
	cmp     #$FF
L0AB3:	jsr     booleq
	jmp     L0A68
;
; else if(expressionPtr->type == EXP_AND) {
;
L0A6E:	ldy     #$09
	jsr     ldaxysp
	jsr     ldaxi
	cpx     #$00
	bne     L0AB5
	cmp     #$0B
	bne     L0AB5
;
; walkRejectRecord(currentTable, expressionPtr->unionPtrs.leaves.leftPtr, match) ||
;
	ldy     #$0D
	jsr     pushwysp
	ldy     #$0B
	jsr     ldaxysp
	ldy     #$0F
	jsr     pushwidx
	ldy     #$0B
	jsr     ldaxysp
	jsr     _walkRejectRecord
	stx     tmp1
	ora     tmp1
	bne     L0AB8
;
; walkRejectRecord(currentTable, expressionPtr->unionPtrs.leaves.rightPtr, match);
;
	ldy     #$0D
	jsr     pushwysp
	ldy     #$0B
	jsr     ldaxysp
	ldy     #$11
	jsr     pushwidx
	ldy     #$0B
	jsr     ldaxysp
	jsr     _walkRejectRecord
	stx     tmp1
	ora     tmp1
	bne     L0AB8
	tax
	jmp     L0A68
L0AB8:	ldx     #$00
	lda     #$01
	jmp     L0A68
;
; else if(expressionPtr->type == EXP_OR) {
;
L0AB5:	ldy     #$09
	jsr     ldaxysp
	jsr     ldaxi
	cpx     #$00
	bne     L0AC1
	cmp     #$0C
	bne     L0AC1
;
; walkRejectRecord(currentTable, expressionPtr->unionPtrs.leaves.leftPtr, match) &&
;
	ldy     #$0D
	jsr     pushwysp
	ldy     #$0B
	jsr     ldaxysp
	ldy     #$0F
	jsr     pushwidx
	ldy     #$0B
	jsr     ldaxysp
	jsr     _walkRejectRecord
	stx     tmp1
	ora     tmp1
	beq     L0AC8
;
; walkRejectRecord(currentTable, expressionPtr->unionPtrs.leaves.rightPtr, match);
;
	ldy     #$0D
	jsr     pushwysp
	ldy     #$0B
	jsr     ldaxysp
	ldy     #$11
	jsr     pushwidx
	ldy     #$0B
	jsr     ldaxysp
	jsr     _walkRejectRecord
	stx     tmp1
	ora     tmp1
	bne     L0AC4
L0AC8:	tax
	jmp     L0A68
L0AC4:	ldx     #$00
	lda     #$01
	jmp     L0A68
;
; else if(expressionPtr->type <= EXP_NOT) {
;
L0AC1:	ldy     #$09
	jsr     ldaxysp
	jsr     ldaxi
	cmp     #$0E
	txa
	sbc     #$00
	bvc     L0AD0
	eor     #$80
L0AD0:	bpl     L0ACE
;
; return walkRejectRecord(currentTable, expressionPtr->unionPtrs.leaves.leftPtr, match) == 0;
;
	ldy     #$0D
	jsr     pushwysp
	ldy     #$0B
	jsr     ldaxysp
	ldy     #$0F
	jsr     pushwidx
	ldy     #$0B
	jsr     ldaxysp
	jsr     _walkRejectRecord
	cpx     #$00
	bne     L0AD5
	cmp     #$00
L0AD5:	jsr     booleq
	jmp     L0A68
;
; else if(expressionPtr->type == EXP_IN || expressionPtr->type == EXP_NOTIN) {
;
L0ACE:	ldy     #$09
	jsr     ldaxysp
	jsr     ldaxi
	cpx     #$00
	bne     L1620
	cmp     #$14
	beq     L0AD8
L1620:	ldy     #$09
	jsr     ldaxysp
	jsr     ldaxi
	cpx     #$00
	jne     L0AD7
	cmp     #$15
	jne     L1619
;
; getValue(expressionPtr->unionPtrs.leaves.leftPtr, match);
;
L0AD8:	ldy     #$09
	jsr     ldaxysp
	ldy     #$0F
	jsr     pushwidx
	ldy     #$09
	jsr     ldaxysp
	jsr     _getValue
;
; if(expressionPtr->unionPtrs.leaves.leftPtr->leftNull) {
;
	ldy     #$09
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	ldy     #$08
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	iny
	ora     (ptr1),y
	beq     L161F
;
; freeAndZero(expressionPtr->unionPtrs.leaves.leftPtr->value);
;
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	ldy     #$0D
	jsr     ldaxidx
	jsr     _free
	ldy     #$09
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$0C
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; return FALSE;
;
	tax
	jmp     L0A68
;
; i = expressionPtr->unionPtrs.inLeaves.lastEntryPtr->index,
;
L161F:	jsr     ldaxysp
	ldy     #$11
	jsr     ldaxidx
	jsr     ldaxi
	ldy     #$02
	jsr     staxysp
;
; currentAtom = expressionPtr->unionPtrs.inLeaves.lastEntryPtr->nextInList;
;
	ldy     #$09
	jsr     ldaxysp
	ldy     #$11
	jsr     ldaxidx
L1625:	ldy     #$05
	jsr     ldaxidx
	jsr     stax0sp
;
; i != currentAtom->index;
;
	ldy     #$03
	jsr     ldaxysp
	sta     sreg
	stx     sreg+1
	jsr     ldax0sp
	jsr     ldaxi
	cpx     sreg+1
	bne     L1622
	cmp     sreg
	jeq     L0AE7
;
; (unsigned char **)(&(expressionPtr->unionPtrs.leaves.leftPtr->value)),
;
L1622:	ldy     #$09
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	ldy     #$0C
	jsr     incaxy
	jsr     pushax
;
; (unsigned char **)(&(currentAtom->content)),
;
	ldy     #$03
	jsr     ldaxysp
	jsr     incax2
	jsr     pushax
;
; expressionPtr->unionPtrs.leaves.leftPtr->caseSensitive,
;
	ldy     #$0D
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	ldy     #$0B
	jsr     pushwidx
;
; (void (*)())&getUnicodeChar,
;
	lda     #<(_getUnicodeChar)
	ldx     #>(_getUnicodeChar)
	jsr     pushax
;
; ) == 0) {
;
	lda     #<(_getUnicodeChar)
	ldx     #>(_getUnicodeChar)
	jsr     _strCompare
	cpx     #$00
	bne     L0AE8
	cmp     #$00
	bne     L0AE8
;
; freeAndZero(expressionPtr->unionPtrs.leaves.leftPtr->value);
;
	ldy     #$09
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	ldy     #$0D
	jsr     ldaxidx
	jsr     _free
	ldy     #$09
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$0C
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; return expressionPtr->type == EXP_NOTIN;  /* FALSE */
;
	ldy     #$09
	jsr     ldaxysp
	jsr     ldaxi
	cpx     #$00
	bne     L0B02
	cmp     #$15
L0B02:	jsr     booleq
	jmp     L0A68
;
; ) {
;
L0AE8:	jsr     ldax0sp
	jmp     L1625
;
; freeAndZero(expressionPtr->unionPtrs.leaves.leftPtr->value);
;
L0AE7:	ldy     #$09
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	ldy     #$0D
	jsr     ldaxidx
	jsr     _free
	ldy     #$09
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$0C
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; return expressionPtr->type != EXP_NOTIN;  /* TRUE */
;
	ldy     #$09
	jsr     ldaxysp
	jsr     ldaxi
	cpx     #$00
	bne     L0B08
	cmp     #$15
L0B08:	jsr     boolne
	jmp     L0A68
;
; return FALSE;
;
L0AD7:	ldx     #$00
L1619:	txa
;
; }
;
L0A68:	ldy     #$0C
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; int __near__ getColumnCount (__near__ unsigned char *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_getColumnCount: near

.segment	"CODE"

;
; int getColumnCount(char *inputFileName) {
;
	jsr     pushax
;
; FILE *inputFile = NULL;
;
	jsr     push0
;
; int columnCount = 1;
;
	lda     #$01
	jsr     pusha0
;
; inputFile = skipBom(inputFileName, NULL);
;
	ldy     #$07
	jsr     pushwysp
	ldx     #$00
	txa
	jsr     _skipBom
	ldy     #$02
	jsr     staxysp
;
; if(inputFile == NULL) {
;
	cpx     #$00
	bne     L0B1B
	cmp     #$00
	bne     L0B1B
;
; fputs(TDB_COULDNT_OPEN_INPUT, stderr);
;
	lda     #<(L0B15)
	ldx     #>(L0B15)
	jsr     pushax
	lda     _stderr
	ldx     _stderr+1
	jsr     _fputs
;
; return -1;
;
	ldx     #$FF
	jmp     L1626
;
; columnCount++;
;
L0B19:	jsr     ldax0sp
	jsr     incax1
	jsr     stax0sp
;
; while(getCsvColumn(&inputFile, NULL, NULL, NULL, NULL, TRUE)) {
;
L0B1B:	lda     #$02
	jsr     leaa0sp
	jsr     pushax
	jsr     push0
	jsr     push0
	jsr     push0
	jsr     push0
	lda     #$01
	jsr     _getCsvColumn
	stx     tmp1
	ora     tmp1
	bne     L0B19
;
; fprintf(stdout, "%d", columnCount);
;
	lda     _stdout
	ldx     _stdout+1
	jsr     pushax
	lda     #<(L0B26)
	ldx     #>(L0B26)
	jsr     pushax
	ldy     #$07
	jsr     pushwysp
	ldy     #$06
	jsr     _fprintf
;
; fclose(inputFile);
;
	ldy     #$03
	jsr     ldaxysp
	jsr     _fclose
;
; return 0;
;
	ldx     #$00
L1626:	txa
;
; }
;
	jsr     incsp6
	jmp     farret

.endproc

; ---------------------------------------------------------------
; __near__ struct resultColumn * __near__ parse_expCommaList (__near__ struct qryData *, __near__ struct expression *, __near__ unsigned char *, int)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_parse_expCommaList: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; struct columnReference *currentReference = NULL;
;
	jsr     push0
;
; struct columnReference *newReference = NULL;
;
	jsr     push0
;
; struct columnReference *newReference2 = NULL;
;
	jsr     push0
;
; struct resultColumn *newResultColumn = NULL;
;
	jsr     push0
;
; if(queryData->parseMode != 1) {
;
	ldy     #$0F
	jsr     ldaxysp
	jsr     ldaxi
	cpx     #$00
	bne     L162C
	cmp     #$01
	beq     L0B31
;
; return NULL;
;
L162C:	ldx     #$00
	txa
	jmp     L0BDB
;
; if(aggregationType == GRP_NONE) {
;
L0B31:	ldy     #$08
	lda     (sp),y
	iny
	ora     (sp),y
	jne     L0B35
;
; queryData->columnCount++;
;
	ldy     #$0F
	jsr     ldaxysp
	jsr     pushax
	ldy     #$05
	jsr     ldaxidx
	jsr     incax1
	ldy     #$04
	jsr     staxspidx
;
; if(resultColumnName == NULL) {
;
	ldy     #$0A
	lda     (sp),y
	iny
	ora     (sp),y
	jne     L0B5F
;
; if(expressionPtr->type == EXP_COLUMN) {
;
	ldy     #$0D
	jsr     ldaxysp
	jsr     ldaxi
	cpx     #$00
	bne     L0B3C
	cmp     #$01
	bne     L0B3C
;
; if((resultColumnName = strdup(((struct inputColumn*)(expressionPtr->unionPtrs.voidPtr))->fileColumnName)) == NULL) {
;
	ldy     #$0D
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	ldy     #$03
	jsr     ldaxidx
	jsr     _strdup
	ldy     #$0A
	jsr     staxysp
	cpx     #$00
	jne     L0B5F
	cmp     #$00
	jne     L0B5F
;
; fputs(TDB_MALLOC_FAILED, stderr);
;
	lda     #<(L0B48)
	ldx     #>(L0B48)
;
; else if(d_sprintf(&resultColumnName, TDB_UNTITLED_COLUMN) == FALSE) {
;
	jmp     L1639
L0B3C:	lda     #$0A
	jsr     leaa0sp
	jsr     pushax
	lda     #<(L0B51)
	ldx     #>(L0B51)
	jsr     pushax
	ldy     #$13
	jsr     ldaxysp
	ldy     #$05
	jsr     pushwidx
	ldy     #$06
	jsr     _d_sprintf
	cpx     #$00
	bne     L0B5F
	cmp     #$00
	bne     L0B5F
;
; fputs(TDB_MALLOC_FAILED, stderr);
;
	lda     #<(L0B56)
	ldx     #>(L0B56)
;
; else {
;
	jmp     L1639
;
; free(resultColumnName);
;
L0B35:	ldy     #$0B
	jsr     ldaxysp
	jsr     _free
;
; queryData->hiddenColumnCount++;
;
	ldy     #$0F
	jsr     ldaxysp
	jsr     pushax
	ldy     #$07
	jsr     ldaxidx
	jsr     incax1
	ldy     #$06
	jsr     staxspidx
;
; if(d_sprintf(&resultColumnName, "%d", queryData->hiddenColumnCount) == FALSE) {
;
	lda     #$0A
	jsr     leaa0sp
	jsr     pushax
	lda     #<(L0B62)
	ldx     #>(L0B62)
	jsr     pushax
	ldy     #$13
	jsr     ldaxysp
	ldy     #$07
	jsr     pushwidx
	ldy     #$06
	jsr     _d_sprintf
	cpx     #$00
	bne     L0B5F
	cmp     #$00
	bne     L0B5F
;
; fputs(TDB_MALLOC_FAILED, stderr);
;
	lda     #<(L0B67)
	ldx     #>(L0B67)
L1639:	jsr     pushax
	lda     _stderr
	ldx     _stderr+1
	jsr     _fputs
;
; exit(EXIT_FAILURE);
;
	ldx     #$00
	lda     #$01
	jsr     _exit
;
; currentReference = hash_lookupString(queryData->columnReferenceHashTable, resultColumnName);
;
L0B5F:	ldy     #$0F
	jsr     ldaxysp
	ldy     #$17
	jsr     pushwidx
	ldy     #$0D
	jsr     ldaxysp
	jsr     _hash_lookupString
	ldy     #$06
	jsr     staxysp
;
; if(currentReference == NULL) {
;
	cpx     #$00
	bne     L0B70
	cmp     #$00
	bne     L0B70
;
; reallocMsg((void**)(&newReference), sizeof(struct columnReference));
;
	lda     #$04
	jsr     leaa0sp
	jsr     pushax
	ldx     #$00
	lda     #$0A
	jsr     _reallocMsg
;
; newReference->referenceName = resultColumnName;
;
	ldy     #$05
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$0B
	jsr     ldaxysp
	ldy     #$00
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; newReference->nextReferenceWithName = NULL;
;
	ldy     #$05
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$08
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; hash_addString(queryData->columnReferenceHashTable, resultColumnName, newReference);
;
	ldy     #$0F
	jsr     ldaxysp
	ldy     #$17
	jsr     pushwidx
	ldy     #$0F
	jsr     pushwysp
	ldy     #$09
	jsr     ldaxysp
	jsr     _hash_addString
;
; else {
;
	jmp     L0B9D
;
; free(resultColumnName);
;
L0B70:	ldy     #$0B
	jsr     ldaxysp
	jsr     _free
;
; reallocMsg((void**)(&newReference), sizeof(struct columnReference));
;
	lda     #$04
	jsr     leaa0sp
	jsr     pushax
	ldx     #$00
	lda     #$0A
	jsr     _reallocMsg
;
; if(currentReference->referenceType == REF_COLUMN) {
;
	ldy     #$07
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	cpx     #$00
	jne     L0BA0
	cmp     #$01
	jne     L0BA0
;
; reallocMsg((void**)(&newReference2), sizeof(struct columnReference));
;
	lda     #$02
	jsr     leaa0sp
	jsr     pushax
	ldx     #$00
	lda     #$0A
	jsr     _reallocMsg
;
; memcpy(newReference, currentReference, sizeof(struct columnReference));
;
	ldy     #$07
	jsr     pushwysp
	ldy     #$0B
	jsr     pushwysp
	ldx     #$00
	lda     #$0A
	jsr     _memcpy
;
; memcpy(currentReference, newReference2, sizeof(struct columnReference));
;
	ldy     #$09
	jsr     pushwysp
	ldy     #$07
	jsr     pushwysp
	ldx     #$00
	lda     #$0A
	jsr     _memcpy
;
; free(newReference2);
;
	ldy     #$03
	jsr     ldaxysp
	jsr     _free
;
; currentReference->nextReferenceWithName = newReference;
;
	ldy     #$07
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$05
	jsr     ldaxysp
	ldy     #$08
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; currentReference->referenceName = newReference->referenceName;
;
	ldy     #$07
	jsr     ldaxysp
	sta     sreg
	stx     sreg+1
	ldy     #$05
	jsr     ldaxysp
	jsr     ldaxi
	ldy     #$00
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; newReference = currentReference;
;
	ldy     #$07
	jsr     ldaxysp
	ldy     #$04
	jsr     staxysp
;
; else {
;
	jmp     L0B9D
;
; currentReference = currentReference->nextReferenceWithName;
;
L0B9E:	ldy     #$07
	jsr     ldaxysp
	ldy     #$09
	jsr     ldaxidx
	ldy     #$06
	jsr     staxysp
;
; currentReference->nextReferenceWithName != NULL &&
;
L0BA0:	ldy     #$07
	jsr     ldaxysp
	ldy     #$09
	jsr     ldaxidx
	cpx     #$00
	bne     L162D
	cmp     #$00
	beq     L1628
;
; currentReference->nextReferenceWithName->referenceType != REF_COLUMN
;
L162D:	ldy     #$07
	jsr     ldaxysp
	ldy     #$09
	jsr     ldaxidx
	ldy     #$03
	jsr     ldaxidx
;
; ) {
;
	cpx     #$00
	bne     L0B9E
	cmp     #$01
	bne     L0B9E
;
; newReference->nextReferenceWithName = currentReference->nextReferenceWithName;
;
L1628:	ldy     #$05
	jsr     ldaxysp
	sta     sreg
	stx     sreg+1
	ldy     #$07
	jsr     ldaxysp
	ldy     #$09
	jsr     ldaxidx
	ldy     #$08
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; currentReference->nextReferenceWithName = newReference;
;
	ldy     #$07
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$05
	jsr     ldaxysp
	ldy     #$08
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; newReference->referenceName = currentReference->referenceName;
;
	ldy     #$05
	jsr     ldaxysp
	sta     sreg
	stx     sreg+1
	ldy     #$07
	jsr     ldaxysp
	jsr     ldaxi
	ldy     #$00
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; newReference->referenceType = REF_EXPRESSION;
;
L0B9D:	ldy     #$05
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$02
	tay
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; newReference->reference.calculatedPtr.expressionPtr = expressionPtr;
;
	ldy     #$05
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$0D
	jsr     ldaxysp
	ldy     #$04
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; if(expressionPtr->type == EXP_COLUMN && aggregationType == GRP_NONE) {
;
	ldy     #$0D
	jsr     ldaxysp
	jsr     ldaxi
	cpx     #$00
	jne     L0BB2
	cmp     #$01
	jne     L0BB2
	ldy     #$08
	lda     (sp),y
	iny
	ora     (sp),y
	jne     L0BB2
;
; newResultColumn = ((struct inputColumn*)(expressionPtr->unionPtrs.voidPtr))->firstResultColumn;
;
	ldy     #$0D
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	ldy     #$07
	jsr     ldaxidx
	jsr     stax0sp
;
; newReference->reference.calculatedPtr.firstResultColumn = NULL;
;
	ldy     #$05
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$06
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; while (newResultColumn != NULL) {
;
	jmp     L162F
;
; if(queryData->firstResultColumn == newResultColumn) {
;
L0BBE:	ldy     #$0F
	jsr     ldaxysp
	ldy     #$1D
	jsr     ldaxidx
	ldy     #$00
	cmp     (sp),y
	bne     L1630
	txa
	iny
	cmp     (sp),y
	bne     L1630
;
; queryData->firstResultColumn->isHidden = FALSE;
;
	ldy     #$0F
	jsr     ldaxysp
	ldy     #$1D
	jsr     ldaxidx
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$02
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; queryData->firstResultColumn->resultColumnName = strdup(newReference->referenceName);
;
	ldy     #$0F
	jsr     ldaxysp
	ldy     #$1D
	jsr     pushwidx
	ldy     #$07
	jsr     ldaxysp
	jsr     ldaxi
	jsr     _strdup
	ldy     #$12
	jsr     staxspidx
;
; return queryData->firstResultColumn;
;
	ldy     #$0F
	jsr     ldaxysp
	ldy     #$1D
	jmp     L162A
;
; if(newResultColumn->nextColumnInstance == NULL) {
;
L1630:	jsr     ldax0sp
	ldy     #$15
	jsr     ldaxidx
	cpx     #$00
	bne     L0BCB
	cmp     #$00
	bne     L0BCB
;
; newResultColumn->nextColumnInstance = parse_newOutputColumn(
;
	jsr     pushw0sp
;
; queryData,
;
	ldy     #$13
	jsr     pushwysp
;
; /*isHidden = */FALSE,
;
	jsr     push0
;
; /*isCalculated = */FALSE,
;
	jsr     push0
;
; /*resultColumnName = */strdup(newReference->referenceName),
;
	ldy     #$0D
	jsr     ldaxysp
	jsr     ldaxi
	jsr     _strdup
	jsr     pushax
;
; );
;
	ldx     #$00
	txa
	jsr     _parse_newOutputColumn
	ldy     #$14
	jsr     staxspidx
;
; return newResultColumn->nextColumnInstance;
;
	jsr     ldax0sp
	ldy     #$15
	jmp     L162A
;
; newResultColumn = newResultColumn->nextColumnInstance;
;
L0BCB:	jsr     ldax0sp
	ldy     #$15
	jsr     ldaxidx
	jsr     stax0sp
;
; while (newResultColumn != NULL) {
;
L162F:	ldy     #$00
	lda     (sp),y
	iny
	ora     (sp),y
	jne     L0BBE
;
; return NULL;
;
	tax
	jmp     L0BDB
;
; newReference->reference.calculatedPtr.firstResultColumn = parse_newOutputColumn(
;
L0BB2:	ldy     #$07
	jsr     pushwysp
;
; queryData,
;
	ldy     #$13
	jsr     pushwysp
;
; /*isHidden = */aggregationType != GRP_NONE,
;
	ldy     #$0D
	jsr     ldaxysp
	cpx     #$00
	bne     L0BE0
	cmp     #$00
L0BE0:	jsr     boolne
	jsr     pusha0
;
; /*isCalculated = */TRUE,
;
	lda     #$01
	jsr     pusha0
;
; /*resultColumnName = */strdup(newReference->referenceName),
;
	ldy     #$0D
	jsr     ldaxysp
	jsr     ldaxi
	jsr     _strdup
	jsr     pushax
;
; );
;
	ldy     #$13
	jsr     ldaxysp
	jsr     _parse_newOutputColumn
	ldy     #$06
	jsr     staxspidx
;
; return newReference->reference.calculatedPtr.firstResultColumn;
;
	dey
	jsr     ldaxysp
	ldy     #$07
L162A:	jsr     ldaxidx
;
; }
;
L0BDB:	ldy     #$10
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; __near__ struct expression * __near__ parse_functionRefStar (__near__ struct qryData *, long)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_parse_functionRefStar: near

.segment	"CODE"

;
; ) {
;
	jsr     pusheax
;
; if(queryData->parseMode != 1) {
;
	ldy     #$05
	jsr     ldaxysp
	jsr     ldaxi
	cpx     #$00
	bne     L163C
	cmp     #$01
	beq     L0BE7
;
; return NULL;
;
L163C:	ldx     #$00
	txa
	jmp     L0BE6
;
; if(aggregationType != GRP_COUNT) {
;
L0BE7:	jsr     ldeax0sp
	jsr     pusheax
	ldx     #$00
	stx     sreg
	stx     sreg+1
	lda     #$05
	jsr     tosneeax
	beq     L0BEB
;
; fputs("only count(*) is valid",stderr);
;
	lda     #<(L0BEE)
	ldx     #>(L0BEE)
	jsr     pushax
	lda     _stderr
	ldx     _stderr+1
	jsr     _fputs
;
; exit(EXIT_FAILURE);
;
	ldx     #$00
	lda     #$01
	jsr     _exit
;
; queryData,
;
L0BEB:	ldy     #$07
	jsr     pushwysp
;
; GRP_STAR,
;
	ldx     #$00
	lda     #$07
	jsr     push0ax
;
; parse_scalarExpLiteral(queryData, ""),
;
	ldy     #$0D
	jsr     pushwysp
	lda     #<(L0BF8)
	ldx     #>(L0BF8)
	jsr     _parse_scalarExpLiteral
	jsr     pushax
;
; );
;
	ldx     #$00
	txa
	jsr     _parse_functionRef
;
; }
;
L0BE6:	jsr     incsp6
	jmp     farret

.endproc

; ---------------------------------------------------------------
; int __near__ myfseek (__near__ struct _FILE *, long, int)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_myfseek: near

.segment	"CODE"

;
; int myfseek(FILE *stream, long offset, int origin) {
;
	jsr     pushax
;
; for(current = 0; current<offset; current++) {
;
	jsr     decsp6
	ldx     #$00
	stx     sreg
	stx     sreg+1
	txa
	ldy     #$02
	jsr     steaxysp
L0BFC:	ldy     #$05
	jsr     ldeaxysp
	jsr     pusheax
	ldy     #$0F
	jsr     ldeaxysp
	jsr     toslteax
	beq     L0BFD
;
; c = fgetc(stream);
;
	ldy     #$0D
	jsr     ldaxysp
	jsr     _fgetc
	jsr     stax0sp
;
; for(current = 0; current<offset; current++) {
;
	ldy     #$05
	jsr     ldeaxysp
	jsr     saveeax
	ldy     #$01
	jsr     inceaxy
	ldy     #$02
	jsr     steaxysp
	jsr     resteax
	jmp     L0BFC
;
; return 0;
;
L0BFD:	ldx     #$00
	txa
;
; }
;
	ldy     #$0E
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; void __near__ tree_walkAndCleanup (__near__ struct qryData *, __near__ __near__ struct resultTree * *, __near__ __near__ function returning void *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_tree_walkAndCleanup: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; int i = 0;
;
	jsr     decsp4
	jsr     push0
;
; if(root == NULL || *root == NULL) {
;
	ldy     #$08
	lda     (sp),y
	iny
	ora     (sp),y
	jeq     L0C12
	jsr     ldaxysp
	jsr     ldaxi
	cpx     #$00
	bne     L0C0A
	cmp     #$00
	jeq     L0C12
;
; currentResult = *root;
;
L0C0A:	ldy     #$09
L1646:	jsr     ldaxysp
	ldy     #$01
L1644:	jsr     ldaxidx
	ldy     #$04
	jsr     staxysp
;
; if(currentResult->left) {
;
L0C14:	ldy     #$05
	jsr     ldaxysp
	ldy     #$00
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	iny
	ora     (ptr1),y
	beq     L0C15
;
; currentResult = currentResult->left;
;
	ldy     #$05
;
; continue;
;
	jmp     L1646
;
; if((currentResult->type) != TRE_FREED) {
;
L0C15:	ldy     #$05
	jsr     ldaxysp
	ldy     #$09
	jsr     ldaxidx
	cpx     #$00
	bne     L1640
	cmp     #$03
	beq     L0C19
;
; query,
;
L1640:	ldy     #$09
	jsr     pushwysp
	ldy     #$0F
	jsr     pushwysp
;
; currentResult->columns,
;
	ldy     #$09
	jsr     ldaxysp
	ldy     #$07
	jsr     pushwidx
;
; );
;
	ldy     #$07
	jsr     ldaxysp
	pha
	ldy     #$04
	lda     (sp),y
	sta     jmpvec+1
	iny
	lda     (sp),y
	sta     jmpvec+2
	pla
	jsr     jmpvec
	jsr     incsp2
;
; currentResult->type = TRE_FREED;
;
	ldy     #$05
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$03
	ldy     #$08
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; i+=1;
;
	tax
	lda     #$01
	jsr     addeq0sp
;
; if(currentResult->right) {
;
L0C19:	ldy     #$05
	jsr     ldaxysp
	ldy     #$02
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	iny
	ora     (ptr1),y
	beq     L0C25
;
; currentResult = currentResult->right;
;
	ldy     #$05
	jsr     ldaxysp
	ldy     #$03
;
; continue;
;
	jmp     L1644
;
; parentResult = currentResult->parent;
;
L0C25:	ldy     #$05
	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	ldy     #$02
	jsr     staxysp
;
; if(parentResult != NULL) {
;
	cpx     #$00
	bne     L1641
	cmp     #$00
	beq     L0C2B
;
; if(parentResult->left == currentResult) {
;
L1641:	ldy     #$03
	jsr     ldaxysp
	jsr     ldaxi
	ldy     #$04
	cmp     (sp),y
	bne     L0C2E
	txa
	iny
	cmp     (sp),y
	bne     L0C2E
;
; currentResult = parentResult;
;
	ldy     #$03
	jsr     ldaxysp
	ldy     #$04
	jsr     staxysp
;
; free(currentResult->left);
;
	jsr     ldaxi
	jsr     _free
;
; currentResult->left = NULL;
;
	ldy     #$05
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	tay
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; else {
;
	jmp     L0C14
;
; currentResult = parentResult;
;
L0C2E:	ldy     #$03
	jsr     ldaxysp
	ldy     #$04
	jsr     staxysp
;
; free(currentResult->right);
;
	ldy     #$03
	jsr     ldaxidx
	jsr     _free
;
; currentResult->right = NULL;
;
	ldy     #$05
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$02
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; else {
;
	jmp     L0C14
;
; free(currentResult);
;
L0C2B:	ldy     #$05
	jsr     ldaxysp
	jsr     _free
;
; *root = NULL;
;
	ldy     #$09
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	tay
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; }
;
L0C12:	ldy     #$0C
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; int __near__ runQuery (__near__ unsigned char *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_runQuery: near

.segment	"CODE"

;
; int runQuery(char *queryFileName) {
;
	jsr     pushax
;
; struct resultColumnValue* match = NULL;
;
	ldy     #$28
	jsr     subysp
	jsr     push0
;
; readQuery(queryFileName, &query);
;
	ldy     #$2D
	jsr     pushwysp
	lda     #$04
	jsr     leaa0sp
	jsr     _readQuery
;
; (void**)&match,
;
	lda     sp
	ldx     sp+1
	jsr     pushax
;
; (query.columnCount)*sizeof(struct resultColumnValue)
;
	ldy     #$0B
;
; );
;
	jsr     pushwysp
	lda     #$0E
	jsr     tosumula0
	jsr     _reallocMsg
;
; query.orderByClause == NULL &&
;
	ldy     #$22
	lda     (sp),y
	iny
	ora     (sp),y
	bne     L0C4B
;
; query.intoFileName == NULL &&
;
	ldy     #$12
	lda     (sp),y
	iny
	ora     (sp),y
	bne     L0C4B
;
; query.groupByClause == NULL
;
	ldy     #$24
	lda     (sp),y
	iny
	ora     (sp),y
;
; ) {
;
	bne     L0C4B
;
; outputHeader(&query); 
;
	lda     #$02
	jsr     leaa0sp
	jsr     _outputHeader
;
; while(getMatchingRecord(&query, match)) {
;
	jmp     L0C56
;
; outputResult(&query, match, 0);
;
L0C54:	lda     #$02
	jsr     leaa0sp
	jsr     pushax
	ldy     #$05
	jsr     pushwysp
	ldx     #$00
	txa
	jsr     _outputResult
;
; match = NULL;
;
	ldx     #$00
	txa
	jsr     stax0sp
;
; (void**)&match,
;
	lda     sp
	ldx     sp+1
	jsr     pushax
;
; (query.columnCount)*sizeof(struct resultColumnValue)
;
	ldy     #$0B
;
; );
;
	jsr     pushwysp
	lda     #$0E
	jsr     tosumula0
	jsr     _reallocMsg
;
; while(getMatchingRecord(&query, match)) {
;
L0C56:	lda     #$02
	jsr     leaa0sp
	jsr     pushax
	ldy     #$03
	jsr     ldaxysp
	jsr     _getMatchingRecord
	stx     tmp1
	ora     tmp1
	bne     L0C54
;
; free(match);
;
	jsr     ldax0sp
	jsr     _free
;
; match = NULL;
;
	ldx     #$00
	txa
	jsr     stax0sp
;
; else {
;
	jmp     L0C91
;
; if(query.groupByClause != NULL) {
;
L0C4B:	ldy     #$24
	lda     (sp),y
	iny
	ora     (sp),y
	beq     L0C70
;
; query.useGroupBy = TRUE;
;
	ldx     #$00
	lda     #$01
	ldy     #$0E
	jsr     staxysp
;
; while(getMatchingRecord(&query, match)) {
;
	jmp     L0C70
;
; tree_insert(&query, match, &(query.resultSet));
;
L0C6E:	lda     #$02
	jsr     leaa0sp
	jsr     pushax
	ldy     #$05
	jsr     pushwysp
	lda     #$2A
	jsr     leaa0sp
	jsr     _tree_insert
;
; match = NULL;
;
	ldx     #$00
	txa
	jsr     stax0sp
;
; (void**)&match,
;
	lda     sp
	ldx     sp+1
	jsr     pushax
;
; (query.columnCount)*sizeof(struct resultColumnValue)
;
	ldy     #$0B
;
; );
;
	jsr     pushwysp
	lda     #$0E
	jsr     tosumula0
	jsr     _reallocMsg
;
; while(getMatchingRecord(&query, match)) {
;
L0C70:	lda     #$02
	jsr     leaa0sp
	jsr     pushax
	ldy     #$03
	jsr     ldaxysp
	jsr     _getMatchingRecord
	stx     tmp1
	ora     tmp1
	bne     L0C6E
;
; free(match);
;
	jsr     ldax0sp
	jsr     _free
;
; match = NULL;
;
	ldx     #$00
	txa
	jsr     stax0sp
;
; if(query.groupByClause != NULL) {
;
	ldy     #$24
	lda     (sp),y
	iny
	ora     (sp),y
	beq     L0C83
;
; groupResults(&query);
;
	lda     #$02
	jsr     leaa0sp
	jsr     _groupResults
;
; query.useGroupBy = FALSE;
;
	ldx     #$00
	txa
	ldy     #$0E
	jsr     staxysp
;
; outputHeader(&query);
;
L0C83:	lda     #$02
	jsr     leaa0sp
	jsr     _outputHeader
;
; &query,
;
	lda     #$02
	jsr     leaa0sp
	jsr     pushax
;
; &(query.resultSet),
;
	lda     #$28
	jsr     leaa0sp
	jsr     pushax
;
; );
;
	lda     #<(_outputResult)
	ldx     #>(_outputResult)
	jsr     _tree_walkAndCleanup
;
; if(query.intoFileName) {
;
	ldy     #$13
	lda     (sp),y
	dey
	ora     (sp),y
	beq     L0C91
;
; fclose(query.outputFile);
;
	ldy     #$17
	jsr     ldaxysp
	jsr     _fclose
;
; fprintf(stdout, "%d", query.recordCount);
;
	lda     _stdout
	ldx     _stdout+1
	jsr     pushax
	lda     #<(L0C97)
	ldx     #>(L0C97)
	jsr     pushax
	ldy     #$11
	jsr     pushwysp
	ldy     #$06
	jsr     _fprintf
;
; fflush(stdout);
;
	lda     _stdout
	ldx     _stdout+1
	jsr     _fflush
;
; cleanup_query(&query);
;
L0C91:	lda     #$02
	jsr     leaa0sp
	jsr     _cleanup_query
;
; return 0;
;
	ldx     #$00
	txa
;
; }
;
	ldy     #$2C
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; unsigned int __near__ hash_compare (__near__ struct columnReferenceHash *, __near__ unsigned char *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_hash_compare: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; hashval = 0;
;
	jsr     decsp2
	ldx     #$00
	txa
	tay
L1648:	jsr     staxysp
;
; for(; *str != '\0'; str++) {
;
	ldy     #$03
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	beq     L0CA3
;
; hashval = *str + (hashval << 5) - hashval;
;
	ldy     #$03
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	sta     ptr1
	jsr     ldax0sp
	jsr     shlax4
	jsr     shlax1
	clc
	adc     ptr1
	bcc     L1647
	inx
L1647:	sec
	ldy     #$00
	sbc     (sp),y
	pha
	txa
	iny
	sbc     (sp),y
	tax
	pla
	jsr     stax0sp
;
; for(; *str != '\0'; str++) {
;
	ldy     #$03
	jsr     ldaxysp
	jsr     incax1
	ldy     #$02
	jmp     L1648
;
; return hashval % hashtable->size;
;
L0CA3:	jsr     pushw0sp
	ldy     #$07
	jsr     ldaxysp
	jsr     ldaxi
	jsr     tosumodax
;
; }
;
	jsr     incsp6
	jmp     farret

.endproc

; ---------------------------------------------------------------
; __near__ struct columnReference * __near__ hash_lookupString (__near__ struct columnReferenceHash *, __near__ unsigned char *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_hash_lookupString: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; unsigned int hashval = hash_compare(hashtable, str);
;
	jsr     decsp2
	ldy     #$07
	jsr     pushwysp
	ldy     #$05
	jsr     ldaxysp
	jsr     _hash_compare
	jsr     pushax
;
; for(list = hashtable->table[hashval]; list != NULL; list = list->nextReferenceInHash) {
;
	ldy     #$07
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	sta     ptr1
	stx     ptr1+1
	jsr     ldax0sp
	jsr     aslax1
	clc
	adc     ptr1
	pha
	txa
	adc     ptr1+1
	tax
	pla
	ldy     #$01
L164B:	jsr     ldaxidx
	ldy     #$02
	jsr     staxysp
	ldy     #$02
	lda     (sp),y
	iny
	ora     (sp),y
	beq     L0CB1
;
; if (strcmp(str, list->referenceName) == 0) {
;
	ldy     #$07
	jsr     pushwysp
	ldy     #$05
	jsr     ldaxysp
	jsr     ldaxi
	jsr     _strcmp
	cpx     #$00
	bne     L0CB2
	cmp     #$00
	bne     L0CB2
;
; return list->content;
;
	ldy     #$03
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	jmp     L0CAC
;
; for(list = hashtable->table[hashval]; list != NULL; list = list->nextReferenceInHash) {
;
L0CB2:	ldy     #$03
	jsr     ldaxysp
	ldy     #$05
	jmp     L164B
;
; return NULL;
;
L0CB1:	tax
;
; }
;
L0CAC:	jsr     incsp8
	jmp     farret

.endproc

; ---------------------------------------------------------------
; void __near__ reallocMsg (__near__ __near__ void * *, unsigned int)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_reallocMsg: near

.segment	"CODE"

;
; void reallocMsg(void **mem, size_t size) {
;
	jsr     pushax
;
; void *temp = NULL;
;
	jsr     push0
;
; if((temp = realloc(*mem, size)) == NULL) {
;
	ldy     #$05
	jsr     ldaxysp
	jsr     pushw
	ldy     #$05
	jsr     ldaxysp
	jsr     _realloc
	jsr     stax0sp
	cpx     #$00
	bne     L0CC4
	cmp     #$00
	bne     L0CC4
;
; fputs(TDB_MALLOC_FAILED, stderr);
;
	lda     #<(L0CCC)
	ldx     #>(L0CCC)
	jsr     pushax
	lda     _stderr
	ldx     _stderr+1
	jsr     _fputs
;
; exit(EXIT_FAILURE);
;
	ldx     #$00
	lda     #$01
	jsr     _exit
;
; *mem = temp;
;
L0CC4:	ldy     #$05
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	jsr     ldax0sp
	ldy     #$00
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; }
;
	jsr     incsp6
	jmp     farret

.endproc

; ---------------------------------------------------------------
; int __near__ consumeCombiningChars (__near__ __near__ unsigned char * *, __near__ __near__ unsigned char * *, __near__ __near__ unsigned char * *, __near__ __near__ unsigned char * *, __near__ __near__ function returning void *, __near__ __near__ function returning void *, __near__ int *, __near__ int *, __near__ int *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_consumeCombiningChars: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; int combiner1, combiner2, skip1 = FALSE, skip2 = FALSE;
;
	jsr     decsp4
	jsr     push0
	jsr     push0
;
; (*offset1)+=(*bytesMatched1);
;
	ldy     #$15
	jsr     ldaxysp
	jsr     pushax
	jsr     pushw
	ldy     #$11
	jsr     ldaxysp
	jsr     ldaxi
	jsr     tosaddax
	ldy     #$00
	jsr     staxspidx
;
; (*offset2)+=(*bytesMatched2);
;
	ldy     #$13
	jsr     ldaxysp
	jsr     pushax
	jsr     pushw
	ldy     #$0F
	jsr     ldaxysp
	jsr     ldaxi
	jsr     tosaddax
	ldy     #$00
	jsr     staxspidx
;
; if(skip1 == FALSE) {
;
L0CDE:	ldy     #$02
	lda     (sp),y
	iny
	ora     (sp),y
	bne     L0CE1
;
; (*((int (*)(unsigned char **, unsigned char **, int,  int *, void (*)()))get1))
;
	ldy     #$13
;
; (offset1, str1, 0, bytesMatched1, get1)
;
	jsr     pushwysp
	ldy     #$19
	jsr     pushwysp
	ldy     #$1F
	jsr     pushwysp
	jsr     push0
	ldy     #$17
	jsr     pushwysp
	ldy     #$1B
	jsr     ldaxysp
;
; );
;
	pha
	ldy     #$08
	lda     (sp),y
	sta     jmpvec+1
	iny
	lda     (sp),y
	sta     jmpvec+2
	pla
	jsr     jmpvec
	jsr     incsp2
	jsr     axlong
	jsr     _isCombiningChar
	ldy     #$06
	jsr     staxysp
;
; if(skip2 == FALSE) {
;
L0CE1:	ldy     #$00
	lda     (sp),y
	iny
	ora     (sp),y
	bne     L0CEE
;
; (*((int (*)(unsigned char **, unsigned char **, int,  int *, void (*)()))get2))
;
	ldy     #$11
;
; (offset2, str2, 0, bytesMatched2, get2)
;
	jsr     pushwysp
	ldy     #$17
	jsr     pushwysp
	ldy     #$1D
	jsr     pushwysp
	jsr     push0
	ldy     #$15
	jsr     pushwysp
	ldy     #$19
	jsr     ldaxysp
;
; );
;
	pha
	ldy     #$08
	lda     (sp),y
	sta     jmpvec+1
	iny
	lda     (sp),y
	sta     jmpvec+2
	pla
	jsr     jmpvec
	jsr     incsp2
	jsr     axlong
	jsr     _isCombiningChar
	ldy     #$04
	jsr     staxysp
;
; if(skip1 == FALSE && skip2 == FALSE) {
;
L0CEE:	ldy     #$02
	lda     (sp),y
	iny
	ora     (sp),y
	bne     L0D0C
	tay
	lda     (sp),y
	iny
	ora     (sp),y
	bne     L0D0C
;
; if(combiner1 != combiner2) {
;
	ldy     #$07
	jsr     ldaxysp
	ldy     #$04
	cmp     (sp),y
	bne     L164F
	txa
	iny
	cmp     (sp),y
	beq     L0D0C
;
; if(*accentcheck == 2) {
;
L164F:	ldy     #$09
	jsr     ldaxysp
	jsr     ldaxi
	cpx     #$00
	bne     L0D03
	cmp     #$02
	bne     L0D03
;
; return (combiner1 > combiner2) ? 1 : -1;
;
	ldy     #$09
	jsr     pushwysp
	ldy     #$07
	jsr     ldaxysp
	jsr     tosicmp
	bmi     L0D08
	beq     L0D08
	ldx     #$00
	lda     #$01
	jmp     L0CD3
L0D08:	ldx     #$FF
	jmp     L1650
;
; *accentcheck = 1;
;
L0D03:	ldy     #$09
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$01
	ldy     #$00
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; if(combiner1 == 0) {
;
L0D0C:	ldy     #$06
	lda     (sp),y
	iny
	ora     (sp),y
	bne     L0D0F
;
; skip1 = TRUE; 
;
	tax
	lda     #$01
	ldy     #$02
	jsr     staxysp
;
; else {
;
	jmp     L0D14
;
; (*offset1)+=(*bytesMatched1);
;
L0D0F:	ldy     #$15
	jsr     ldaxysp
	jsr     pushax
	jsr     pushw
	ldy     #$11
	jsr     ldaxysp
	jsr     ldaxi
	jsr     tosaddax
	ldy     #$00
	jsr     staxspidx
;
; if(combiner2 == 0) {
;
L0D14:	ldy     #$04
	lda     (sp),y
	iny
	ora     (sp),y
	bne     L0D19
;
; skip2 = TRUE; 
;
	tax
	lda     #$01
	jsr     stax0sp
;
; else {
;
	jmp     L0D1E
;
; (*offset2)+=(*bytesMatched2);
;
L0D19:	ldy     #$13
	jsr     ldaxysp
	jsr     pushax
	jsr     pushw
	ldy     #$0F
	jsr     ldaxysp
	jsr     ldaxi
	jsr     tosaddax
	ldy     #$00
	jsr     staxspidx
;
; } while (skip1 == FALSE || skip2 == FALSE);
;
L0D1E:	ldy     #$02
	lda     (sp),y
	iny
	ora     (sp),y
	jeq     L0CDE
	ldy     #$00
	lda     (sp),y
	iny
	ora     (sp),y
	jeq     L0CDE
	ldx     #$00
L1650:	txa
;
; }
;
L0CD3:	ldy     #$1A
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; int __near__ getNextRecordOffset (__near__ unsigned char *, long)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_getNextRecordOffset: near

.segment	"CODE"

;
; int getNextRecordOffset(char *inputFileName, long offset) {
;
	jsr     pusheax
;
; FILE *inputFile = NULL;
;
	jsr     push0
;
; inputFile = skipBom(inputFileName, NULL);
;
	ldy     #$09
	jsr     pushwysp
	ldx     #$00
	txa
	jsr     _skipBom
	jsr     stax0sp
;
; if(inputFile == NULL) {
;
	cpx     #$00
	bne     L0D2E
	cmp     #$00
	bne     L0D2E
;
; fputs(TDB_COULDNT_OPEN_INPUT, stderr);
;
	lda     #<(L0D32)
	ldx     #>(L0D32)
	jsr     pushax
	lda     _stderr
	ldx     _stderr+1
	jsr     _fputs
;
; return -1;
;
	ldx     #$FF
	jmp     L1652
;
; if(myfseek(inputFile, offset, SEEK_SET) != 0) {
;
L0D2E:	jsr     pushw0sp
	ldy     #$07
	jsr     ldeaxysp
	jsr     pusheax
	ldx     #$00
	lda     #$02
	jsr     _myfseek
	cpx     #$00
	bne     L1651
	cmp     #$00
	beq     L0D43
;
; fputs(TDB_COULDNT_SEEK, stderr);
;
L1651:	lda     #<(L0D3D)
	ldx     #>(L0D3D)
	jsr     pushax
	lda     _stderr
	ldx     _stderr+1
	jsr     _fputs
;
; return -1;
;
	ldx     #$FF
	jmp     L1652
;
; while(getCsvColumn(&inputFile, NULL, NULL, NULL, &offset, TRUE)) {
;
L0D43:	lda     sp
	ldx     sp+1
	jsr     pushax
	jsr     push0
	jsr     push0
	jsr     push0
	lda     #$0A
	jsr     leaa0sp
	jsr     pushax
	ldx     #$00
	lda     #$01
	jsr     _getCsvColumn
	stx     tmp1
	ora     tmp1
	bne     L0D43
;
; fprintf(stdout, "%ld", offset);
;
	lda     _stdout
	ldx     _stdout+1
	jsr     pushax
	lda     #<(L0D4D)
	ldx     #>(L0D4D)
	jsr     pushax
	ldy     #$09
	jsr     ldeaxysp
	jsr     pusheax
	ldy     #$08
	jsr     _fprintf
;
; fclose(inputFile);
;
	jsr     ldax0sp
	jsr     _fclose
;
; return 0;
;
	ldx     #$00
L1652:	txa
;
; }
;
	jsr     incsp8
	jmp     farret

.endproc

; ---------------------------------------------------------------
; int __near__ getMatchingRecord (__near__ struct qryData *, __near__ struct resultColumnValue *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_getMatchingRecord: near

.segment	"CODE"

;
; {
;
	jsr     pushax
;
; int doLeftRecord = FALSE;
;
	ldy     #$1A
	jsr     subysp
	jsr     push0
;
; long templong = 0;
;
	jsr     pushl0
;
; matchParams.ptr = match;
;
	ldy     #$21
	jsr     ldaxysp
	ldy     #$0A
	jsr     staxysp
;
; matchParams.params = query->params;
;
	ldy     #$23
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	ldy     #$08
	jsr     staxysp
;
; if(query->secondaryInputTable == NULL) {
;
	ldy     #$23
	jsr     ldaxysp
	ldy     #$1B
	jsr     ldaxidx
	cpx     #$00
	bne     L0D5A
	cmp     #$00
	bne     L0D5A
;
; query->secondaryInputTable = query->firstInputTable;
;
	ldy     #$23
	jsr     ldaxysp
	sta     sreg
	stx     sreg+1
	ldy     #$23
	jsr     ldaxysp
	ldy     #$19
	jsr     ldaxidx
	ldy     #$1A
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; currentInputTable = query->secondaryInputTable;
;
L0D5A:	ldy     #$23
	jsr     ldaxysp
	ldy     #$1B
	jsr     ldaxidx
	ldy     #$1E
;
; while(
;
	jmp     L1656
;
; recordHasColumn = TRUE;
;
L165D:	ldy     #$06
	jsr     staxysp
;
; currentInputColumn = currentInputTable->firstInputColumn;
;
	ldy     #$1F
	jsr     ldaxysp
	ldy     #$13
L166A:	jsr     ldaxidx
	ldy     #$1C
	jsr     staxysp
;
; currentInputColumn != NULL;
;
	ldy     #$1C
	lda     (sp),y
	iny
	ora     (sp),y
	jeq     L0D72
;
; if(recordHasColumn == TRUE && !doLeftRecord) {
;
	ldy     #$07
	lda     (sp),y
	bne     L0D7B
	dey
	lda     (sp),y
	cmp     #$01
	bne     L0D7B
	dey
	lda     (sp),y
	dey
	ora     (sp),y
	bne     L0D7B
;
; columnOffsetData.value = NULL;
;
	tax
	ldy     #$18
	jsr     staxysp
;
; templong = columnOffsetData.startOffset;
;
	ldy     #$0F
	jsr     ldeaxysp
	jsr     steax0sp
;
; &(currentInputTable->fileStream),
;
	ldy     #$1F
	jsr     ldaxysp
	ldy     #$0E
	jsr     incaxy
	jsr     pushax
;
; &(columnOffsetData.value),
;
	lda     #$1A
	jsr     leaa0sp
	jsr     pushax
;
; &(columnOffsetData.length),
;
	lda     #$1A
	jsr     leaa0sp
	jsr     pushax
;
; &(columnOffsetData.isQuoted),
;
	lda     #$16
	jsr     leaa0sp
	jsr     pushax
;
; &(templong),
;
	lda     #$08
	jsr     leaa0sp
	jsr     pushax
;
; (query->params & PRM_TRIM) == 0
;
	ldy     #$2D
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	and     #$01
;
; );
;
	jsr     booleq
	jsr     _getCsvColumn
	ldy     #$06
	jsr     staxysp
;
; columnOffsetData.isNormalized = FALSE;
;
	ldx     #$00
	txa
	ldy     #$12
	jsr     staxysp
;
; columnOffsetData.leftNull = FALSE;
;
	ldy     #$14
;
; else {
;
	jmp     L1657
;
; columnOffsetData.leftNull = doLeftRecord;
;
L0D7B:	ldy     #$05
	jsr     ldaxysp
	ldy     #$14
	jsr     staxysp
;
; columnOffsetData.startOffset = 0;
;
	ldx     #$00
	stx     sreg
	stx     sreg+1
	txa
	ldy     #$0C
	jsr     steaxysp
;
; columnOffsetData.length = 0;
;
	ldy     #$16
	jsr     staxysp
;
; columnOffsetData.isQuoted = FALSE;
;
	ldy     #$10
	jsr     staxysp
;
; columnOffsetData.isNormalized = TRUE; /* an empty string needs no unicode normalization */
;
	lda     #$01
	ldy     #$12
	jsr     staxysp
;
; columnOffsetData.value = strdup("");
;
	lda     #<(L0DA4)
	ldx     #>(L0DA4)
	jsr     _strdup
	ldy     #$18
L1657:	jsr     staxysp
;
; currentResultColumn = currentInputColumn->firstResultColumn;
;
	ldy     #$1D
	jsr     ldaxysp
	ldy     #$07
L1669:	jsr     ldaxidx
	ldy     #$1A
	jsr     staxysp
;
; currentResultColumn != NULL;
;
	ldy     #$1A
	lda     (sp),y
	iny
	ora     (sp),y
	beq     L0D73
;
; &(match[currentResultColumn->resultColumnIndex]),
;
	ldy     #$23
	jsr     pushwysp
	ldy     #$1D
	jsr     ldaxysp
	jsr     pushw
	lda     #$0E
	jsr     tosmula0
	jsr     tosaddax
	jsr     pushax
;
; &columnOffsetData,
;
	lda     #$0E
	jsr     leaa0sp
	jsr     pushax
;
; );
;
	ldx     #$00
	lda     #$0E
	jsr     _memcpy
;
; ) {
;
	ldy     #$1B
	jsr     ldaxysp
	ldy     #$15
	jmp     L1669
;
; ) {  /* columns */
;
L0D73:	ldy     #$1D
	jsr     ldaxysp
	ldy     #$09
	jmp     L166A
;
; if(recordHasColumn == TRUE && !doLeftRecord) {
;
L0D72:	ldy     #$07
	lda     (sp),y
	bne     L0DBC
	dey
	lda     (sp),y
	cmp     #$01
	bne     L0DBC
	dey
	lda     (sp),y
	dey
	ora     (sp),y
	bne     L0DBC
;
; &(currentInputTable->fileStream),
;
L0DBD:	ldy     #$1F
	jsr     ldaxysp
	ldy     #$0E
	jsr     incaxy
	jsr     pushax
;
; NULL,
;
	jsr     push0
;
; NULL,
;
	jsr     push0
;
; NULL,
;
	jsr     push0
;
; NULL,
;
	jsr     push0
;
; (query->params & PRM_TRIM) == 0
;
	ldy     #$2D
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	and     #$01
;
; )) {
;
	jsr     booleq
	jsr     _getCsvColumn
	stx     tmp1
	ora     tmp1
	bne     L0DBD
;
; currentInputTable->fileIndex,
;
L0DBC:	ldy     #$1F
	jsr     ldaxysp
	jsr     pushw
;
; query->joinsAndWhereClause,
;
	ldy     #$25
	jsr     ldaxysp
	ldy     #$1F
	jsr     pushwidx
;
; )) {
;
	lda     #$0C
	jsr     leaa0sp
	jsr     _walkRejectRecord
	stx     tmp1
	ora     tmp1
	beq     L0DC8
;
; if(doLeftRecord) {
;
	ldy     #$05
	lda     (sp),y
	dey
	ora     (sp),y
	jeq     L0D66
;
; doLeftRecord = FALSE;
;
	ldx     #$00
	txa
	jsr     staxysp
;
; break;
;
	jmp     L0D65
;
; else if(currentInputTable->nextInputTable == NULL) {
;
L0DC8:	ldy     #$1F
	jsr     ldaxysp
	ldy     #$11
	jsr     ldaxidx
	cpx     #$00
	jne     L0DD3
	cmp     #$00
	jne     L0DD3
;
; currentInputTable->noLeftRecord = FALSE;
;
	ldy     #$1F
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$06
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; currentInputTable = query->firstInputTable;
;
	ldy     #$23
	jsr     ldaxysp
	ldy     #$19
;
; while((currentInputTable) != (query->secondaryInputTable)) {
;
	jmp     L166B
;
; currentInputTable->noLeftRecord = FALSE;
;
L0DDA:	ldy     #$1F
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$06
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; currentInputTable = currentInputTable->nextInputTable;
;
	ldy     #$1F
	jsr     ldaxysp
	ldy     #$11
L166B:	jsr     ldaxidx
	ldy     #$1E
	jsr     staxysp
;
; while((currentInputTable) != (query->secondaryInputTable)) {
;
	sta     sreg
	stx     sreg+1
	ldy     #$23
	jsr     ldaxysp
	ldy     #$1B
	jsr     ldaxidx
	cpx     sreg+1
	bne     L0DDA
	cmp     sreg
	bne     L0DDA
;
; currentInputTable = query->secondaryInputTable;
;
	ldy     #$23
	jsr     ldaxysp
	ldy     #$1B
	jsr     ldaxidx
	ldy     #$1E
	jsr     staxysp
;
; getCalculatedColumns(query, match, FALSE);
;
	ldy     #$25
	jsr     pushwysp
	ldy     #$25
	jsr     pushwysp
	ldx     #$00
	txa
	jsr     _getCalculatedColumns
;
; currentInputTable->fileIndex+1, /* +1 means all tables and *CALCULATED* columns */
;
	ldy     #$1F
	jsr     ldaxysp
	jsr     ldaxi
	jsr     incax1
	jsr     pushax
;
; query->joinsAndWhereClause,
;
	ldy     #$25
	jsr     ldaxysp
	ldy     #$1F
	jsr     pushwidx
;
; )) {
;
	lda     #$0C
	jsr     leaa0sp
	jsr     _walkRejectRecord
	stx     tmp1
	ora     tmp1
	bne     L0DF0
;
; return TRUE;
;
	tax
	lda     #$01
	jmp     L0D53
;
; currentInputTable = query->secondaryInputTable = currentInputTable->nextInputTable;
;
L0DD3:	ldy     #$25
	jsr     pushwysp
	ldy     #$21
	jsr     ldaxysp
	ldy     #$11
	jsr     ldaxidx
	ldy     #$1A
	jsr     staxspidx
	ldy     #$1E
	jsr     staxysp
;
; doLeftRecord = FALSE;
;
L0DF0:	ldx     #$00
	txa
	ldy     #$04
L1656:	jsr     staxysp
;
; endOfFile(currentInputTable->fileStream) ||
;
L0D66:	ldy     #$1F
L165E:	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	jsr     _endOfFile
	stx     tmp1
	ora     tmp1
	bne     L0D67
;
; currentInputTable->isLeftJoined &&
;
	ldy     #$1F
	jsr     ldaxysp
	ldy     #$04
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	iny
	ora     (ptr1),y
	beq     L0D65
;
; currentInputTable->noLeftRecord &&
;
	ldy     #$1F
	jsr     ldaxysp
	ldy     #$06
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	iny
	ora     (ptr1),y
	beq     L0D65
;
; (doLeftRecord = TRUE)
;
	ldx     #$00
	lda     #$01
	ldy     #$04
	jsr     staxysp
;
; )
;
	jmp     L165D
;
; ) {   /* records */
;
L0D67:	ldx     #$00
	lda     #$01
	jmp     L165D
;
; myfseek(currentInputTable->fileStream, currentInputTable->firstRecordOffset, SEEK_SET);
;
L0D65:	ldy     #$1F
	jsr     ldaxysp
	ldy     #$0F
	jsr     pushwidx
	ldy     #$21
	jsr     ldaxysp
	ldy     #$0B
	jsr     ldeaxidx
	jsr     pusheax
	ldx     #$00
	lda     #$02
	jsr     _myfseek
;
; currentInputTable->noLeftRecord = TRUE;
;
	ldy     #$1F
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$01
	ldy     #$06
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; if(currentInputTable->fileIndex == 1) {
;
	ldy     #$1F
	jsr     ldaxysp
	jsr     ldaxi
	cpx     #$00
	bne     L0DFC
	cmp     #$01
	bne     L0DFC
;
; currentInputTable = NULL;
;
	txa
	ldy     #$1E
	jsr     staxysp
;
; else {
;
	jmp     L0E01
;
; currentInputTable = query->firstInputTable;
;
L0DFC:	ldy     #$23
	jsr     ldaxysp
	ldy     #$19
;
; while(currentInputTable->nextInputTable != query->secondaryInputTable) {
;
	jmp     L166C
;
; currentInputTable = currentInputTable->nextInputTable;
;
L0E04:	ldy     #$1F
	jsr     ldaxysp
	ldy     #$11
L166C:	jsr     ldaxidx
	ldy     #$1E
	jsr     staxysp
;
; while(currentInputTable->nextInputTable != query->secondaryInputTable) {
;
	ldy     #$11
	jsr     ldaxidx
	sta     sreg
	stx     sreg+1
	ldy     #$23
	jsr     ldaxysp
	ldy     #$1B
	jsr     ldaxidx
	cpx     sreg+1
	bne     L0E04
	cmp     sreg
	bne     L0E04
;
; query->secondaryInputTable = currentInputTable;
;
	ldy     #$23
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$1F
	jsr     ldaxysp
	ldy     #$1A
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; } while (currentInputTable != NULL);
;
L0E01:	ldy     #$1E
	lda     (sp),y
	iny
	ora     (sp),y
	jne     L165E
;
; return FALSE;
;
	tax
;
; }
;
L0D53:	ldy     #$24
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; void __near__ stringGet (__near__ __near__ unsigned char * *, __near__ struct resultColumnValue *, int)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_stringGet: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; if(str != NULL) {
;
	ldy     #$04
	lda     (sp),y
	iny
	ora     (sp),y
	beq     L0E10
;
; *str = (unsigned char *)(strdup((char const *)(field->value)));
;
	ldy     #$07
	jsr     pushwysp
	ldy     #$05
	jsr     ldaxysp
	ldy     #$0D
	jsr     ldaxidx
	jsr     _strdup
	ldy     #$00
	jsr     staxspidx
;
; }
;
L0E10:	jsr     incsp6
	jmp     farret

.endproc

; ---------------------------------------------------------------
; void __near__ cleanup_inputTables (__near__ struct inputTable *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_cleanup_inputTables: near

.segment	"CODE"

;
; void cleanup_inputTables(struct inputTable *currentInputTable) {
;
	jsr     pushax
;
; while(currentInputTable != NULL) {
;
	jsr     decsp2
	jmp     L0E1B
;
; next = currentInputTable->nextInputTable;
;
L166D:	jsr     ldaxysp
	ldy     #$11
	jsr     ldaxidx
	jsr     stax0sp
;
; free(currentInputTable->queryTableName);
;
	ldy     #$03
	jsr     ldaxysp
	ldy     #$0D
	jsr     ldaxidx
	jsr     _free
;
; fclose(currentInputTable->fileStream);
;
	ldy     #$03
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	jsr     _fclose
;
; free(currentInputTable);
;
	ldy     #$03
	jsr     ldaxysp
	jsr     _free
;
; currentInputTable = next;
;
	jsr     ldax0sp
	ldy     #$02
	jsr     staxysp
;
; while(currentInputTable != NULL) {
;
L0E1B:	ldy     #$02
	lda     (sp),y
	iny
	ora     (sp),y
	bne     L166D
;
; }
;
	jsr     incsp4
	jmp     farret

.endproc

; ---------------------------------------------------------------
; void __near__ outputResult (__near__ struct qryData *, __near__ struct resultColumnValue *, int)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_outputResult: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; int firstColumn = TRUE, j;
;
	jsr     decsp4
	lda     #$01
	jsr     pusha0
;
; FILE *outputFile = query->outputFile;
;
	jsr     decsp2
	ldy     #$0D
	jsr     ldaxysp
	ldy     #$15
	jsr     pushwidx
;
; char *separator = (((query->params) & PRM_SPACE) != 0)?",":", ";
;
	ldy     #$0F
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	and     #$02
	beq     L0E31
	lda     #<(L0E30)
	ldx     #>(L0E30)
	jmp     L0E34
L0E31:	lda     #<(L0E33)
	ldx     #>(L0E33)
L0E34:	jsr     pushax
;
; char *string = NULL;
;
	jsr     push0
;
; char *string2 = NULL;
;
	jsr     push0
;
; j=0;
;
	ldy     #$08
	jsr     staxysp
;
; currentResultColumn = query->firstResultColumn;
;
	ldy     #$15
	jsr     ldaxysp
	ldy     #$1D
L1674:	jsr     ldaxidx
	ldy     #$0E
	jsr     staxysp
;
; currentResultColumn != NULL;
;
	ldy     #$0E
	lda     (sp),y
	iny
	ora     (sp),y
	jeq     L0E3B
;
; if(currentResultColumn->isHidden == FALSE) {
;
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	cpx     #$00
	jne     L0E55
	cmp     #$00
	jne     L0E55
;
; if (!firstColumn) {
;
	ldy     #$0B
	lda     (sp),y
	dey
	ora     (sp),y
	bne     L1672
;
; fputs(separator, outputFile);
;
	ldy     #$07
	jsr     pushwysp
	ldy     #$09
	jsr     ldaxysp
	jsr     _fputs
;
; else {
;
	jmp     L0E4C
;
; firstColumn = FALSE;
;
L1672:	txa
	jsr     staxysp
;
; field = &(columns[j]);
;
L0E4C:	ldy     #$15
	jsr     pushwysp
	ldy     #$0D
	jsr     pushwysp
	lda     #$0E
	jsr     tosmula0
	jsr     tosaddax
	ldy     #$0C
	jsr     staxysp
;
; switch(field->leftNull) {
;
	ldy     #$09
	jsr     ldaxidx
;
; }
;
	cpx     #$00
	bne     L0E61
	cmp     #$01
	bne     L0E61
;
; if(((query->params) & PRM_EXPORT) != 0) {
;
	ldy     #$15
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	and     #$08
	jeq     L0E55
;
; fputs("\\N", outputFile);
;
	lda     #<(L0E5E)
	ldx     #>(L0E5E)
;
; } break;
;
	jmp     L1675
;
; stringGet((unsigned char **)(&string), field, query->params);
;
L0E61:	lda     #$02
	jsr     leaa0sp
	jsr     pushax
	ldy     #$11
	jsr     pushwysp
	ldy     #$19
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	jsr     _stringGet
;
; if(*string == '\0') {
;
	ldy     #$03
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	bne     L0E67
;
; fputs("\"\"", outputFile);  /* empty string always needs escaping */
;
	lda     #<(L0E6A)
	ldx     #>(L0E6A)
;
; else if(needsEscaping(string, query->params)) {
;
	jmp     L1675
L0E67:	ldy     #$05
	jsr     pushwysp
	ldy     #$17
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	jsr     _needsEscaping
	stx     tmp1
	ora     tmp1
	beq     L0E6E
;
; string2 = strReplace("\"","\"\"", string);
;
	lda     #<(L0E74)
	ldx     #>(L0E74)
	jsr     pushax
	lda     #<(L0E76)
	ldx     #>(L0E76)
	jsr     pushax
	ldy     #$07
	jsr     ldaxysp
	jsr     _strReplace
	jsr     stax0sp
;
; fputs("\"", outputFile);
;
	lda     #<(L0E7A)
	ldx     #>(L0E7A)
	jsr     pushax
	ldy     #$09
	jsr     ldaxysp
	jsr     _fputs
;
; fputs(string2, outputFile);
;
	jsr     pushw0sp
	ldy     #$09
	jsr     ldaxysp
	jsr     _fputs
;
; fputs("\"", outputFile);
;
	lda     #<(L0E81)
	ldx     #>(L0E81)
	jsr     pushax
	ldy     #$09
	jsr     ldaxysp
	jsr     _fputs
;
; freeAndZero(string2);
;
	jsr     ldax0sp
	jsr     _free
	ldx     #$00
	txa
	jsr     stax0sp
;
; else {
;
	jmp     L0E55
;
; fputs(string, outputFile);
;
L0E6E:	ldy     #$03
	jsr     ldaxysp
L1675:	jsr     pushax
	ldy     #$09
	jsr     ldaxysp
	jsr     _fputs
;
; j++;
;
L0E55:	ldy     #$09
	jsr     ldaxysp
	jsr     incax1
	ldy     #$08
	jsr     staxysp
;
; ) {
;
	ldy     #$0F
	jsr     ldaxysp
	ldy     #$17
	jmp     L1674
;
; freeAndZero(string);
;
L0E3B:	ldy     #$03
	jsr     ldaxysp
	jsr     _free
	ldx     #$00
	txa
	ldy     #$02
	jsr     staxysp
;
; cleanup_matchValues(query, &columns);
;
	ldy     #$17
	jsr     pushwysp
	lda     #$14
	jsr     leaa0sp
	jsr     _cleanup_matchValues
;
; fputs(query->newLine, outputFile);
;
	ldy     #$15
	jsr     ldaxysp
	ldy     #$13
	jsr     pushwidx
	ldy     #$09
	jsr     ldaxysp
	jsr     _fputs
;
; }
;
	ldy     #$16
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; int __near__ recordCompare (__near__ const void *, __near__ const void *, __near__ void *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_recordCompare: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; matchParams.params = ((struct qryData*)c)->params;
;
	ldy     #$10
	jsr     subysp
	ldy     #$11
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	jsr     stax0sp
;
; orderByClause = ((struct qryData*)c)->useGroupBy?
;
	ldy     #$11
	jsr     ldaxysp
;
; ((struct qryData*)c)->groupByClause:
;
	ldy     #$0C
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	iny
	ora     (ptr1),y
	beq     L0EA2
	ldy     #$11
	jsr     ldaxysp
	ldy     #$23
;
; ((struct qryData*)c)->orderByClause;
;
	jmp     L1676
L0EA2:	ldy     #$11
	jsr     ldaxysp
	ldy     #$21
L1676:	jsr     ldaxidx
	ldy     #$0E
	jsr     staxysp
;
; orderByClause != NULL;
;
	ldy     #$0E
	lda     (sp),y
	iny
	ora     (sp),y
	jeq     L0E9C
;
; matchParams.ptr = (struct resultColumnValue*)a;
;
	ldy     #$15
	jsr     ldaxysp
	ldy     #$02
	jsr     staxysp
;
; orderByClause->expressionPtr,
;
	ldy     #$0F
	jsr     ldaxysp
	jsr     pushw
;
; );
;
	lda     #$02
	jsr     leaa0sp
	jsr     _getValue
;
; string1 = output1 = orderByClause->expressionPtr->value;
;
	ldy     #$0F
	jsr     ldaxysp
	jsr     ldaxi
	ldy     #$0D
	jsr     ldaxidx
	ldy     #$08
	jsr     staxysp
	ldy     #$0C
	jsr     staxysp
;
; orderByClause->expressionPtr->value = NULL;
;
	ldy     #$0F
	jsr     ldaxysp
	jsr     ldaxi
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$0C
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; matchParams.ptr = (struct resultColumnValue*)b;
;
	ldy     #$13
	jsr     ldaxysp
	ldy     #$02
	jsr     staxysp
;
; orderByClause->expressionPtr,
;
	ldy     #$0F
	jsr     ldaxysp
	jsr     pushw
;
; );
;
	lda     #$02
	jsr     leaa0sp
	jsr     _getValue
;
; string2 = output2 = orderByClause->expressionPtr->value;
;
	ldy     #$0F
	jsr     ldaxysp
	jsr     ldaxi
	ldy     #$0D
	jsr     ldaxidx
	ldy     #$06
	jsr     staxysp
	ldy     #$0A
	jsr     staxysp
;
; orderByClause->expressionPtr->value = NULL;
;
	ldy     #$0F
	jsr     ldaxysp
	jsr     ldaxi
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$0C
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; (unsigned char **)(&output1),
;
	lda     #$08
	jsr     leaa0sp
	jsr     pushax
;
; (unsigned char **)(&output2),
;
	lda     #$08
	jsr     leaa0sp
	jsr     pushax
;
; 2,    /* orderByClause->expressionPtr->caseSensitive, */
;
	lda     #$02
	jsr     pusha0
;
; (void (*)())getUnicodeChar,
;
	lda     #<(_getUnicodeChar)
	ldx     #>(_getUnicodeChar)
	jsr     pushax
;
; );
;
	lda     #<(_getUnicodeChar)
	ldx     #>(_getUnicodeChar)
	jsr     _strCompare
	ldy     #$04
	jsr     staxysp
;
; freeAndZero(output1);
;
	ldy     #$09
	jsr     ldaxysp
	jsr     _free
	ldx     #$00
	txa
	ldy     #$08
	jsr     staxysp
;
; freeAndZero(output2);
;
	ldy     #$07
	jsr     ldaxysp
	jsr     _free
	ldx     #$00
	txa
	ldy     #$06
	jsr     staxysp
;
; if(compare != 0) {
;
	ldy     #$04
	lda     (sp),y
	iny
	ora     (sp),y
	beq     L0E9D
;
; return orderByClause->isDescending?compare:-compare;
;
	ldy     #$0F
	jsr     ldaxysp
	ldy     #$02
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	iny
	ora     (ptr1),y
	beq     L0ED5
	ldy     #$05
	jsr     ldaxysp
	jmp     L0E97
L0ED5:	ldy     #$05
	jsr     ldaxysp
	jsr     negax
	jmp     L0E97
;
; ) {
;
L0E9D:	ldy     #$0F
	jsr     ldaxysp
	ldy     #$05
	jmp     L1676
;
; return 0;
;
L0E9C:	tax
;
; }
;
L0E97:	ldy     #$16
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; __near__ struct expression * __near__ parse_scalarExpLiteral (__near__ struct qryData *, __near__ unsigned char *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_parse_scalarExpLiteral: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; struct expression *expressionPtr = NULL;
;
	jsr     push0
;
; if(queryData->parseMode != 1) {
;
	ldy     #$05
	jsr     ldaxysp
	jsr     ldaxi
	cpx     #$00
	bne     L1679
	cmp     #$01
	beq     L0EDC
;
; return NULL;
;
L1679:	ldx     #$00
	txa
	jmp     L0EDA
;
; reallocMsg((void**)(&expressionPtr), sizeof(struct expression));
;
L0EDC:	lda     sp
	ldx     sp+1
	jsr     pushax
	ldx     #$00
	lda     #$12
	jsr     _reallocMsg
;
; expressionPtr->type = EXP_LITERAL;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	lda     #$02
	ldy     #$00
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; expressionPtr->value = NULL;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$0C
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; expressionPtr->unionPtrs.voidPtr = strdup(literal);
;
	jsr     pushw0sp
	ldy     #$05
	jsr     ldaxysp
	jsr     _strdup
	ldy     #$0E
	jsr     staxspidx
;
; expressionPtr->minColumn = 0;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$04
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; expressionPtr->minTable = 0;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$02
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; expressionPtr->containsAggregates = FALSE;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$06
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; return expressionPtr;
;
	jsr     ldax0sp
;
; }
;
L0EDA:	jsr     incsp6
	jmp     farret

.endproc

; ---------------------------------------------------------------
; int __near__ strAppendUTF8 (long, __near__ __near__ unsigned char * *, int)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_strAppendUTF8: near

.segment	"CODE"

;
; int strAppendUTF8(long codepoint, unsigned char **nfdString, int nfdLength) {
;
	jsr     pushax
;
; if (codepoint < 0x80) {
;
	ldy     #$07
	jsr     ldeaxysp
	jsr     pusheax
	ldx     #$00
	stx     sreg
	stx     sreg+1
	lda     #$80
	jsr     toslteax
	beq     L0EF3
;
; reallocMsg((void**)nfdString, nfdLength+1);
;
	ldy     #$05
	jsr     pushwysp
	ldy     #$03
	jsr     ldaxysp
	jsr     incax1
	jsr     _reallocMsg
;
; (*nfdString)[nfdLength++] = codepoint;
;
	ldy     #$03
	jsr     ldaxysp
	jsr     pushw
	ldy     #$03
	jsr     ldaxysp
	sta     regsave
	stx     regsave+1
	jsr     incax1
	ldy     #$02
	jsr     staxysp
	lda     regsave
	ldx     regsave+1
	jsr     tosaddax
	sta     ptr1
	stx     ptr1+1
	ldy     #$04
	lda     (sp),y
	ldy     #$00
	sta     (ptr1),y
;
; else if (codepoint < 0x800) {
;
	jmp     L0F23
L0EF3:	ldy     #$07
	jsr     ldeaxysp
	jsr     pusheax
	ldx     #$08
	lda     #$00
	sta     sreg
	sta     sreg+1
	jsr     toslteax
	beq     L0EFD
;
; reallocMsg((void**)nfdString, nfdLength+2);
;
	ldy     #$05
	jsr     pushwysp
	ldy     #$03
	jsr     ldaxysp
	jsr     incax2
	jsr     _reallocMsg
;
; (*nfdString)[nfdLength++] = (codepoint >> 6) + 0xC0;
;
	ldy     #$03
	jsr     ldaxysp
	jsr     pushw
	ldy     #$03
	jsr     ldaxysp
	sta     regsave
	stx     regsave+1
	jsr     incax1
	ldy     #$02
	jsr     staxysp
	lda     regsave
	ldx     regsave+1
	jsr     tosaddax
	jsr     pushax
	ldy     #$09
	jsr     ldeaxysp
	jsr     asreax4
	jsr     asreax2
	ldy     #$C0
;
; else if (codepoint < 0x10000) {
;
	jmp     L1696
L0EFD:	ldy     #$07
	jsr     ldeaxysp
	jsr     pusheax
	ldx     #$00
	stx     sreg+1
	lda     #$01
	sta     sreg
	txa
	jsr     toslteax
	beq     L0F0D
;
; reallocMsg((void**)nfdString, nfdLength+3);
;
	ldy     #$05
	jsr     pushwysp
	ldy     #$03
	jsr     ldaxysp
	jsr     incax3
	jsr     _reallocMsg
;
; (*nfdString)[nfdLength++] = (codepoint >> 12) + 0xE0;
;
	ldy     #$03
	jsr     ldaxysp
	jsr     pushw
	ldy     #$03
	jsr     ldaxysp
	sta     regsave
	stx     regsave+1
	jsr     incax1
	ldy     #$02
	jsr     staxysp
	lda     regsave
	ldx     regsave+1
	jsr     tosaddax
	jsr     pushax
	ldy     #$09
	jsr     ldeaxysp
	txa
	ldx     sreg
	ldy     sreg+1
	sty     sreg
	cpy     #$80
	ldy     #$00
	bcc     L0F17
	dey
L0F17:	sty     sreg+1
	jsr     asreax4
	ldy     #$E0
;
; else {
;
	jmp     L16B2
;
; reallocMsg((void**)nfdString, nfdLength+4);
;
L0F0D:	ldy     #$05
	jsr     pushwysp
	ldy     #$03
	jsr     ldaxysp
	jsr     incax4
	jsr     _reallocMsg
;
; (*nfdString)[nfdLength++] = (codepoint >> 18) + 0xF0;
;
	ldy     #$03
	jsr     ldaxysp
	jsr     pushw
	ldy     #$03
	jsr     ldaxysp
	sta     regsave
	stx     regsave+1
	jsr     incax1
	ldy     #$02
	jsr     staxysp
	lda     regsave
	ldx     regsave+1
	jsr     tosaddax
	jsr     pushax
	ldy     #$09
	jsr     ldeaxysp
	ldy     #$00
	ldx     sreg+1
	bpl     L0F2C
	dey
L0F2C:	lda     sreg
	sty     sreg+1
	sty     sreg
	jsr     asreax2
	ldy     #$F0
	jsr     inceaxy
	ldy     #$00
	jsr     staspidx
;
; (*nfdString)[nfdLength++] = ((codepoint >> 12) & 0x3F) + 0x80;
;
	ldy     #$03
	jsr     ldaxysp
	jsr     pushw
	ldy     #$03
	jsr     ldaxysp
	sta     regsave
	stx     regsave+1
	jsr     incax1
	ldy     #$02
	jsr     staxysp
	lda     regsave
	ldx     regsave+1
	jsr     tosaddax
	jsr     pushax
	ldy     #$09
	jsr     ldeaxysp
	txa
	ldx     sreg
	ldy     sreg+1
	sty     sreg
	cpy     #$80
	ldy     #$00
	bcc     L0F33
	dey
L0F33:	sty     sreg+1
	jsr     asreax4
	ldx     #$00
	stx     sreg+1
	stx     sreg
	and     #$3F
	ldy     #$80
L16B2:	jsr     inceaxy
	ldy     #$00
	jsr     staspidx
;
; (*nfdString)[nfdLength++] = ((codepoint >> 6) & 0x3F) + 0x80;
;
	ldy     #$03
	jsr     ldaxysp
	jsr     pushw
	ldy     #$03
	jsr     ldaxysp
	sta     regsave
	stx     regsave+1
	jsr     incax1
	ldy     #$02
	jsr     staxysp
	lda     regsave
	ldx     regsave+1
	jsr     tosaddax
	jsr     pushax
	ldy     #$09
	jsr     ldeaxysp
	jsr     asreax4
	jsr     asreax2
	ldx     #$00
	stx     sreg+1
	stx     sreg
	and     #$3F
	ldy     #$80
L1696:	jsr     inceaxy
	ldy     #$00
	jsr     staspidx
;
; (*nfdString)[nfdLength++] = (codepoint & 0x3F) + 0x80;
;
	ldy     #$03
	jsr     ldaxysp
	jsr     pushw
	ldy     #$03
	jsr     ldaxysp
	sta     regsave
	stx     regsave+1
	jsr     incax1
	ldy     #$02
	jsr     staxysp
	lda     regsave
	ldx     regsave+1
	jsr     tosaddax
	jsr     pushax
	ldy     #$09
	jsr     ldeaxysp
	ldx     #$00
	stx     sreg+1
	stx     sreg
	and     #$3F
	ldy     #$80
	jsr     inceaxy
	ldy     #$00
	jsr     staspidx
;
; return nfdLength;
;
L0F23:	jsr     ldax0sp
;
; }
;
	jsr     incsp8
	jmp     farret

.endproc

; ---------------------------------------------------------------
; int __near__ getCurrentDate (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_getCurrentDate: near

.segment	"CODE"

;
; char *output = NULL;
;
	ldy     #$16
	jsr     subysp
	jsr     push0
;
; time(&now);
;
	lda     #$14
	jsr     leaa0sp
	jsr     _time
;
; if(d_tztime(&now, &local, NULL, &output) == FALSE) {
;
	lda     #$14
	jsr     leaa0sp
	jsr     pushax
	lda     #$04
	jsr     leaa0sp
	jsr     pushax
	jsr     push0
	lda     #$06
	jsr     leaa0sp
	jsr     _d_tztime
	cpx     #$00
	bne     L0F44
	cmp     #$00
	bne     L0F44
;
; fputs(TDB_TZTIMED_FAILED, stderr);
;
	lda     #<(L0F4C)
	ldx     #>(L0F4C)
	jsr     pushax
	lda     _stderr
	ldx     _stderr+1
	jsr     _fputs
;
; freeAndZero(output);
;
	jsr     ldax0sp
	jsr     _free
	ldx     #$00
	txa
	jsr     stax0sp
;
; return -1;
;
	dex
	txa
	jmp     L0F40
;
; if(d_sprintf(&output, "%%Y-%%m-%%dT%%H:%%M:%%S%s", output) == FALSE) {
;
L0F44:	lda     sp
	ldx     sp+1
	jsr     pushax
	lda     #<(L0F57)
	ldx     #>(L0F57)
	jsr     pushax
	ldy     #$07
	jsr     pushwysp
	ldy     #$06
	jsr     _d_sprintf
	cpx     #$00
	bne     L0F54
	cmp     #$00
	bne     L0F54
;
; fputs(TDB_SPRINTFD_FAILED, stderr);
;
	lda     #<(L0F5C)
	ldx     #>(L0F5C)
	jsr     pushax
	lda     _stderr
	ldx     _stderr+1
	jsr     _fputs
;
; freeAndZero(output);
;
	jsr     ldax0sp
	jsr     _free
	ldx     #$00
	txa
	jsr     stax0sp
;
; return -1;
;
	dex
	txa
	jmp     L0F40
;
; if(d_strftime(&output, output, &local) == FALSE) {
;
L0F54:	lda     sp
	ldx     sp+1
	jsr     pushax
	ldy     #$05
	jsr     pushwysp
	lda     #$06
	jsr     leaa0sp
	jsr     _d_strftime
	cpx     #$00
	bne     L0F64
	cmp     #$00
	bne     L0F64
;
; fputs(TDB_STRFTIMED_FAILED, stderr);
;
	lda     #<(L0F6B)
	ldx     #>(L0F6B)
	jsr     pushax
	lda     _stderr
	ldx     _stderr+1
	jsr     _fputs
;
; freeAndZero(output);
;
	jsr     ldax0sp
	jsr     _free
	ldx     #$00
	txa
	jsr     stax0sp
;
; return -1;
;
	dex
	txa
	jmp     L0F40
;
; fputs(output, stdout);
;
L0F64:	jsr     pushw0sp
	lda     _stdout
	ldx     _stdout+1
	jsr     _fputs
;
; freeAndZero(output);
;
	jsr     ldax0sp
	jsr     _free
	ldx     #$00
	txa
	jsr     stax0sp
;
; }
;
L0F40:	ldy     #$18
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; int __near__ needsEscaping (__near__ unsigned char *, int)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_needsEscaping: near

.segment	"CODE"

;
; int needsEscaping(char *str, int params) {
;
	jsr     pushax
;
; str == NULL ||
;
	ldy     #$02
	lda     (sp),y
	iny
	ora     (sp),y
	jeq     L16B5
;
; strcmp(str, (((params & PRM_EXPORT) == 0)?"\\N":"\\N")) == 0 ||
;
	ldy     #$05
	jsr     pushwysp
	ldy     #$02
	lda     (sp),y
	and     #$08
	bne     L0F86
	lda     #<(L0F85)
	ldx     #>(L0F85)
	jmp     L0F89
L0F86:	lda     #<(L0F88)
	ldx     #>(L0F88)
L0F89:	jsr     _strcmp
	cpx     #$00
	bne     L16B7
	cmp     #$00
	jeq     L16B9
;
; *str == ' ' ||
;
L16B7:	ldy     #$03
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$20
	jeq     L16B5
;
; *str == '\t') {
;
	ldy     #$03
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$09
	bne     L0F90
;
; return TRUE;
;
	jmp     L16B5
;
; if(*str == '"' || *str == '\n' || *str == ',') {
;
L0F8E:	ldy     #$03
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$22
	beq     L16B5
	ldy     #$03
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$0D
	beq     L16B5
	ldy     #$03
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$2C
;
; return TRUE;
;
	beq     L16B5
;
; str++;
;
	ldy     #$03
	jsr     ldaxysp
	jsr     incax1
	ldy     #$02
	jsr     staxysp
;
; while(*str) {
;
L0F90:	ldy     #$03
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	bne     L0F8E
;
; str--;
;
	ldy     #$03
	jsr     ldaxysp
	jsr     decax1
	ldy     #$02
	jsr     staxysp
;
; if(*str == ' ' || *str == '\t') {
;
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$20
	beq     L16B5
	ldy     #$03
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$09
	beq     L16B5
	ldx     #$00
	txa
	jmp     L0F7B
;
; return TRUE;
;
L16B5:	ldx     #$00
L16B9:	lda     #$01
;
; }
;
L0F7B:	jsr     incsp4
	jmp     farret

.endproc

; ---------------------------------------------------------------
; void __near__ updateRunningCounts (__near__ struct qryData *, __near__ struct resultColumnValue *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_updateRunningCounts: near

.segment	"CODE"

;
; void updateRunningCounts(struct qryData *query, struct resultColumnValue *match) {
;
	jsr     pushax
;
; char *tempString = NULL;
;
	jsr     decsp8
	jsr     push0
;
; char *tempString2 = NULL;
;
	jsr     push0
;
; query->groupCount++;
;
	jsr     decsp8
	ldy     #$17
	jsr     ldaxysp
	jsr     pushax
	ldy     #$0B
	jsr     ldaxidx
	jsr     incax1
	ldy     #$0A
	jsr     staxspidx
;
; for(i = 0; i < query->columnReferenceHashTable->size; i++) {
;
	ldx     #$00
	txa
L16CE:	ldy     #$02
	jsr     staxysp
	jsr     pushax
	ldy     #$19
	jsr     ldaxysp
	ldy     #$17
	jsr     ldaxidx
	jsr     ldaxi
	jsr     tosicmp
	jpl     L0FA2
;
; currentHashEntry = query->columnReferenceHashTable->table[i];
;
	ldy     #$17
	jsr     ldaxysp
	ldy     #$17
	jsr     ldaxidx
	ldy     #$03
	jsr     ldaxidx
	sta     ptr1
	stx     ptr1+1
	ldy     #$03
	jsr     ldaxysp
	jsr     aslax1
	clc
	adc     ptr1
	pha
	txa
	adc     ptr1+1
	tax
	pla
	ldy     #$01
;
; while(currentHashEntry != NULL) {
;
	jmp     L16CB
;
; currentReference = currentHashEntry->content;
;
L16C0:	jsr     ldaxysp
	ldy     #$03
;
; while(currentReference != NULL) {
;
	jmp     L16CC
;
; currentReference->referenceType == REF_EXPRESSION &&
;
L16C1:	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	cpx     #$00
	jne     L0FC5
	cmp     #$02
	jne     L0FC5
;
; (currentResultColumn = currentReference->reference.calculatedPtr.firstResultColumn) != NULL &&
;
	ldy     #$11
	jsr     ldaxysp
	ldy     #$07
	jsr     ldaxidx
	ldy     #$0E
	jsr     staxysp
	cpx     #$00
	bne     L16C2
	cmp     #$00
	jeq     L0FC5
;
; currentResultColumn->groupType != GRP_NONE
;
L16C2:	ldy     #$0F
	jsr     ldaxysp
	ldy     #$07
	jsr     ldaxidx
;
; ) {
;
	cpx     #$00
	bne     L0FB9
	cmp     #$00
	jeq     L0FC5
;
; field = &(match[currentResultColumn->resultColumnIndex]);
;
L0FB9:	ldy     #$17
	jsr     pushwysp
	ldy     #$11
	jsr     ldaxysp
	jsr     pushw
	lda     #$0E
	jsr     tosmula0
	jsr     tosaddax
	ldy     #$0C
	jsr     staxysp
;
; if(field->leftNull == FALSE) {
;
	ldy     #$09
	jsr     ldaxidx
	cpx     #$00
	jne     L0FC5
	cmp     #$00
	jne     L0FC5
;
; stringGet((unsigned char **)(&tempString), field, query->params);
;
	lda     #$0A
	jsr     leaa0sp
	jsr     pushax
	ldy     #$11
	jsr     pushwysp
	ldy     #$1B
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	jsr     _stringGet
;
; if(currentResultColumn->groupType > GRP_STAR) {
;
	ldy     #$0F
	jsr     ldaxysp
	ldy     #$07
	jsr     ldaxidx
	cmp     #$08
	txa
	sbc     #$00
	bvs     L0FCF
	eor     #$80
L0FCF:	jpl     L0FF6
;
; if(query->groupCount > 1) {
;
	ldy     #$17
	jsr     ldaxysp
	ldy     #$0B
	jsr     ldaxidx
	cmp     #$02
	txa
	sbc     #$00
	bvs     L0FD2
	eor     #$80
L0FD2:	jpl     L0FD0
;
; for(j = 1; j < query->groupCount; j++) {
;
	ldx     #$00
	lda     #$01
L16CD:	jsr     stax0sp
	jsr     pushax
	ldy     #$19
	jsr     ldaxysp
	ldy     #$0B
	jsr     ldaxidx
	jsr     tosicmp
	jpl     L0FF6
;
; stringGet((unsigned char **)(&tempString2), &(match[(currentResultColumn->resultColumnIndex) - (query->columnCount)]), query->params);
;
	lda     #$08
	jsr     leaa0sp
	jsr     pushax
	ldy     #$19
	jsr     pushwysp
	ldy     #$13
	jsr     ldaxysp
	jsr     pushw
	ldy     #$1D
	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	jsr     tossubax
	jsr     pushax
	lda     #$0E
	jsr     tosmula0
	jsr     tosaddax
	jsr     pushax
	ldy     #$1B
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	jsr     _stringGet
;
; (unsigned char **)(&tempString),
;
	lda     #$0A
	jsr     leaa0sp
	jsr     pushax
;
; (unsigned char **)(&tempString2),
;
	lda     #$0A
	jsr     leaa0sp
	jsr     pushax
;
; TRUE,
;
	lda     #$01
	jsr     pusha0
;
; (void (*)())getUnicodeChar,
;
	lda     #<(_getUnicodeChar)
	ldx     #>(_getUnicodeChar)
	jsr     pushax
;
; ) == 0) {
;
	lda     #<(_getUnicodeChar)
	ldx     #>(_getUnicodeChar)
	jsr     _strCompare
	cpx     #$00
	bne     L0FE4
	cmp     #$00
	bne     L0FE4
;
; freeAndZero(tempString2);
;
	ldy     #$09
	jsr     ldaxysp
	jsr     _free
	ldx     #$00
	txa
	ldy     #$08
;
; break;
;
	jmp     L16BF
;
; freeAndZero(tempString2);
;
L0FE4:	ldy     #$09
	jsr     ldaxysp
	jsr     _free
	ldx     #$00
	txa
	ldy     #$08
	jsr     staxysp
;
; for(j = 1; j < query->groupCount; j++) {
;
	jsr     ldax0sp
	jsr     incax1
	jmp     L16CD
;
; j = query->groupCount;
;
L0FD0:	ldy     #$17
	jsr     ldaxysp
	ldy     #$0B
	jsr     ldaxidx
	ldy     #$00
L16BF:	jsr     staxysp
;
; switch(currentResultColumn->groupType) {
;
L0FF6:	ldy     #$0F
	jsr     ldaxysp
	ldy     #$07
	jsr     ldaxidx
;
; }
;
	cpx     #$00
	jne     L0FFB
	cmp     #$01
	jeq     L1016
	cmp     #$02
	jeq     L1039
	cmp     #$03
	jeq     L1052
	cmp     #$04
	jeq     L1016
	cmp     #$05
	beq     L1002
	cmp     #$06
	jeq     L1030
	cmp     #$08
	beq     L1005
	cmp     #$09
	jeq     L1039
	cmp     #$0A
	jeq     L1052
	cmp     #$0B
	beq     L1005
	cmp     #$0C
	beq     L0FFD
	cmp     #$0D
	jeq     L1025
	jmp     L0FFB
;
; if(j == query->groupCount) {
;
L0FFD:	jsr     ldax0sp
	sta     sreg
	stx     sreg+1
	ldy     #$17
	jsr     ldaxysp
	ldy     #$0B
	jsr     ldaxidx
	cpx     sreg+1
	jne     L0FFB
	cmp     sreg
	jne     L0FFB
;
; currentResultColumn->groupCount++;
;
	ldy     #$0F
	jsr     ldaxysp
	jsr     pushax
	ldy     #$0F
	jsr     ldaxidx
	jsr     incax1
	ldy     #$0E
	jsr     staxspidx
;
; break;
;
	jmp     L0FFB
;
; currentResultColumn->groupCount++;
;
L1002:	ldy     #$0F
	jsr     ldaxysp
	jsr     pushax
	ldy     #$0F
	jsr     ldaxidx
	jsr     incax1
	ldy     #$0E
	jsr     staxspidx
;
; break;
;
	jmp     L0FFB
;
; if(j == query->groupCount) {
;
L1005:	jsr     ldax0sp
	sta     sreg
	stx     sreg+1
	ldy     #$17
	jsr     ldaxysp
	ldy     #$0B
	jsr     ldaxidx
	cpx     sreg+1
	jne     L0FFB
	cmp     sreg
	jne     L0FFB
;
; currentResultColumn->groupCount++;
;
	ldy     #$0F
	jsr     ldaxysp
	jsr     pushax
	ldy     #$0F
	jsr     ldaxidx
	jsr     incax1
	ldy     #$0E
	jsr     staxspidx
;
; tempFloat = strtod(tempString, NULL);
;
	dey
	jsr     pushwysp
	ldx     #$00
	txa
	jsr     _strtod
	ldy     #$04
	jsr     steaxysp
;
; currentResultColumn->groupNum = fadd(currentResultColumn->groupNum, tempFloat);
;
	ldy     #$11
	jsr     pushwysp
	ldy     #$11
	jsr     ldaxysp
	ldy     #$0D
	jsr     ldeaxidx
	jsr     pusheax
	ldy     #$0D
	jsr     ldeaxysp
	jsr     __fadd
	ldy     #$0A
	jsr     steaxspidx
;
; break;
;
	jmp     L0FFB
;
; currentResultColumn->groupCount++;
;
L1016:	ldy     #$0F
	jsr     ldaxysp
	jsr     pushax
	ldy     #$0F
	jsr     ldaxidx
	jsr     incax1
	ldy     #$0E
	jsr     staxspidx
;
; tempFloat = strtod(tempString, NULL);
;
	dey
	jsr     pushwysp
	ldx     #$00
	txa
	jsr     _strtod
	ldy     #$04
	jsr     steaxysp
;
; currentResultColumn->groupNum = fadd(currentResultColumn->groupNum, tempFloat);
;
	ldy     #$11
	jsr     pushwysp
	ldy     #$11
	jsr     ldaxysp
	ldy     #$0D
	jsr     ldeaxidx
	jsr     pusheax
	ldy     #$0D
	jsr     ldeaxysp
	jsr     __fadd
	ldy     #$0A
	jsr     steaxspidx
;
; break;
;
	jmp     L0FFB
;
; if(j == query->groupCount) {
;
L1025:	jsr     ldax0sp
	sta     sreg
	stx     sreg+1
	ldy     #$17
	jsr     ldaxysp
	ldy     #$0B
	jsr     ldaxidx
	cpx     sreg+1
	jne     L0FFB
	cmp     sreg
	jne     L0FFB
;
; &(currentResultColumn->groupText),
;
	ldy     #$0F
	jsr     ldaxysp
	jsr     incax8
	jsr     pushax
;
; "%s%s",
;
	lda     #<(L102B)
	ldx     #>(L102B)
	jsr     pushax
;
; currentResultColumn->groupText,
;
	ldy     #$13
	jsr     ldaxysp
	ldy     #$09
	jsr     pushwidx
;
; );
;
	ldy     #$13
	jsr     pushwysp
	ldy     #$08
	jsr     _d_sprintf
;
; break;
;
	jmp     L0FFB
;
; &(currentResultColumn->groupText),
;
L1030:	ldy     #$0F
	jsr     ldaxysp
	jsr     incax8
	jsr     pushax
;
; "%s%s",
;
	lda     #<(L1034)
	ldx     #>(L1034)
	jsr     pushax
;
; currentResultColumn->groupText,
;
	ldy     #$13
	jsr     ldaxysp
	ldy     #$09
	jsr     pushwidx
;
; );
;
	ldy     #$13
	jsr     pushwysp
	ldy     #$08
	jsr     _d_sprintf
;
; break;
;
	jmp     L0FFB
;
; if(currentResultColumn->groupText == NULL || strCompare(
;
L1039:	ldy     #$0F
	jsr     ldaxysp
	ldy     #$09
	jsr     ldaxidx
	cpx     #$00
	bne     L16C3
	cmp     #$00
	beq     L103D
;
; (unsigned char **)(&tempString),
;
L16C3:	lda     #$0A
	jsr     leaa0sp
	jsr     pushax
;
; (unsigned char **)(&(currentResultColumn->groupText)),
;
	ldy     #$11
	jsr     ldaxysp
	jsr     incax8
	jsr     pushax
;
; 2,    /* TRUE, */
;
	lda     #$02
	jsr     pusha0
;
; (void (*)())getUnicodeChar,
;
	lda     #<(_getUnicodeChar)
	ldx     #>(_getUnicodeChar)
	jsr     pushax
;
; ) == -1) {
;
	lda     #<(_getUnicodeChar)
	ldx     #>(_getUnicodeChar)
	jsr     _strCompare
	cpx     #$FF
	jne     L0FFB
	cmp     #$FF
	jne     L0FFB
;
; free(currentResultColumn->groupText);
;
L103D:	ldy     #$0F
	jsr     ldaxysp
	ldy     #$09
	jsr     ldaxidx
	jsr     _free
;
; currentResultColumn->groupText = tempString;
;
	ldy     #$0F
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$0B
	jsr     ldaxysp
	ldy     #$08
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; continue;
;
	jmp     L16D4
;
; if(currentResultColumn->groupText == NULL || strCompare(
;
L1052:	ldy     #$0F
	jsr     ldaxysp
	ldy     #$09
	jsr     ldaxidx
	cpx     #$00
	bne     L16C5
	cmp     #$00
	beq     L1056
;
; (unsigned char **)(&tempString),
;
L16C5:	lda     #$0A
	jsr     leaa0sp
	jsr     pushax
;
; (unsigned char **)(&(currentResultColumn->groupText)),
;
	ldy     #$11
	jsr     ldaxysp
	jsr     incax8
	jsr     pushax
;
; 2,    /* TRUE, */
;
	lda     #$02
	jsr     pusha0
;
; (void (*)())getUnicodeChar,
;
	lda     #<(_getUnicodeChar)
	ldx     #>(_getUnicodeChar)
	jsr     pushax
;
; ) == 1) {
;
	lda     #<(_getUnicodeChar)
	ldx     #>(_getUnicodeChar)
	jsr     _strCompare
	cpx     #$00
	bne     L0FFB
	cmp     #$01
	bne     L0FFB
;
; free(currentResultColumn->groupText);
;
L1056:	ldy     #$0F
	jsr     ldaxysp
	ldy     #$09
	jsr     ldaxidx
	jsr     _free
;
; currentResultColumn->groupText = tempString;
;
	ldy     #$0F
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$0B
	jsr     ldaxysp
	ldy     #$08
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; continue;
;
	jmp     L16D4
;
; freeAndZero(tempString);
;
L0FFB:	ldy     #$0B
	jsr     ldaxysp
	jsr     _free
L16D4:	ldx     #$00
	txa
	ldy     #$0A
	jsr     staxysp
;
; currentReference = currentReference->nextReferenceWithName;
;
L0FC5:	ldy     #$11
	jsr     ldaxysp
	ldy     #$09
L16CC:	jsr     ldaxidx
	ldy     #$10
	jsr     staxysp
;
; while(currentReference != NULL) {
;
	ldy     #$10
	lda     (sp),y
	iny
	ora     (sp),y
	jne     L16C1
;
; currentHashEntry = currentHashEntry->nextReferenceInHash;
;
	ldy     #$13
	jsr     ldaxysp
	ldy     #$05
L16CB:	jsr     ldaxidx
	ldy     #$12
	jsr     staxysp
;
; while(currentHashEntry != NULL) {
;
	ldy     #$12
	lda     (sp),y
	iny
	ora     (sp),y
	jne     L16C0
;
; for(i = 0; i < query->columnReferenceHashTable->size; i++) {
;
	ldy     #$03
	jsr     ldaxysp
	jsr     incax1
	jmp     L16CE
;
; }
;
L0FA2:	ldy     #$18
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; int __near__ yyerror (__near__ struct qryData *, __near__ void *, __near__ const unsigned char *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_yyerror: near

.segment	"CODE"

;
; int yyerror(struct qryData *queryData, void *scanner, const char *msg) {
;
	jsr     pushax
;
; fputs(msg, stderr);
;
	jsr     pushw0sp
	lda     _stderr
	ldx     _stderr+1
	jsr     _fputs
;
; return 1;
;
	ldx     #$00
	lda     #$01
;
; }
;
	jsr     incsp6
	jmp     farret

.endproc

; ---------------------------------------------------------------
; void __near__ readQuery (__near__ unsigned char *, __near__ struct qryData *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_readQuery: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; FILE *queryFile = NULL;
;
	jsr     push0
;
; int inputTableIndex = 2, i;
;
	ldy     #$0C
	jsr     subysp
	lda     #$02
	jsr     pusha0
;
; queryFile = fopen(queryFileName, "r");
;
	jsr     decsp2
	ldy     #$17
	jsr     pushwysp
	lda     #<(L10E9)
	ldx     #>(L10E9)
	jsr     _fopen
	ldy     #$10
	jsr     staxysp
;
; if(queryFile == NULL) {
;
	cpx     #$00
	bne     L10EB
	cmp     #$00
	bne     L10EB
;
; fputs(TDB_COULDNT_OPEN_INPUT, stderr);
;
	lda     #<(L10EF)
	ldx     #>(L10EF)
	jsr     pushax
	lda     _stderr
	ldx     _stderr+1
	jsr     _fputs
;
; exit(EXIT_FAILURE);
;
	ldx     #$00
	lda     #$01
	jsr     _exit
;
; query->parseMode = 0;   /* specify we want to just read the file data for now */
;
L10EB:	ldy     #$13
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	tay
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; query->hasGrouping = FALSE;
;
	ldy     #$13
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$02
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; query->useGroupBy = FALSE;
;
	ldy     #$13
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$0C
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; query->columnCount = 0;
;
	ldy     #$13
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$04
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; query->hiddenColumnCount = 0;
;
	ldy     #$13
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$06
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; query->recordCount = 0;
;
	ldy     #$13
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$08
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; query->groupCount = 0;
;
	ldy     #$13
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$0A
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; query->params = 0;
;
	ldy     #$13
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$0E
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; query->intoFileName = NULL;
;
	ldy     #$13
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$10
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; query->columnReferenceHashTable = hash_createTable(32);
;
	ldy     #$15
	jsr     pushwysp
	ldx     #$00
	lda     #$20
	jsr     _hash_createTable
	ldy     #$16
	jsr     staxspidx
;
; query->firstInputTable = NULL;
;
	ldy     #$13
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$18
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; query->secondaryInputTable = NULL;
;
	ldy     #$13
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$1A
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; query->firstResultColumn = NULL;
;
	ldy     #$13
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$1C
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; query->joinsAndWhereClause = NULL;
;
	ldy     #$13
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$1E
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; query->orderByClause = NULL;
;
	ldy     #$13
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$20
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; query->groupByClause = NULL;
;
	ldy     #$13
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$22
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; query->resultSet = NULL;
;
	ldy     #$13
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$24
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; yylex_init(&scanner);
;
	lda     #$0E
	jsr     leaa0sp
	jsr     _yylex_init
;
; yyset_in(queryFile, scanner);
;
	ldy     #$13
	jsr     pushwysp
	ldy     #$11
	jsr     ldaxysp
	jsr     _yyset_in
;
; switch(yyparse(query, scanner)) {
;
	ldy     #$15
	jsr     pushwysp
	ldy     #$11
	jsr     ldaxysp
	jsr     _yyparse
;
; }
;
	cpx     #$00
	bne     L1133
	cmp     #$00
	beq     L1120
	cmp     #$01
	beq     L1124
	cmp     #$02
	beq     L112C
	jmp     L1133
;
; fputs(TDB_PARSER_SYNTAX, stderr);
;
L1124:	lda     #<(L1126)
	ldx     #>(L1126)
;
; break;
;
	jmp     L16ED
;
; fputs(TDB_PARSER_USED_ALL_RAM, stderr);
;
L112C:	lda     #<(L112E)
	ldx     #>(L112E)
;
; break;
;
	jmp     L16ED
;
; fputs(TDB_PARSER_UNKNOWN, stderr);
;
L1133:	lda     #<(L1135)
	ldx     #>(L1135)
L16ED:	jsr     pushax
	lda     _stderr
	ldx     _stderr+1
	jsr     _fputs
;
; exit(EXIT_FAILURE);
;
	ldx     #$00
	lda     #$01
	jsr     _exit
;
; query->newLine = query->intoFileName?"\r\n":"\n";
;
L1120:	ldy     #$13
	jsr     ldaxysp
	sta     sreg
	stx     sreg+1
	ldy     #$13
	jsr     ldaxysp
	ldy     #$10
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	iny
	ora     (ptr1),y
	beq     L113D
	lda     #<(L113C)
	ldx     #>(L113C)
	jmp     L1140
L113D:	lda     #<(L113F)
	ldx     #>(L113F)
L1140:	iny
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; query->firstInputTable = currentInputTable =
;
	ldy     #$15
	jsr     pushwysp
;
; (query->secondaryInputTable != NULL ?
;
	ldy     #$15
	jsr     ldaxysp
	ldy     #$1B
	jsr     ldaxidx
	cpx     #$00
	bne     L16DC
	cmp     #$00
;
; query->secondaryInputTable :
;
	beq     L1147
L16DC:	ldy     #$15
	jsr     ldaxysp
	ldy     #$1B
;
; query->firstInputTable)->nextInputTable;
;
	jmp     L16D7
L1147:	ldy     #$15
	jsr     ldaxysp
	ldy     #$19
L16D7:	jsr     ldaxidx
	ldy     #$11
	jsr     ldaxidx
	ldy     #$0E
	jsr     staxysp
	ldy     #$18
;
; while (currentInputTable->nextInputTable != query->firstInputTable) {
;
	jmp     L16D8
;
; currentInputTable = currentInputTable->nextInputTable;
;
L114B:	ldy     #$0D
	jsr     ldaxysp
	ldy     #$11
	jsr     ldaxidx
	ldy     #$0C
	jsr     staxysp
;
; currentInputTable->fileIndex = inputTableIndex++;
;
	jsr     pushax
	ldy     #$05
	jsr     ldaxysp
	sta     regsave
	stx     regsave+1
	jsr     incax1
	ldy     #$04
	jsr     staxysp
	lda     regsave
	ldx     regsave+1
	ldy     #$00
L16D8:	jsr     staxspidx
;
; while (currentInputTable->nextInputTable != query->firstInputTable) {
;
	ldy     #$0D
	jsr     ldaxysp
	ldy     #$11
	jsr     ldaxidx
	sta     sreg
	stx     sreg+1
	ldy     #$13
	jsr     ldaxysp
	ldy     #$19
	jsr     ldaxidx
	cpx     sreg+1
	bne     L114B
	cmp     sreg
	bne     L114B
;
; currentInputTable->nextInputTable = NULL;
;
	ldy     #$0D
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$10
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; query->secondaryInputTable = NULL;
;
	ldy     #$13
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$1A
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; for(i=0; i<query->columnReferenceHashTable->size; i++) {
;
	tax
L16E5:	jsr     stax0sp
	jsr     pushax
	ldy     #$15
	jsr     ldaxysp
	ldy     #$17
	jsr     ldaxidx
	jsr     ldaxi
	jsr     tosicmp
	jpl     L1158
;
; currentHashEntry = query->columnReferenceHashTable->table[i];
;
	ldy     #$13
	jsr     ldaxysp
	ldy     #$17
	jsr     ldaxidx
	ldy     #$03
	jsr     ldaxidx
	sta     ptr1
	stx     ptr1+1
	jsr     ldax0sp
	jsr     aslax1
	clc
	adc     ptr1
	pha
	txa
	adc     ptr1+1
	tax
	pla
	ldy     #$01
;
; while(currentHashEntry != NULL) {
;
	jmp     L16E4
;
; if(currentHashEntry->content->nextReferenceWithName) {
;
L16DB:	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	ldy     #$08
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	iny
	ora     (ptr1),y
	beq     L1167
;
; currentReferenceWithName = currentHashEntry->content->nextReferenceWithName->nextReferenceWithName;
;
	ldy     #$05
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	ldy     #$09
	jsr     ldaxidx
	ldy     #$09
	jsr     ldaxidx
	ldy     #$0A
	jsr     staxysp
;
; currentHashEntry->content->nextReferenceWithName->nextReferenceWithName = NULL;
;
	ldy     #$05
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	ldy     #$09
	jsr     ldaxidx
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$08
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; currentHashEntry->content->nextReferenceWithName = currentReferenceWithName;
;
	ldy     #$05
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	sta     ptr1
	stx     ptr1+1
	ldy     #$0B
	jsr     ldaxysp
	ldy     #$08
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; currentHashEntry = currentHashEntry->nextReferenceInHash;
;
L1167:	ldy     #$05
	jsr     ldaxysp
	ldy     #$05
L16E4:	jsr     ldaxidx
	ldy     #$04
	jsr     staxysp
;
; while(currentHashEntry != NULL) {
;
	ldy     #$04
	lda     (sp),y
	iny
	ora     (sp),y
	bne     L16DB
;
; for(i=0; i<query->columnReferenceHashTable->size; i++) {
;
	jsr     ldax0sp
	jsr     incax1
	jmp     L16E5
;
; yylex_destroy(scanner);
;
L1158:	ldy     #$0F
	jsr     ldaxysp
	jsr     _yylex_destroy
;
; query->parseMode = 1;
;
	ldy     #$13
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$01
	ldy     #$00
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; fclose(queryFile);
;
	ldy     #$11
	jsr     ldaxysp
	jsr     _fclose
;
; queryFile = fopen(queryFileName, "r");
;
	ldy     #$17
	jsr     pushwysp
	lda     #<(L117A)
	ldx     #>(L117A)
	jsr     _fopen
	ldy     #$10
	jsr     staxysp
;
; if(queryFile == NULL) {
;
	cpx     #$00
	bne     L117C
	cmp     #$00
	bne     L117C
;
; fputs(TDB_COULDNT_OPEN_INPUT, stderr);
;
	lda     #<(L1180)
	ldx     #>(L1180)
	jsr     pushax
	lda     _stderr
	ldx     _stderr+1
	jsr     _fputs
;
; exit(EXIT_FAILURE);
;
	ldx     #$00
	lda     #$01
	jsr     _exit
;
; yylex_init(&scanner);
;
L117C:	lda     #$0E
	jsr     leaa0sp
	jsr     _yylex_init
;
; yyset_in(queryFile, scanner);
;
	ldy     #$13
	jsr     pushwysp
	ldy     #$11
	jsr     ldaxysp
	jsr     _yyset_in
;
; switch(yyparse(query, scanner)) {
;
	ldy     #$15
	jsr     pushwysp
	ldy     #$11
	jsr     ldaxysp
	jsr     _yyparse
;
; }
;
	cpx     #$00
	bne     L11A1
	cmp     #$00
	beq     L118E
	cmp     #$01
	beq     L1192
	cmp     #$02
	beq     L119A
	jmp     L11A1
;
; fputs(TDB_PARSER_SYNTAX, stderr);
;
L1192:	lda     #<(L1194)
	ldx     #>(L1194)
;
; break;
;
	jmp     L16EE
;
; fputs(TDB_PARSER_USED_ALL_RAM, stderr);
;
L119A:	lda     #<(L119C)
	ldx     #>(L119C)
;
; break;
;
	jmp     L16EE
;
; fputs(TDB_PARSER_UNKNOWN, stderr);
;
L11A1:	lda     #<(L11A3)
	ldx     #>(L11A3)
L16EE:	jsr     pushax
	lda     _stderr
	ldx     _stderr+1
	jsr     _fputs
;
; exit(EXIT_FAILURE);
;
	ldx     #$00
	lda     #$01
	jsr     _exit
;
; currentResultColumn = query->firstResultColumn;
;
L118E:	ldy     #$13
	jsr     ldaxysp
	ldy     #$1D
	jsr     ldaxidx
	ldy     #$08
	jsr     staxysp
;
; query->columnCount = currentResultColumn->resultColumnIndex+1;
;
	ldy     #$13
	jsr     ldaxysp
	sta     sreg
	stx     sreg+1
	ldy     #$09
	jsr     ldaxysp
	jsr     ldaxi
	jsr     incax1
	ldy     #$04
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; query->firstResultColumn = query->firstResultColumn->nextColumnInResults;
;
	ldy     #$13
	jsr     ldaxysp
	sta     sreg
	stx     sreg+1
	ldy     #$13
	jsr     ldaxysp
	ldy     #$1D
	jsr     ldaxidx
	ldy     #$17
	jsr     ldaxidx
	ldy     #$1C
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; currentResultColumn->nextColumnInResults = NULL;
;
	ldy     #$09
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$16
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; if(query->orderByClause != NULL) {
;
	ldy     #$13
	jsr     ldaxysp
	ldy     #$21
	jsr     ldaxidx
	cpx     #$00
	bne     L16DD
	cmp     #$00
	beq     L11B0
;
; currentSortingList = query->orderByClause;
;
L16DD:	ldy     #$13
	jsr     ldaxysp
	ldy     #$21
	jsr     ldaxidx
	ldy     #$06
	jsr     staxysp
;
; query->orderByClause = query->orderByClause->nextInList;
;
	ldy     #$13
	jsr     ldaxysp
	sta     sreg
	stx     sreg+1
	ldy     #$13
	jsr     ldaxysp
	ldy     #$21
	jsr     ldaxidx
	ldy     #$05
	jsr     ldaxidx
	ldy     #$20
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; currentSortingList->nextInList = NULL;
;
	ldy     #$07
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$04
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; if(query->groupByClause != NULL) {
;
L11B0:	ldy     #$13
	jsr     ldaxysp
	ldy     #$23
	jsr     ldaxidx
	cpx     #$00
	bne     L16DE
	cmp     #$00
	beq     L11B9
;
; currentSortingList = query->groupByClause;
;
L16DE:	ldy     #$13
	jsr     ldaxysp
	ldy     #$23
	jsr     ldaxidx
	ldy     #$06
	jsr     staxysp
;
; query->groupByClause = query->groupByClause->nextInList;
;
	ldy     #$13
	jsr     ldaxysp
	sta     sreg
	stx     sreg+1
	ldy     #$13
	jsr     ldaxysp
	ldy     #$23
	jsr     ldaxidx
	ldy     #$05
	jsr     ldaxidx
	ldy     #$22
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; currentSortingList->nextInList = NULL;
;
	ldy     #$07
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$04
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; yylex_destroy(scanner);
;
L11B9:	ldy     #$0F
	jsr     ldaxysp
	jsr     _yylex_destroy
;
; fclose(queryFile);
;
	ldy     #$11
	jsr     ldaxysp
	jsr     _fclose
;
; }
;
	ldy     #$16
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; int __near__ tree_insert (__near__ struct qryData *, __near__ struct resultColumnValue *, __near__ __near__ struct resultTree * *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_tree_insert: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; if(root == NULL) {
;
	jsr     decsp6
	ldy     #$06
	lda     (sp),y
	iny
	ora     (sp),y
	bne     L11C7
;
; return FALSE;
;
	tax
	jmp     L11E6
;
; if((newResult = malloc(sizeof(struct resultTree))) == NULL) {
;
L11C7:	ldx     #$00
	lda     #$0A
	jsr     _malloc
	ldy     #$02
	jsr     staxysp
	cpx     #$00
	bne     L11CB
	cmp     #$00
;
; return FALSE;
;
	jeq     L11E6
;
; newResult->parent = NULL;
;
L11CB:	ldy     #$03
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$04
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; newResult->left = NULL;
;
	ldy     #$03
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	tay
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; newResult->right = NULL;
;
	ldy     #$03
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$02
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; newResult->columns = columns;
;
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$09
	jsr     ldaxysp
	ldy     #$06
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; newResult->type = TRE_BLACK;
;
	ldy     #$03
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$01
	ldy     #$08
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; if(*root == NULL) {
;
	ldy     #$07
	jsr     ldaxysp
	jsr     ldaxi
	cpx     #$00
	bne     L11DC
	cmp     #$00
	bne     L11DC
;
; *root = newResult;
;
	ldy     #$07
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$03
	jsr     ldaxysp
	ldy     #$00
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; return TRUE;
;
	ldx     #$00
	tya
	jmp     L11E6
;
; currentResult = *root;
;
L11DC:	ldy     #$07
L16F3:	jsr     ldaxysp
	ldy     #$01
L16F1:	jsr     ldaxidx
	ldy     #$04
	jsr     staxysp
;
; comparison = recordCompare(currentResult->columns, columns, query);
;
	ldy     #$07
	jsr     pushwidx
	ldy     #$0D
	jsr     pushwysp
	ldy     #$0F
	jsr     ldaxysp
	jsr     _recordCompare
	jsr     stax0sp
;
; if(comparison < 1) {
;
	cmp     #$01
	txa
	sbc     #$00
	bvc     L11F0
	eor     #$80
L11F0:	bpl     L11EE
;
; if(currentResult->left == NULL) {
;
	ldy     #$05
	jsr     ldaxysp
	jsr     ldaxi
	cpx     #$00
	bne     L11F1
	cmp     #$00
	bne     L11F1
;
; newResult->parent = currentResult;
;
	ldy     #$03
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$05
	jsr     ldaxysp
	ldy     #$04
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; currentResult->left = newResult;
;
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$03
	jsr     ldaxysp
	ldy     #$00
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; return TRUE;
;
	ldx     #$00
	tya
	jmp     L11E6
;
; currentResult = currentResult->left;
;
L11F1:	ldy     #$05
;
; else {
;
	jmp     L16F3
;
; if(currentResult->right == NULL) {
;
L11EE:	ldy     #$05
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	cpx     #$00
	bne     L11FD
	cmp     #$00
	bne     L11FD
;
; newResult->parent = currentResult;
;
	ldy     #$03
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$05
	jsr     ldaxysp
	ldy     #$04
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; currentResult->right = newResult;
;
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$03
	jsr     ldaxysp
	ldy     #$02
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; return TRUE;
;
	ldx     #$00
	lda     #$01
	jmp     L11E6
;
; currentResult = currentResult->right;
;
L11FD:	ldy     #$05
	jsr     ldaxysp
	ldy     #$03
;
; }
;
	jmp     L16F1
;
; }
;
L11E6:	ldy     #$0C
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; int __near__ d_tztime (__near__ unsigned long *, __near__ struct tm *, __near__ struct tm *, __near__ __near__ unsigned char * *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_d_tztime: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; char *format = "+%02i%02i";
;
	ldy     #$10
	jsr     subysp
	lda     #<(L1209)
	ldx     #>(L1209)
	jsr     pushax
;
; if(now == NULL) {
;
	ldy     #$18
	lda     (sp),y
	iny
	ora     (sp),y
	bne     L120B
;
; return FALSE;
;
	tax
	jmp     L1208
;
; if(local != NULL) {
;
L120B:	ldy     #$16
	lda     (sp),y
	iny
	ora     (sp),y
	beq     L120F
;
; lcl = local;
;
	jsr     ldaxysp
	ldy     #$10
	jsr     staxysp
;
; else if (output != NULL) {
;
	jmp     L1707
L120F:	ldy     #$12
	lda     (sp),y
	iny
	ora     (sp),y
	beq     L121A
;
; lcl = (struct tm *)malloc(sizeof(struct tm));
;
	ldx     #$00
	lda     #$12
	jsr     _malloc
	ldy     #$10
	jsr     staxysp
;
; if(lcl == NULL) {
;
	cpx     #$00
	bne     L1220
	cmp     #$00
;
; return FALSE;
;
	jeq     L1208
;
; memcpy((void*)lcl, (void*)localtime(now), sizeof(struct tm));
;
L1220:	ldy     #$11
	jsr     ldaxysp
L1707:	jsr     pushax
	ldy     #$1B
	jsr     ldaxysp
	jsr     _localtime
	jsr     pushax
	ldx     #$00
	lda     #$12
	jsr     _memcpy
;
; if(utc != NULL) {
;
L121A:	ldy     #$14
	lda     (sp),y
	iny
	ora     (sp),y
	beq     L1229
;
; gm = utc;
;
	jsr     ldaxysp
	ldy     #$0E
	jsr     staxysp
;
; else if(output != NULL) {
;
	jmp     L1708
L1229:	ldy     #$12
	lda     (sp),y
	iny
	ora     (sp),y
	beq     L1234
;
; gm = (struct tm *)malloc(sizeof(struct tm));
;
	ldx     #$00
	lda     #$12
	jsr     _malloc
	ldy     #$0E
	jsr     staxysp
;
; if(gm == NULL) {
;
	cpx     #$00
	bne     L123A
	cmp     #$00
	bne     L123A
;
; if(local == NULL) {
;
	ldy     #$16
	lda     (sp),y
	iny
	ora     (sp),y
	bne     L16FA
;
; free((void*)lcl);
;
	ldy     #$11
	jsr     ldaxysp
	jsr     _free
;
; return FALSE;
;
	ldx     #$00
L16FA:	txa
	jmp     L1208
;
; memcpy((void*)gm, (void*)gmtime(now), sizeof(struct tm));
;
L123A:	ldy     #$0F
	jsr     ldaxysp
L1708:	jsr     pushax
	ldy     #$1B
	jsr     ldaxysp
	jsr     _gmtime
	jsr     pushax
	ldx     #$00
	lda     #$12
	jsr     _memcpy
;
; if(output != NULL) {
;
L1234:	ldy     #$12
	lda     (sp),y
	iny
	ora     (sp),y
	jeq     L1248
;
; hourlcl = lcl->tm_hour;
;
	ldy     #$11
	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	ldy     #$0C
	jsr     staxysp
;
; hourutc = gm->tm_hour;
;
	ldy     #$0F
	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	ldy     #$0A
	jsr     staxysp
;
; output2 = (char*)realloc((void*)*output, 6);
;
	ldy     #$13
	jsr     ldaxysp
	jsr     pushw
	ldx     #$00
	lda     #$06
	jsr     _realloc
	ldy     #$02
	jsr     staxysp
;
; if(output2 == NULL) {
;
	cpx     #$00
	bne     L1253
	cmp     #$00
	bne     L1253
;
; if(local == NULL) {
;
	ldy     #$16
	lda     (sp),y
	iny
	ora     (sp),y
	bne     L1256
;
; free((void*)lcl);
;
	ldy     #$11
	jsr     ldaxysp
	jsr     _free
;
; if(utc == NULL) {
;
L1256:	ldy     #$14
	lda     (sp),y
	iny
	ora     (sp),y
	bne     L125B
;
; free((void*)gm);
;
	ldy     #$0F
	jsr     ldaxysp
	jsr     _free
;
; return FALSE;
;
L125B:	ldx     #$00
	txa
	jmp     L1208
;
; *output = output2;
;
L1253:	ldy     #$13
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$03
	jsr     ldaxysp
	ldy     #$00
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; if(lcl->tm_year > gm->tm_year) {
;
	ldy     #$11
	jsr     ldaxysp
	ldy     #$0B
	jsr     pushwidx
	ldy     #$11
	jsr     ldaxysp
	ldy     #$0B
	jsr     ldaxidx
	jsr     tosicmp
	bmi     L1263
	beq     L1263
;
; hourlcl+=24;
;
	ldy     #$0C
;
; else if (gm->tm_year > lcl->tm_year) {
;
	jmp     L16FD
L1263:	ldy     #$0F
	jsr     ldaxysp
	ldy     #$0B
	jsr     pushwidx
	ldy     #$13
	jsr     ldaxysp
	ldy     #$0B
	jsr     ldaxidx
	jsr     tosicmp
	bmi     L1268
;
; else if(lcl->tm_yday > gm->tm_yday) {
;
	bne     L1700
L1268:	ldy     #$11
	jsr     ldaxysp
	ldy     #$0F
	jsr     pushwidx
	ldy     #$11
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	jsr     tosicmp
	bmi     L126D
	beq     L126D
;
; hourlcl+=24;
;
	ldy     #$0C
;
; else if (gm->tm_yday > lcl->tm_yday) {
;
	jmp     L16FD
L126D:	ldy     #$0F
	jsr     ldaxysp
	ldy     #$0F
	jsr     pushwidx
	ldy     #$13
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	jsr     tosicmp
	bmi     L1272
	beq     L1272
;
; hourutc+=24;
;
L1700:	ldy     #$0A
L16FD:	ldx     #$00
	lda     #$18
	jsr     addeqysp
;
; difference = ((hourlcl - hourutc)*60)+lcl->tm_min - gm->tm_min;
;
L1272:	ldy     #$0D
	jsr     ldaxysp
	sec
	ldy     #$0A
	sbc     (sp),y
	pha
	txa
	iny
	sbc     (sp),y
	tax
	pla
	jsr     pushax
	lda     #$3C
	jsr     tosmula0
	jsr     pushax
	ldy     #$13
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	jsr     tosaddax
	jsr     pushax
	ldy     #$11
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	jsr     tossubax
	ldy     #$08
	jsr     staxysp
;
; minute_difference = difference % 60;
;
	jsr     pushax
	ldx     #$00
	lda     #$3C
	jsr     tosmoda0
	ldy     #$04
	jsr     staxysp
;
; hour_difference = (difference - minute_difference)/60;
;
	ldy     #$09
	jsr     ldaxysp
	sec
	ldy     #$04
	sbc     (sp),y
	pha
	txa
	iny
	sbc     (sp),y
	tax
	pla
	jsr     pushax
	lda     #$3C
	jsr     tosdiva0
	ldy     #$06
	jsr     staxysp
;
; if(hour_difference < 0) {
;
	cpx     #$80
	bcc     L127F
;
; format = "%03i%02i";
;
	lda     #<(L1282)
	ldx     #>(L1282)
	jsr     stax0sp
;
; sprintf(*output, format, hour_difference, minute_difference);
;
L127F:	ldy     #$13
	jsr     ldaxysp
	jsr     pushw
	ldy     #$05
	jsr     pushwysp
	ldy     #$0D
	jsr     pushwysp
	ldy     #$0D
	jsr     pushwysp
	ldy     #$08
	jsr     _sprintf
;
; if(local == NULL) {
;
L1248:	ldy     #$16
	lda     (sp),y
	iny
	ora     (sp),y
	bne     L1289
;
; free((void*)lcl);
;
	ldy     #$11
	jsr     ldaxysp
	jsr     _free
;
; if(utc == NULL) {
;
L1289:	ldy     #$14
	lda     (sp),y
	iny
	ora     (sp),y
	bne     L128E
;
; free((void*)gm);
;
	ldy     #$0F
	jsr     ldaxysp
	jsr     _free
;
; return TRUE;
;
L128E:	ldx     #$00
	lda     #$01
;
; }
;
L1208:	ldy     #$1A
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; __near__ struct resultColumnValue * __near__ getFirstRecord (__near__ struct resultTree *, __near__ struct qryData *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_getFirstRecord: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; if(root == NULL) {
;
	jsr     decsp2
	ldy     #$04
	lda     (sp),y
	iny
	ora     (sp),y
	bne     L170A
;
; return NULL;
;
	tax
	jmp     L1294
;
; currentResult = root;
;
L170A:	jsr     ldaxysp
;
; while(currentResult->left) {
;
	jmp     L170C
;
; currentResult = currentResult->left;
;
L170B:	jsr     ldaxysp
	jsr     ldaxi
L170C:	jsr     stax0sp
;
; while(currentResult->left) {
;
	ldy     #$00
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	iny
	ora     (ptr1),y
	bne     L170B
;
; return currentResult->columns;
;
	jsr     ldax0sp
	ldy     #$07
	jsr     ldaxidx
;
; }
;
L1294:	jsr     incsp6
	jmp     farret

.endproc

; ---------------------------------------------------------------
; void __near__ groupResultsInner (__near__ struct qryData *, __near__ struct resultColumnValue *, int)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_groupResultsInner: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; if(i) {
;
	jsr     decsp2
	ldy     #$03
	lda     (sp),y
	dey
	ora     (sp),y
	jeq     L12C9
;
; previousMatch = query->match;
;
	ldy     #$07
	jsr     ldaxysp
	ldy     #$27
	jsr     ldaxidx
	jsr     stax0sp
;
; query->match = columns;
;
	ldy     #$07
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$05
	jsr     ldaxysp
	ldy     #$26
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; (query->groupByClause != NULL &&   /* if no group by clause then every record is part of one group */
;
	ldy     #$07
	jsr     ldaxysp
	ldy     #$23
	jsr     ldaxidx
	cpx     #$00
	bne     L1711
	cmp     #$00
	beq     L170E
;
; (void *)previousMatch,
;
L1711:	jsr     pushw0sp
;
; (void *)query->match,
;
	ldy     #$09
	jsr     ldaxysp
	ldy     #$27
	jsr     pushwidx
;
; ) != 0) ||
;
	ldy     #$0B
	jsr     ldaxysp
	jsr     _recordCompare
	cpx     #$00
	bne     L1710
	cmp     #$00
	bne     L1710
;
; i == query->recordCount
;
L170E:	ldy     #$03
	jsr     ldaxysp
	sta     sreg
	stx     sreg+1
;
; ) {
;
	ldy     #$07
	jsr     ldaxysp
	ldy     #$09
	jsr     ldaxidx
	cpx     sreg+1
	bne     L12A9
	cmp     sreg
	bne     L12A9
;
; getGroupedColumns(query);
;
L1710:	ldy     #$07
	jsr     ldaxysp
	jsr     _getGroupedColumns
;
; getCalculatedColumns(query, previousMatch, TRUE);
;
	ldy     #$09
	jsr     pushwysp
	ldy     #$05
	jsr     pushwysp
	ldx     #$00
	lda     #$01
	jsr     _getCalculatedColumns
;
; query->useGroupBy = FALSE;
;
	ldy     #$07
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$0C
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; tree_insert(query, previousMatch, &(query->resultSet));
;
	ldy     #$09
	jsr     pushwysp
	ldy     #$05
	jsr     pushwysp
	ldy     #$0B
	jsr     ldaxysp
	ldy     #$24
	jsr     incaxy
	jsr     _tree_insert
;
; query->useGroupBy = TRUE;
;
	ldy     #$07
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$01
	ldy     #$0C
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; else {
;
	jmp     L12C3
;
; cleanup_matchValues(query, &previousMatch);
;
L12A9:	ldy     #$09
	jsr     pushwysp
	lda     #$02
	jsr     leaa0sp
	jsr     _cleanup_matchValues
;
; free(previousMatch);
;
	jsr     ldax0sp
	jsr     _free
;
; if(i < query->recordCount) {
;
L12C3:	ldy     #$05
	jsr     pushwysp
	ldy     #$09
	jsr     ldaxysp
	ldy     #$09
	jsr     ldaxidx
	jsr     tosicmp
	bpl     L12C9
;
; updateRunningCounts(query, query->match);
;
	ldy     #$09
	jsr     pushwysp
	ldy     #$09
	jsr     ldaxysp
	ldy     #$27
	jsr     ldaxidx
	jsr     _updateRunningCounts
;
; }
;
L12C9:	jsr     incsp8
	jmp     farret

.endproc

; ---------------------------------------------------------------
; __near__ struct _FILE * __near__ skipBom (__near__ const unsigned char *, __near__ long *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_skipBom: near

.segment	"CODE"

;
; FILE *skipBom(const char *filename, long* offset) {
;
	jsr     pushax
;
; file = fopen(filename, "rb");
;
	jsr     decsp2
	ldy     #$07
	jsr     pushwysp
	lda     #<(L12D2)
	ldx     #>(L12D2)
	jsr     _fopen
	jsr     stax0sp
;
; if (file != NULL) {
;
	cpx     #$00
	bne     L1714
	cmp     #$00
	beq     L12D4
;
; if(fgetc(file) == 239 && fgetc(file) == 187 && fgetc(file) == 191) {
;
L1714:	jsr     ldax0sp
	jsr     _fgetc
	cpx     #$00
	bne     L12D7
	cmp     #$EF
	bne     L12D7
	jsr     ldax0sp
	jsr     _fgetc
	cpx     #$00
	bne     L12D7
	cmp     #$BB
	bne     L12D7
	jsr     ldax0sp
	jsr     _fgetc
	cpx     #$00
	bne     L12D7
	cmp     #$BF
	bne     L12D7
;
; if(offset) {
;
	ldy     #$03
	lda     (sp),y
	dey
	ora     (sp),y
	beq     L12ED
;
; *offset = 3;
;
	ldy     #$05
	jsr     pushwysp
	ldx     #$00
	stx     sreg
	stx     sreg+1
	lda     #$03
;
; return file;
;
	jmp     L1716
;
; fclose(file);
;
L12D7:	jsr     ldax0sp
	jsr     _fclose
;
; file = fopen(filename, "rb");
;
	ldy     #$07
	jsr     pushwysp
	lda     #<(L12EB)
	ldx     #>(L12EB)
	jsr     _fopen
	jsr     stax0sp
;
; if(offset) {
;
L12D4:	ldy     #$03
	lda     (sp),y
	dey
	ora     (sp),y
	beq     L12ED
;
; *offset = 0;
;
	ldy     #$05
	jsr     pushwysp
	ldx     #$00
	stx     sreg
	stx     sreg+1
	txa
L1716:	ldy     #$00
	jsr     steaxspidx
;
; return file;
;
L12ED:	jsr     ldax0sp
;
; }
;
	jsr     incsp6
	jmp     farret

.endproc

; ---------------------------------------------------------------
; long __near__ getUnicodeCharFast (__near__ __near__ unsigned char * *, __near__ __near__ unsigned char * *, int, __near__ int *, __near__ __near__ function returning void *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_getUnicodeCharFast: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; unsigned char *temp = (unsigned char *)(*(offset+plusBytes));
;
	ldy     #$05
	jsr     ldaxysp
	jsr     aslax1
	clc
	ldy     #$08
	adc     (sp),y
	pha
	txa
	iny
	adc     (sp),y
	tax
	pla
	jsr     pushw
;
; if(*temp < 0x80) {
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$80
	bcs     L12F6
;
; *bytesMatched = 1;
;
	ldy     #$05
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$01
	ldy     #$00
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; return (long)(*temp);
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	ldx     #$00
	lda     (ptr1),y
	jsr     aulong
	jsr     axulong
	jmp     L12F2
;
; else if(*temp < 0xE0) {
;
L12F6:	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$E0
	bcs     L12FD
;
; *bytesMatched = 2;
;
	ldy     #$05
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$02
	ldy     #$00
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; return (long)((*(temp) << 6) + *(temp+1)) - 0x3080;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     (ptr1,x)
	jsr     aslax4
	jsr     aslax2
	jsr     pushax
	ldy     #$03
	jsr     ldaxysp
	jsr     incax1
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     (ptr1,x)
	jsr     tosadda0
	jsr     axulong
	jsr     pusheax
	ldx     #$30
	lda     #$00
	sta     sreg
	jmp     L1719
;
; else if (*temp < 0xF0) {
;
L12FD:	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$F0
	jcs     L1307
;
; *bytesMatched = 3;
;
	ldy     #$05
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$03
	ldy     #$00
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; return ((long)(*temp) << 12) + ((long)(*(temp+1)) << 6) + (long)(*(temp+2)) - 0xE2080;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	ldx     #$00
	lda     (ptr1),y
	jsr     aulong
	jsr     axulong
	ldy     sreg
	sty     sreg+1
	stx     sreg
	tax
	lda     #$00
	jsr     asleax4
	jsr     pusheax
	ldy     #$05
	jsr     ldaxysp
	jsr     incax1
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	ldx     #$00
	lda     (ptr1),y
	jsr     aulong
	jsr     axulong
	jsr     asleax4
	jsr     asleax2
	jsr     tosaddeax
	jsr     pusheax
	ldy     #$05
	jsr     ldaxysp
	jsr     incax2
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	ldx     #$00
	lda     (ptr1),y
	jsr     aulong
	jsr     axulong
	jsr     tosaddeax
	jsr     pusheax
	ldx     #$20
	lda     #$0E
	sta     sreg
	lda     #$00
	jmp     L1719
;
; *bytesMatched = 4;
;
L1307:	ldy     #$05
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$04
	ldy     #$00
	sta     (ptr1),y
	iny
	lda     #$00
	sta     (ptr1),y
;
; return ((long)(*temp) << 18) + ((long)(*(temp+1)) << 12) + ((long)(*(temp+2)) << 6) + (*(temp+3)) - 0x3C82080;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	ldx     #$00
	lda     (ptr1),y
	jsr     aulong
	jsr     axulong
	stx     sreg+1
	sta     sreg
	lda     #$00
	tax
	jsr     asleax2
	jsr     pusheax
	ldy     #$05
	jsr     ldaxysp
	jsr     incax1
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	ldx     #$00
	lda     (ptr1),y
	jsr     aulong
	jsr     axulong
	ldy     sreg
	sty     sreg+1
	stx     sreg
	tax
	lda     #$00
	jsr     asleax4
	jsr     tosaddeax
	jsr     pusheax
	ldy     #$05
	jsr     ldaxysp
	jsr     incax2
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	ldx     #$00
	lda     (ptr1),y
	jsr     aulong
	jsr     axulong
	jsr     asleax4
	jsr     asleax2
	jsr     tosaddeax
	jsr     pusheax
	ldy     #$05
	jsr     ldaxysp
	jsr     incax3
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	ldx     #$00
	lda     (ptr1),y
	jsr     axulong
	jsr     tosaddeax
	jsr     pusheax
	ldx     #$20
	lda     #$C8
	sta     sreg
	lda     #$03
L1719:	sta     sreg+1
	lda     #$80
	jsr     tossubeax
;
; }
;
L12F2:	ldy     #$0C
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; void __near__ runCommand (__near__ unsigned char *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_runCommand: near

.segment	"CODE"

;
; void runCommand(char *string) {
;
	jsr     pushax
;
; }
;
	jsr     incsp2
	jmp     farret

.endproc

; ---------------------------------------------------------------
; __near__ struct hash4Entry * __near__ getLookupTableEntry (__near__ __near__ unsigned char * *, __near__ __near__ unsigned char * *, __near__ int *, __near__ __near__ function returning void *, int)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_getLookupTableEntry: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; struct hash4Entry *temp = NULL, *temp2 = NULL;
;
	jsr     push0
	jsr     push0
;
; int totalBytes = 0;
;
	jsr     push0
;
; if(isNumberWithGetByteLength(*offset, lastMatchedBytes, firstChar)) {
;
	ldy     #$0F
	jsr     ldaxysp
	jsr     pushw
	ldy     #$0F
	jsr     pushwysp
	ldy     #$0B
	jsr     ldaxysp
	jsr     _isNumberWithGetByteLength
	stx     tmp1
	ora     tmp1
	beq     L1331
;
; return &numberEntry;
;
	lda     #<(_numberEntry)
	ldx     #>(_numberEntry)
	jmp     L1325
;
; temp2 = temp;
;
L132F:	ldy     #$05
	jsr     ldaxysp
	ldy     #$02
	jsr     staxysp
;
; totalBytes += *lastMatchedBytes;
;
	ldy     #$0B
	jsr     ldaxysp
	jsr     ldaxi
	jsr     addeq0sp
;
; (*((int (*)(unsigned char **, unsigned char **, int,  int *, void (*)()))get))
;
	ldy     #$0B
;
; (offset, str, totalBytes, lastMatchedBytes, get);
;
	jsr     pushwysp
	ldy     #$13
	jsr     pushwysp
	ldy     #$13
	jsr     pushwysp
	ldy     #$09
	jsr     pushwysp
	ldy     #$15
	jsr     pushwysp
	ldy     #$13
	jsr     ldaxysp
	pha
	ldy     #$08
	lda     (sp),y
	sta     jmpvec+1
	iny
	lda     (sp),y
	sta     jmpvec+2
	pla
	jsr     jmpvec
	jsr     incsp2
;
; while((temp = in_word_set((char const *)(*offset), totalBytes+(*lastMatchedBytes)))) {
;
L1331:	ldy     #$0F
	jsr     ldaxysp
	jsr     pushw
	ldy     #$0D
	jsr     ldaxysp
	jsr     ldaxi
	clc
	ldy     #$02
	adc     (sp),y
	pha
	txa
	iny
	adc     (sp),y
	tax
	pla
	jsr     _in_word_set
	ldy     #$04
	jsr     staxysp
	stx     tmp1
	ora     tmp1
	bne     L132F
;
; if(temp2 != NULL) {
;
	ldy     #$02
	lda     (sp),y
	iny
	ora     (sp),y
	beq     L171A
;
; *lastMatchedBytes = totalBytes;
;
	ldy     #$0B
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	jsr     ldax0sp
	ldy     #$00
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; return temp2;
;
	ldy     #$03
L171A:	jsr     ldaxysp
;
; }
;
L1325:	ldy     #$10
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; int __near__ isNumberWithGetByteLength (__near__ unsigned char *, __near__ int *, int)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_isNumberWithGetByteLength: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; int decimalNotFound = TRUE;
;
	lda     #$01
	jsr     pusha0
;
; unsigned char *string = offset;
;
	ldy     #$09
	jsr     pushwysp
;
; (*offset >= '0' && *offset <= '9') ||
;
	ldy     #$09
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$30
	ldx     #$00
	bcc     L171B
	ldy     #$09
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$3A
	jcc     L1760
	ldx     #$00
;
; (firstChar && (
;
L171B:	ldy     #$05
	lda     (sp),y
	dey
	ora     (sp),y
	jeq     L13A0
;
; (*offset == '.' && (*(offset+1) >= '0' && *(offset+1) <= '9')) ||
;
	ldy     #$09
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$2E
	bne     L171C
	ldy     #$09
	jsr     ldaxysp
	jsr     incax1
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$30
	bcc     L171C
	ldy     #$09
	jsr     ldaxysp
	jsr     incax1
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$3A
	jcc     L1760
;
; (*offset == '-' && ((*(offset+1) >= '0' && *(offset+1) <= '9') || (*(offset+1) == '.' && (*(offset+2) >= '0' && *(offset+2) <= '9')))) ||
;
L171C:	ldy     #$09
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$2D
	bne     L171F
	ldy     #$09
	jsr     ldaxysp
	jsr     incax1
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$30
	bcc     L171D
	ldy     #$09
	jsr     ldaxysp
	jsr     incax1
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$3A
	jcc     L1760
L171D:	ldy     #$09
	jsr     ldaxysp
	jsr     incax1
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$2E
	bne     L171F
	ldy     #$09
	jsr     ldaxysp
	jsr     incax2
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$30
	bcc     L171F
	ldy     #$09
	jsr     ldaxysp
	jsr     incax2
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$3A
	jcc     L1760
;
; (*offset == '+' && ((*(offset+1) >= '0' && *(offset+1) <= '9') || (*(offset+1) == '.' && (*(offset+2) >= '0' && *(offset+2) <= '9'))))
;
L171F:	ldy     #$09
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     (ptr1,x)
	cmp     #$2B
	bne     L1751
	ldy     #$09
	jsr     ldaxysp
	jsr     incax1
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$30
	bcc     L1720
	ldy     #$09
	jsr     ldaxysp
	jsr     incax1
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$3A
	bcc     L1760
L1720:	ldy     #$09
	jsr     ldaxysp
	jsr     incax1
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     (ptr1,x)
	cmp     #$2E
	bne     L1749
	ldy     #$09
	jsr     ldaxysp
	jsr     incax2
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$30
	tya
	tax
	jcc     L13A0
	ldy     #$09
	jsr     ldaxysp
	jsr     incax2
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$3A
	bcc     L1760
	ldx     #$00
	txa
	jmp     L13A0
L1749:	txa
	jmp     L13A0
L1751:	txa
	jmp     L13A0
;
; if(*string == '-' || *string == '+') {
;
L1760:	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$2D
	beq     L138B
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$2B
	bne     L138D
;
; string++;
;
L138B:	jsr     ldax0sp
	jsr     incax1
	jsr     stax0sp
;
; (*string >= '0' && *string <= '9') ||
;
L138D:	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$30
	bcc     L1724
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$3A
	bcc     L138B
;
; (decimalNotFound && (*string == '.' || *string == ',') &&
;
L1724:	ldy     #$03
	lda     (sp),y
	dey
	ora     (sp),y
	beq     L1726
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$2E
	beq     L1765
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$2C
	bne     L1726
;
; !(decimalNotFound = FALSE))
;
L1765:	ldx     #$00
	txa
	ldy     #$02
	jsr     staxysp
	jmp     L138B
;
; *(lastMatchedBytes)+=(string-offset)-1;
;
L1726:	ldy     #$07
	jsr     ldaxysp
	jsr     pushax
	jsr     ldaxi
	sta     ptr1
	stx     ptr1+1
	ldy     #$03
	jsr     ldaxysp
	sec
	ldy     #$0A
	sbc     (sp),y
	pha
	txa
	iny
	sbc     (sp),y
	tax
	pla
	jsr     decax1
	clc
	adc     ptr1
	pha
	txa
	adc     ptr1+1
	tax
	pla
	ldy     #$00
	jsr     staxspidx
;
; return TRUE;
;
	ldx     #$00
	lda     #$01
;
; }
;
L13A0:	ldy     #$0A
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; void __near__ cleanup_resultColumns (__near__ struct resultColumn *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_cleanup_resultColumns: near

.segment	"CODE"

;
; void cleanup_resultColumns(struct resultColumn *currentResultColumn) {
;
	jsr     pushax
;
; while(currentResultColumn != NULL) {
;
	jsr     decsp2
	jmp     L13AF
;
; next = currentResultColumn->nextColumnInResults;
;
L1772:	jsr     ldaxysp
	ldy     #$17
	jsr     ldaxidx
	jsr     stax0sp
;
; free(currentResultColumn->resultColumnName);
;
	ldy     #$03
	jsr     ldaxysp
	ldy     #$13
	jsr     ldaxidx
	jsr     _free
;
; free(currentResultColumn);
;
	ldy     #$03
	jsr     ldaxysp
	jsr     _free
;
; currentResultColumn = next;
;
	jsr     ldax0sp
	ldy     #$02
	jsr     staxysp
;
; while(currentResultColumn != NULL) {
;
L13AF:	ldy     #$02
	lda     (sp),y
	iny
	ora     (sp),y
	bne     L1772
;
; }
;
	jsr     incsp4
	jmp     farret

.endproc

; ---------------------------------------------------------------
; int __near__ strAppend (unsigned char, __near__ __near__ unsigned char * *, __near__ unsigned int *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_strAppend: near

.segment	"CODE"

;
; int strAppend(char c, char **value, size_t *strSize) {
;
	jsr     pushax
;
; if(strSize != NULL) {
;
	jsr     decsp2
	ldy     #$02
	lda     (sp),y
	iny
	ora     (sp),y
	beq     L13BB
;
; if(value != NULL) {
;
	iny
	lda     (sp),y
	iny
	ora     (sp),y
	beq     L13CF
;
; if((temp = realloc(*value, (*strSize)+1)) != NULL) {
;
	jsr     ldaxysp
	jsr     pushw
	ldy     #$05
	jsr     ldaxysp
	jsr     ldaxi
	jsr     incax1
	jsr     _realloc
	jsr     stax0sp
	cpx     #$00
	bne     L1773
	cmp     #$00
	beq     L13BA
;
; *value = temp;
;
L1773:	ldy     #$05
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	jsr     ldax0sp
	ldy     #$00
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; (*value)[*strSize] = c;
;
	ldy     #$05
	jsr     ldaxysp
	jsr     ldaxi
	sta     sreg
	stx     sreg+1
	ldy     #$03
	jsr     ldaxysp
	jsr     ldaxi
	clc
	adc     sreg
	sta     ptr1
	txa
	adc     sreg+1
	sta     ptr1+1
	ldy     #$06
	lda     (sp),y
	ldy     #$00
	sta     (ptr1),y
;
; (*strSize)++;
;
L13CF:	ldy     #$03
	jsr     ldaxysp
	jsr     pushax
	jsr     ldaxi
	jsr     incax1
	ldy     #$00
	jsr     staxspidx
;
; return TRUE;
;
L13BB:	ldx     #$00
	lda     #$01
;
; }
;
L13BA:	jsr     incsp7
	jmp     farret

.endproc

; ---------------------------------------------------------------
; int __near__ d_sprintf (__near__ __near__ unsigned char * *, __near__ unsigned char *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_d_sprintf: near

.segment	"CODE"

;
; int d_sprintf(char **str, char *format, ...) {
;
	jsr     enter
;
; char *newStr = NULL;
;
	jsr     decsp2
	jsr     push0
;
; if(str == NULL || format == NULL) {
;
	jsr     decsp2
	ldy     #$06
	lda     (sp),y
	jsr     leaa0sp
	jsr     incax5
	jsr     ldaxi
	cpx     #$00
	bne     L1775
	cmp     #$00
	jeq     L13D4
L1775:	ldy     #$06
	lda     (sp),y
	jsr     leaa0sp
	jsr     incax3
	jsr     ldaxi
	cpx     #$00
	bne     L13D6
	cmp     #$00
	jeq     L13D4
;
; va_start(args, format);
;
L13D6:	ldy     #$06
	lda     (sp),y
	jsr     leaa0sp
	jsr     incax3
	jsr     stax0sp
;
; newSize = (size_t)(vsnprintf(NULL, 0, format, args)+1); /* plus '\0' */
;
	jsr     push0
	jsr     push0
	ldy     #$0A
	lda     (sp),y
	jsr     leaa0sp
	jsr     incax7
	jsr     pushw
	ldy     #$07
	jsr     ldaxysp
	jsr     _vsnprintf
	jsr     incax1
	ldy     #$04
	jsr     staxysp
;
; if((newStr = (char*)malloc(newSize)) == NULL) {
;
	jsr     _malloc
	ldy     #$02
	jsr     staxysp
	cpx     #$00
	bne     L13E7
	cmp     #$00
;
; return FALSE;
;
	beq     L13D4
;
; va_start(args, format);
;
L13E7:	ldy     #$06
	lda     (sp),y
	jsr     leaa0sp
	jsr     incax3
	jsr     stax0sp
;
; vsprintf(newStr, format, args);
;
	ldy     #$05
	jsr     pushwysp
	ldy     #$08
	lda     (sp),y
	jsr     leaa0sp
	jsr     incax5
	jsr     pushw
	ldy     #$05
	jsr     ldaxysp
	jsr     _vsprintf
;
; newStr[newSize] = '\0';
;
	ldy     #$05
	jsr     ldaxysp
	clc
	ldy     #$02
	adc     (sp),y
	sta     ptr1
	txa
	iny
	adc     (sp),y
	sta     ptr1+1
	lda     #$00
	tay
	sta     (ptr1),y
;
; free(*str);
;
	ldy     #$06
	lda     (sp),y
	jsr     leaa0sp
	jsr     incax5
	jsr     ldaxi
	jsr     ldaxi
	jsr     _free
;
; *str = newStr;
;
	ldy     #$06
	lda     (sp),y
	jsr     leaa0sp
	jsr     incax5
	jsr     pushw
	ldy     #$05
	jsr     ldaxysp
	ldy     #$00
	jsr     staxspidx
;
; return newSize;
;
	ldy     #$05
	jsr     ldaxysp
;
; }
;
L13D4:	ldy     #$06
	jsr     leavey
	jmp     farret

.endproc

; ---------------------------------------------------------------
; int __near__ hash_addString (__near__ struct columnReferenceHash *, __near__ unsigned char *, __near__ struct columnReference *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_hash_addString: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; unsigned int hashval = hash_compare(hashtable, str);
;
	jsr     decsp4
	ldy     #$0B
	jsr     pushwysp
	ldy     #$09
	jsr     ldaxysp
	jsr     _hash_compare
	jsr     pushax
;
; current_list = hash_lookupString(hashtable, str);
;
	ldy     #$0D
	jsr     pushwysp
	ldy     #$0B
	jsr     ldaxysp
	jsr     _hash_lookupString
	ldy     #$04
	jsr     staxysp
;
; if (current_list != NULL) {
;
	cpx     #$00
	bne     L1778
	cmp     #$00
	beq     L1779
;
; return 2;
;
L1778:	ldx     #$00
	lda     #$02
	jmp     L13FE
;
; if ((new_list2 = malloc(sizeof(struct columnRefHashEntry))) == NULL) {
;
L1779:	lda     #$06
	jsr     _malloc
	ldy     #$02
	jsr     staxysp
	cpx     #$00
	bne     L140A
	cmp     #$00
	bne     L140A
;
; return 1;
;
	lda     #$01
	jmp     L13FE
;
; new_list2->referenceName = str;
;
L140A:	ldy     #$03
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$09
	jsr     ldaxysp
	ldy     #$00
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; new_list2->content = new_list;
;
	ldy     #$03
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$07
	jsr     ldaxysp
	ldy     #$02
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; new_list2->nextReferenceInHash = hashtable->table[hashval];
;
	jsr     ldaxysp
	sta     sreg
	stx     sreg+1
	ldy     #$0B
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	sta     ptr1
	stx     ptr1+1
	jsr     ldax0sp
	jsr     aslax1
	clc
	adc     ptr1
	pha
	txa
	adc     ptr1+1
	tax
	pla
	jsr     ldaxi
	ldy     #$04
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; hashtable->table[hashval] = new_list2;
;
	ldy     #$0B
	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	sta     ptr1
	stx     ptr1+1
	jsr     ldax0sp
	jsr     aslax1
	clc
	adc     ptr1
	sta     ptr1
	txa
	adc     ptr1+1
	sta     ptr1+1
	ldy     #$03
	jsr     ldaxysp
	ldy     #$00
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; return 0;
;
	ldx     #$00
	txa
;
; }
;
L13FE:	ldy     #$0C
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; void __near__ strFree (__near__ __near__ unsigned char * *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_strFree: near

.segment	"CODE"

;
; void strFree(char **str) {
;
	jsr     pushax
;
; free(*str);
;
	jsr     ldax0sp
	jsr     ldaxi
	jsr     _free
;
; *str = NULL;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	tay
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; }
;
	jsr     incsp2
	jmp     farret

.endproc

; ---------------------------------------------------------------
; void __near__ getGroupedColumns (__near__ struct qryData *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_getGroupedColumns: near

.segment	"CODE"

;
; void getGroupedColumns(struct qryData *query) {
;
	jsr     pushax
;
; for(i = 0; i < query->columnReferenceHashTable->size; i++) {
;
	jsr     decsp8
	ldx     #$00
	txa
L1787:	jsr     stax0sp
	jsr     pushax
	ldy     #$0B
	jsr     ldaxysp
	ldy     #$17
	jsr     ldaxidx
	jsr     ldaxi
	jsr     tosicmp
	jpl     L1423
;
; currentHashEntry = query->columnReferenceHashTable->table[i];
;
	ldy     #$09
	jsr     ldaxysp
	ldy     #$17
	jsr     ldaxidx
	ldy     #$03
	jsr     ldaxidx
	sta     ptr1
	stx     ptr1+1
	jsr     ldax0sp
	jsr     aslax1
	clc
	adc     ptr1
	pha
	txa
	adc     ptr1+1
	tax
	pla
	ldy     #$01
;
; while(currentHashEntry != NULL) {
;
	jmp     L1784
;
; currentReference = currentHashEntry->content;
;
L177D:	jsr     ldaxysp
	ldy     #$03
;
; while(currentReference != NULL) {
;
	jmp     L1785
;
; currentReference->referenceType == REF_EXPRESSION &&
;
L177E:	jsr     ldaxysp
	ldy     #$03
	jsr     ldaxidx
	cpx     #$00
	jne     L1444
	cmp     #$02
	jne     L1444
;
; (currentResultColumn = currentReference->reference.calculatedPtr.firstResultColumn) != NULL &&
;
	ldy     #$05
	jsr     ldaxysp
	ldy     #$07
	jsr     ldaxidx
	ldy     #$02
	jsr     staxysp
	cpx     #$00
	bne     L177F
	cmp     #$00
	jeq     L1444
;
; currentResultColumn->groupType != GRP_NONE
;
L177F:	ldy     #$03
	jsr     ldaxysp
	ldy     #$07
	jsr     ldaxidx
;
; ) {
;
	cpx     #$00
	bne     L143A
	cmp     #$00
	jeq     L1444
;
; switch(currentResultColumn->groupType) {
;
L143A:	ldy     #$03
	jsr     ldaxysp
	ldy     #$07
	jsr     ldaxidx
;
; }
;
	cpx     #$00
	jne     L1444
	cmp     #$01
	beq     L1446
	cmp     #$04
	beq     L1450
	cmp     #$05
	jeq     L1464
	cmp     #$07
	jeq     L146E
	cmp     #$08
	beq     L1446
	cmp     #$0B
	beq     L1450
	cmp     #$0C
	beq     L1464
	jmp     L1444
;
; currentResultColumn->groupCount);
;
L1446:	ldy     #$05
	jsr     pushwysp
	ldy     #$05
	jsr     ldaxysp
	ldy     #$0D
	jsr     ldeaxidx
	jsr     pusheax
	ldy     #$09
	jsr     ldaxysp
	ldy     #$0F
	jsr     ldaxidx
	jsr     axlong
	jsr     __fdiv
	ldy     #$0A
	jsr     steaxspidx
;
; ftostr(&(currentResultColumn->groupText),currentResultColumn->groupNum);
;
L1450:	ldy     #$03
	jsr     ldaxysp
	jsr     incax8
	jsr     pushax
	ldx     #$00
	lda     #$21
	jsr     _reallocMsg
	ldy     #$03
	jsr     ldaxysp
	jsr     incax8
	jsr     pushw
	ldy     #$05
	jsr     ldaxysp
	ldy     #$0D
	jsr     ldeaxidx
	jsr     __ftostr
	ldy     #$03
	jsr     ldaxysp
	jsr     incax8
	jsr     pushax
	ldy     #$05
	jsr     ldaxysp
	jsr     incax8
	jsr     ldaxi
	jsr     _strlen
	jsr     incax1
	jsr     _reallocMsg
;
; break;
;
	jmp     L1444
;
; d_sprintf(&(currentResultColumn->groupText), "%d", currentResultColumn->groupCount);
;
L1464:	ldy     #$03
	jsr     ldaxysp
	jsr     incax8
	jsr     pushax
	lda     #<(L146A)
	ldx     #>(L146A)
	jsr     pushax
	ldy     #$07
	jsr     ldaxysp
	ldy     #$0F
;
; break;
;
	jmp     L1788
;
; d_sprintf(&(currentResultColumn->groupText), "%d", query->groupCount);
;
L146E:	ldy     #$03
	jsr     ldaxysp
	jsr     incax8
	jsr     pushax
	lda     #<(L1472)
	ldx     #>(L1472)
	jsr     pushax
	ldy     #$0D
	jsr     ldaxysp
	ldy     #$0B
L1788:	jsr     pushwidx
	ldy     #$06
	jsr     _d_sprintf
;
; currentReference = currentReference->nextReferenceWithName;
;
L1444:	ldy     #$05
	jsr     ldaxysp
	ldy     #$09
L1785:	jsr     ldaxidx
	ldy     #$04
	jsr     staxysp
;
; while(currentReference != NULL) {
;
	ldy     #$04
	lda     (sp),y
	iny
	ora     (sp),y
	jne     L177E
;
; currentHashEntry = currentHashEntry->nextReferenceInHash;
;
	ldy     #$07
	jsr     ldaxysp
	ldy     #$05
L1784:	jsr     ldaxidx
	ldy     #$06
	jsr     staxysp
;
; while(currentHashEntry != NULL) {
;
	ldy     #$06
	lda     (sp),y
	iny
	ora     (sp),y
	jne     L177D
;
; for(i = 0; i < query->columnReferenceHashTable->size; i++) {
;
	jsr     ldax0sp
	sta     regsave
	stx     regsave+1
	jsr     incax1
	jmp     L1787
;
; }
;
L1423:	ldy     #$0A
	jsr     addysp
	jmp     farret

.endproc

; ---------------------------------------------------------------
; void __near__ yyerror2 (long, __near__ unsigned char *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_yyerror2: near

.segment	"CODE"

;
; void yyerror2(long lineno, char *text) {
;
	jsr     pushax
;
; fprintf(stderr, TDB_LEX_UNTERMINATED);
;
	lda     _stderr
	ldx     _stderr+1
	jsr     pushax
	lda     #<(L147C)
	ldx     #>(L147C)
	jsr     pushax
	ldy     #$09
	jsr     ldeaxysp
	jsr     pusheax
	ldy     #$0B
	jsr     pushwysp
	ldy     #$0A
	jsr     _fprintf
;
; }
;
	jsr     incsp6
	jmp     farret

.endproc

; ---------------------------------------------------------------
; void __near__ cleanup_orderByClause (__near__ struct sortingList *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_cleanup_orderByClause: near

.segment	"CODE"

;
; void cleanup_orderByClause(struct sortingList *currentSortingList) {
;
	jsr     pushax
;
; while(currentSortingList != NULL) {
;
	jsr     decsp2
	jmp     L1483
;
; next = currentSortingList->nextInList;
;
L1789:	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	jsr     stax0sp
;
; cleanup_expression(currentSortingList->expressionPtr);
;
	ldy     #$03
	jsr     ldaxysp
	jsr     ldaxi
	jsr     _cleanup_expression
;
; free(currentSortingList);
;
	ldy     #$03
	jsr     ldaxysp
	jsr     _free
;
; currentSortingList = next;
;
	jsr     ldax0sp
	ldy     #$02
	jsr     staxysp
;
; while(currentSortingList != NULL) {
;
L1483:	ldy     #$02
	lda     (sp),y
	iny
	ora     (sp),y
	bne     L1789
;
; }
;
	jsr     incsp4
	jmp     farret

.endproc

; ---------------------------------------------------------------
; void __near__ cleanup_matchValues (__near__ struct qryData *, __near__ __near__ struct resultColumnValue * *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_cleanup_matchValues: near

.segment	"CODE"

;
; ) {
;
	jsr     pushax
;
; for(i = 0, len = query->columnCount; i < len; i++) {
;
	jsr     decsp4
	ldx     #$00
	txa
	ldy     #$02
	jsr     staxysp
	ldy     #$07
	jsr     ldaxysp
	ldy     #$05
	jsr     ldaxidx
	ldy     #$00
L178B:	jsr     staxysp
	ldy     #$03
	jsr     ldaxysp
	ldy     #$00
	cmp     (sp),y
	txa
	iny
	sbc     (sp),y
	bvc     L178A
	eor     #$80
L178A:	bpl     L1490
;
; free((*match)[i].value);
;
	ldy     #$05
	jsr     ldaxysp
	jsr     pushw
	ldy     #$07
	jsr     pushwysp
	lda     #$0E
	jsr     tosmula0
	jsr     tosaddax
	ldy     #$0D
	jsr     ldaxidx
	jsr     _free
;
; for(i = 0, len = query->columnCount; i < len; i++) {
;
	ldy     #$03
	jsr     ldaxysp
	jsr     incax1
	ldy     #$02
	jmp     L178B
;
; free(*match);
;
L1490:	ldy     #$05
	jsr     ldaxysp
	jsr     ldaxi
	jsr     _free
;
; *match = NULL;
;
	ldy     #$05
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	tay
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; }
;
	jsr     incsp8
	jmp     farret

.endproc

