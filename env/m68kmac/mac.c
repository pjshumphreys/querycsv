/*  macos.c  Macintosh Toolbox/Carbon support functions  using only API compatible with System 1.0  Use Macintosh Programmer's Workshop to build  using the Makefile in this folder.  Compiles for:    m68k: Toolbox, System 1 - Mac OS 9.2.2    ppc: Carbon CFM, Mac OS 8.1 - Mac OS X v10.6    i386: Carbon Mach-O, Mac OS X v10.4 - 10.10 */#define OLDROUTINENAMES 1#include <stdio.h>#include <stdlib.h>#include <signal.h>#include <ctype.h>#if TARGET_API_MAC_CARBON#if __MACH__#include <Carbon/Carbon.h>#else#include <Carbon.h>#endif#else#include <Quickdraw.h>#include <MacWindows.h>#include <Dialogs.h>#include <Menus.h>#include <ToolUtils.h>#include <Devices.h>#include <Drag.h>#include <AppleEvents.h>#include <Gestalt.h>#include <DiskInit.h>#endif#include <SIO.h>#define TARGET_API_MAC_TOOLBOX (!TARGET_API_MAC_CARBON)#if TARGET_API_MAC_TOOLBOX#define GetWindowPort(w) wQDGlobals qd;   /* qd is needed by the Macintosh runtime */#endif#include "mac.h"enum {	sApplicationName = 1,	sTranslationLockedErr,	sTranslationErr,	sOpeningErr,	sReadErr,				// 5	sWriteToBusyFileErr,	sBusyOpen,	sChooseFile,	sChooseFolder,	sChooseVolume,			// 10	sCreateFolder,	sChooseObject,	sSaveCopyMessage,	slSavePromptIndex,	slClosingIndex,			// 15	slQuittingIndex,	sAddRemoveTitle,	sLowMemoryErr};/*  A DocumentRecord contains the WindowRecord for one of our document windows,  as well as the TEHandle for the text we are editing. Other document fields  can be added to this record as needed. For a similar example, see how the  Window Manager and Dialog Manager add fields after the GrafPort.*/typedef struct {  WindowRecord  docWindow;  TEHandle      docTE;  ControlHandle docVScroll;  ControlHandle docHScroll;  ProcPtr       docClik;} DocumentRecord, *DocumentPeek;#define APP_NAME_STRING "\pQueryCSV"#define SCREEN_WIDTH 320#define SCREEN_HEIGHT 320#define BITMAP_SIZE 16#define	rAppStringsID			128#define kOpenPrefKey			1#define	kMaxDocumentCount		100		// maximum number of documents allowed#define TRUE 1#define FALSE 0/* TODO: do something about these ugly global variables. What are they even for anyway? */WindowPtr mainWindowPtr;const short appleM = 0;const short fileM = 1;const short editM = 2;const short fontM = 3;const short sizeM = 4;int quit = FALSE;int windowNotOpen = TRUE;char *progArg = NULL;/*  gInBackground is maintained by our OSEvent handling routines. Any part of  the program can check it to find out if it is currently in the background.  It is maintained by Initialize and DoEvent*/Boolean gInBackground;/*	kMaxDocWidth is an arbitrary number used to specify the width of the TERec's	destination rectangle so that word wrap and horizontal scrolling can be	demonstrated. */#define	kMaxDocWidth			576/* kMinDocDim is used to limit the minimum dimension of a window when GrowWindow	is called. */#define	kMinDocDim				64/*	kCrChar is used to match with a carriage return when calculating the	number of lines in the TextEdit record. kDelChar is used to check for	delete in keyDowns. */#define kCrChar					13#define kDelChar				8/*	kControlInvisible is used to 'turn off' controls (i.e., cause the control not	to be redrawn as a result of some Control Manager call such as SetCtlValue)	by being put into the contrlVis field of the record. kControlVisible is used	the same way to 'turn on' the control. */#define kControlInvisible		0#define kControlVisible			0xFF/*	kScrollbarAdjust and kScrollbarWidth are used in calculating	values for control positioning and sizing. */#define kScrollbarWidth			16#define kScrollbarAdjust		(kScrollbarWidth - 1)/*  A reference to our assembly language routine that gets attached to the clikLoop  field of our TE record.*/extern pascal void AsmClikLoop(void);/* Check to see if a window belongs to a desk accessory. */Boolean isDeskAccessory(WindowPtr window) {  /* DA windows have negative windowKinds */  return window == nil?false:(((WindowPeek)window)->windowKind < 0);}/* Check to see if a window is an application one (???). */Boolean isApplicationWindow(WindowPtr window) {  /* application windows have windowKinds = userKind (8) */  return window == nil?false:(((WindowPeek)window)->windowKind == userKind);}Rect getScreenBounds() {	Rect r;	BitMap theScreenBits;#if TARGET_API_MAC_CARBON	GetQDGlobalsScreenBits(&theScreenBits); /* carbon accessor */	r = theScreenBits.bounds;#else	r = qd.screenBits.bounds;#endif	return r;}void alertUser(short error) {  Str255  message;  SetCursor(&qd.arrow);  /* type Str255 is an array in MPW 3 */  GetIndString(message, kErrStrings, error);  ParamText(message, (unsigned char *)"", (unsigned char *)"", (unsigned char *)"");  Alert(rUserAlert, nil);}static pascal OSErr appleEventOpenApp(    const AppleEvent *theAppleEvent,    AppleEvent *reply,    long handlerRefCon) {  return noErr;}static pascal OSErr appleEventPrintDoc(    const AppleEvent *theAppleEvent,    AppleEvent *reply,    long handlerRefCon) {  return noErr;}static pascal OSErr appleEventOpenDoc(    const AppleEvent *theAppleEvent,    AppleEvent *reply,    long handlerRefCon) {  AEDescList  docList;  AEKeyword   keyword;  DescType    returnedType;  FSSpec      theFSSpec;  Size        actualSize;  long        itemsInList;  long        index;  OSErr       result;  if(      (result = AEGetParamDesc(        theAppleEvent,        keyDirectObject,        typeAEList,        &docList      ) != 0) ||      (result = AECountItems(&docList, &itemsInList)) != 0  ) {    return result;  }  for(index = 1; index <= itemsInList; index++) {    if(result = AEGetNthPtr(        &docList,        index,        typeFSS,        &keyword,        &returnedType,        (Ptr)&theFSSpec,        sizeof(FSSpec),        &actualSize    )) {      return result;    }    //Spin up a thread. set the volume and folder for that thread also    if(windowNotOpen) {      windowNotOpen = FALSE;    }    else {      Alert(rAboutAlert, nil);    }  }  return noErr;}static pascal OSErr appleEventQuit(    const AppleEvent *appleEvt,    AppleEvent* reply,    long refcon  ) {  quit = 1;  return noErr;}void setupAppleEvents() {  long result;  if(    Gestalt(gestaltAppleEventsAttr, &result) != noErr ||  /* Problem calling Gestalt or */    (result & (1 << gestaltAppleEventsPresent)) == 0      /* test the 0th bit of the result. If it is zero then Apple events is not available */  ) {    return;  }  if(    AEInstallEventHandler(        kCoreEventClass,        kAEOpenApplication,        NewAEEventHandlerProc(appleEventOpenApp),        0,        false      ) != noErr ||    AEInstallEventHandler(        kCoreEventClass,        kAEOpenDocuments,        NewAEEventHandlerProc(appleEventOpenDoc),        0,        false      ) != noErr ||    AEInstallEventHandler(        kCoreEventClass,        kAEPrintDocuments,        NewAEEventHandlerProc(appleEventPrintDoc),        0,        false      ) != noErr ||    AEInstallEventHandler(        kCoreEventClass,        kAEQuitApplication,        NewAEEventHandlerProc(appleEventQuit),        0,        false      ) != noErr  ) {    raise(SIGABRT);  }}void setupMenus() {  long result;  MenuRef menu;  MenuHandle myMenus[5];  int i;  myMenus[appleM] = GetMenu(mApple);#if TARGET_API_MAC_TOOLBOX  AddResMenu(myMenus[appleM],'DRVR'); // System-provided Desk Accessories menu#endif  myMenus[appleM] = GetMenu(mApple);  myMenus[fileM]  = GetMenu(mFile);  myMenus[editM]  = GetMenu(mEdit);  myMenus[fontM]  = GetMenu(mFont);  myMenus[sizeM]  = GetMenu(mSize);  for(i = 0; i < 5; i++) {    InsertMenu(myMenus[i], 0);  }#if TARGET_API_MAC_CARBON  /* In OS X, 'Quit' moves from File to the Application Menu */  if(      Gestalt(gestaltMenuMgrAttr, &result) == noErr &&      (result & gestaltMenuMgrAquaLayoutMask) != 0    ) {    menu = GetMenuHandle(mFile);    DeleteMenuItem(menu, mFileQuit);  }#endif  menu = GetMenuHandle(mFont);  AppendResMenu(menu, 'FONT');  DrawMenuBar();}void adjustCursor(Point mouse, RgnHandle region) {  WindowPtr   window;  RgnHandle   arrowRgn;  RgnHandle   iBeamRgn;  Rect        iBeamRect;  window = FrontWindow();   /* we only adjust the cursor when we are in front */  if (!gInBackground && !isDeskAccessory(window)) {    /* calculate regions for different cursor shapes */    arrowRgn = NewRgn();    iBeamRgn = NewRgn();    /* start arrowRgn wide open */    SetRectRgn(arrowRgn, kExtremeNeg, kExtremeNeg, kExtremePos, kExtremePos);    /* calculate iBeamRgn */    if (isApplicationWindow(window)) {      iBeamRect = (*((DocumentPeek) window)->docTE)->viewRect;            SetPort(window);        /* make a global version of the viewRect */      LocalToGlobal(&TopLeft(iBeamRect));      LocalToGlobal(&BotRight(iBeamRect));      RectRgn(iBeamRgn, &iBeamRect);      /* we temporarily change the port's origin to 'globalfy' the visRgn */      SetOrigin(-window->portBits.bounds.left, -window->portBits.bounds.top);      SectRgn(iBeamRgn, window->visRgn, iBeamRgn);      SetOrigin(0, 0);    }    /* subtract other regions from arrowRgn */    DiffRgn(arrowRgn, iBeamRgn, arrowRgn);    /* change the cursor and the region parameter */    if (PtInRgn(mouse, iBeamRgn)) {      SetCursor(*GetCursor(iBeamCursor));      CopyRgn(iBeamRgn, region);    }    else {      SetCursor(&qd.arrow);      CopyRgn(arrowRgn, region);    }    DisposeRgn(arrowRgn);    DisposeRgn(iBeamRgn);  }}void adjustMenus() {	MenuHandle menu;	menu = GetMenuHandle(mFile);	if(!windowNotOpen) {		DisableItem(menu, mFileOpen);    menu = GetMenuHandle(mEdit);    EnableItem(menu, mEditSelectAll);    //if(textSelected) {      //EnableItem(menu, mEditCopy);    //}    //else {      //DisableItem(menu, mEditCopy);    //}  }}void adjustTE(WindowPtr window) {  TEPtr te;          te = *((DocumentPeek)window)->docTE;  TEScroll(    te->viewRect.left -    te->destRect.left -    GetControlValue(((DocumentPeek)window)->docHScroll),    te->viewRect.top -    te->destRect.top -    (GetControlValue(((DocumentPeek)window)->docVScroll) * te->lineHeight),    ((DocumentPeek)window)->docTE  );}void adjustViewRect(TEHandle docTE) {  TEPtr te;          te = *docTE;  te->viewRect.bottom = (    (      (        te->viewRect.bottom - te->viewRect.top      ) / te->lineHeight    ) * te->lineHeight  ) +  te->viewRect.top;}void adjustHV(Boolean isVert, ControlHandle control, TEHandle docTE, Boolean canRedraw) {  short oldValue, oldMax, value, max, lines;  TEPtr te = *docTE;          oldValue = GetControlValue(control);  oldMax = GetControlMaximum(control);                                                         if (isVert) {    lines = te->nLines;    if (*(*te->hText + te->teLength - 1) == kCrChar) {      lines += 1;    }        max = lines - ((te->viewRect.bottom - te->viewRect.top) / te->lineHeight);  }  else {    max = kMaxDocWidth - (te->viewRect.right - te->viewRect.left);  }    if (max < 0) {    max = 0;  }    SetControlMaximum(control, max);  if (isVert) {    value = (te->viewRect.top - te->destRect.top) / te->lineHeight;  }  else {    value = te->viewRect.left - te->destRect.left;  }    if (value < 0) {    value = 0;  }  else if (value > max) {    value = max;  }    SetControlValue(control, value);  if (      canRedraw ||      max != oldMax ||      value != oldValue  ) {    ShowControl(control);  }}void adjustScrollbarValues(WindowPtr window, Boolean canRedraw) {  DocumentPeek doc = (DocumentPeek)window;  adjustHV(true,  doc->docVScroll, doc->docTE, canRedraw);  adjustHV(false, doc->docHScroll, doc->docTE, canRedraw);}void adjustScrollbars(WindowPtr window, Boolean needsResize) {  DocumentPeek doc;  Rect teRect;    doc = (DocumentPeek) window;  /* First, turn visibility of scrollbars off so we won't get unwanted redrawing */  (*doc->docVScroll)->contrlVis = kControlInvisible;  (*doc->docHScroll)->contrlVis = kControlInvisible;  if (needsResize) {    /* move & size as needed */    /* start with TERect */    GetTERect(window, &teRect);                                                            (*doc->docTE)->viewRect = teRect;    /* snap to nearest line */    adjustViewRect(doc->docTE);                                                            MoveControl(doc->docVScroll, window->portRect.right - kScrollbarAdjust, -1);    SizeControl(        doc->docVScroll,        kScrollbarWidth,        window->portRect.bottom - window->portRect.top - kScrollbarAdjust - kScrollTweek      );          MoveControl(doc->docHScroll, -1, window->portRect.bottom - kScrollbarAdjust);    SizeControl(        doc->docHScroll,        window->portRect.right - window->portRect.left - kScrollbarAdjust - kScrollTweek,        kScrollbarWidth      );  }    adjustScrollbarValues(window, needsResize);                        /* fool with max and current value */  /* Now, restore visibility in case we never had to ShowControl during adjustment */  (*doc->docVScroll)->contrlVis = kControlVisible;        /* turn them on */  (*doc->docHScroll)->contrlVis = kControlVisible;}#if TARGET_API_MAC_TOOLBOX#include <StandardFile.h>OSStatus openFileDialog() {  Point       where;  unsigned const char prompt = '\0';  OSType      typeList = 'TEXT';  SFReply     reply;  OSErr       result;  where.h = where.v = 70;  SFGetFile(where, &prompt, nil, 1, &typeList, nil, &reply);  if(reply.good) {    result = SetVol(reply.fName, reply.vRefNum);    if(result != 0) {      /* error check */    }    windowNotOpen = FALSE;  }  return noErr;}#endif#if TARGET_API_MAC_CARBON#endifvoid openWindow() {  Ptr storage;  WindowPtr window;  DocumentPeek doc;  Rect viewRect, destRect;  Boolean proceed;  /* Attempt to allocate some memory to bind the generic window to TextEdit functionality */  storage = NewPtr(sizeof(DocumentRecord));  if (storage == nil) {    /* abort the program */    raise(SIGABRT);    /* The raising of the abort signal should mean we never get here, but just in case */    return;  }  /* attempt to create the window that will contain program output */  window = GetNewWindow(rDocWindow, storage, (WindowPtr)-1);  if (window == nil) {    /* get rid of the storage if it is never used */    DisposePtr(storage);    /* abort the program */    raise(SIGABRT);    /* The raising of the abort signal should mean we never get here, but just in case */    return;  }  /* set the port (Mac OS boilerplate?) */  SetPort(GetWindowPort(window));  /*    cast the window instance into a DocumentPeek structure,    so we can set up the TextEdit related fields  */  doc = (DocumentPeek)window;  /* TEXTEDIT STUFF begins here  ******************************/  /* set up the textedit content size (not the viewport) rectangle */  GetTERect(window, &viewRect);  destRect = viewRect;  destRect.right = destRect.left + kMaxDocWidth;  /*    attempt to create a TextEdit control and bind    it to our window/document structure  */  doc->docTE = TENew(&destRect, &viewRect);  /*only proceed if the TextEdit control was successfully created */  proceed = doc->docTE != nil;  if(proceed) {    /* fix up the TextEdit view? */    adjustViewRect(doc->docTE);    TEAutoView(true, doc->docTE);   /*TEAutoView controls automatic scrolling */    /*      backup the original click loop routine then substitute our own.      It seems our substitute routine has to be written in      assembly language as "registers need to be mucked with" (???)    */    doc->docClik = (ProcPtr) (*doc->docTE)->clickLoop;    (*doc->docTE)->clickLoop = (TEClickLoopUPP) AsmClikLoop;    /* Attempt to setup vertical scrollbar control */    doc->docVScroll = GetNewControl(rVScroll, window);    proceed = (doc->docVScroll != nil);  }  if (proceed) {    /* Attempt to setup horizontal scrollbar control */    doc->docHScroll = GetNewControl(rHScroll, window);    proceed = (doc->docHScroll != nil);  }  if (proceed) {    /*      Adjust & draw the controls, then show the window.      False to adjustScrollValues means musn't redraw; technically, of course,      the window is hidden so it wouldn't matter whether we called ShowControl or not.    */    adjustScrollValues(window, false);    ShowWindow(window);  }  else {    /*      Something failed in the window creation process.      Clean up then tell the user what happened    */    closeWindow(window);    alertUser(eNoWindow);    /* abort the program */    raise(SIGABRT);  }}void idleWindow() {  WindowPtr window = FrontWindow();  if(window != nil) {    IdleControls(window);            if (isApplicationWindow(window)) {      TEIdle(((DocumentPeek) window)->docTE);    }  }}void repaintWindow(WindowPtr window) {  Rect tempRect;  if (isApplicationWindow(window)) {    BeginUpdate(window);    /* draw if updating needs to be done */    if (!EmptyRgn(window->visRgn)) {        #if TARGET_API_MAC_TOOLBOX      tempRect = qd.thePort->portRect;#else      GetWindowPortBounds(window, &tempRect);#endif      SetPort(window);      EraseRect(&tempRect);      DrawControls(window);      DrawGrowIcon(window);      TEUpdate(&tempRect, ((DocumentPeek)window)->docTE);    }    EndUpdate(window);  }}void activateWindow(WindowPtr window, Boolean becomingActive) {  RgnHandle     tempRgn, clipRgn;  Rect          growRect;  DocumentPeek  doc;          if (isApplicationWindow(window)) {    doc = (DocumentPeek) window;    if (becomingActive) {      /*        since we don't want TEActivate to draw a selection in an area where        we're going to erase and redraw, we'll clip out the update region        before calling it.      */      tempRgn = NewRgn();      clipRgn = NewRgn();      /* get localized update region */      GetLocalUpdateRgn(window, tempRgn);                              GetClip(clipRgn);      /* subtract updateRgn from clipRgn */      DiffRgn(clipRgn, tempRgn, tempRgn);                              SetClip(tempRgn);      TEActivate(doc->docTE);      /* restore the full-blown clipRgn */      SetClip(clipRgn);                                                              DisposeRgn(tempRgn);      DisposeRgn(clipRgn);            /* the controls must be redrawn on activation: */      (*doc->docVScroll)->contrlVis = kControlVisible;      (*doc->docHScroll)->contrlVis = kControlVisible;      InvalRect(&(*doc->docVScroll)->contrlRect);      InvalRect(&(*doc->docHScroll)->contrlRect);      /* the growbox needs to be redrawn on activation: */      growRect = window->portRect;      /* adjust for the scrollbars */      growRect.top = growRect.bottom - kScrollbarAdjust;      growRect.left = growRect.right - kScrollbarAdjust;      InvalRect(&growRect);    }    else {                      TEDeactivate(doc->docTE);      /* the controls must be hidden on deactivation: */      HideControl(doc->docVScroll);      HideControl(doc->docHScroll);      /* the growbox should be changed immediately on deactivation: */      DrawGrowIcon(window);    }  }}void resizedWindow(WindowPtr window) {  adjustScrollbars(window, true);  adjustTE(window);  InvalRect(&window->portRect);}void growWindow(WindowPtr window) {  long         growResult;  Rect         tempRect;  RgnHandle    tempRgn;  DocumentPeek doc;          /* set up limiting values */  tempRect = getScreenBounds();      tempRect.left = kMinDocDim;  tempRect.top = kMinDocDim;    growResult = GrowWindow(window, event->where, &tempRect);  /* see if it really changed size */  if (growResult != 0) {    doc = (DocumentPeek) window;    /* save old text box */    tempRect = (*doc->docTE)->viewRect;       tempRgn = NewRgn();    /* get localized update region */    GetLocalUpdateRgn(window, tempRgn);       SizeWindow(window, LoWord(growResult), HiWord(growResult), true);    resizedWindow(window);    /* calculate & validate the region that hasn't changed so it won't get redrawn */    SectRect(&tempRect, &(*doc->docTE)->viewRect, &tempRect);    /* take it out of update */    ValidRect(&tempRect);       /* put back any prior update */    InvalRgn(tempRgn);          DisposeRgn(tempRgn);  }}void zoomWindow(WindowPtr window, short part) {  EraseRect(&window->portRect);  ZoomWindow(window, part, window == FrontWindow());  resizedWindow(window);}void closeWindow(WindowPtr window) {  TEHandle te;  if (isDeskAccessory(window)) {    CloseDeskAcc(((WindowPeek) window)->windowKind);  }  else if (isApplicationWindow(window)) {    te = ((DocumentPeek) window)->docTE;    if (te != nil) {      /* dispose the TEHandle if we got far enough to make one */      TEDispose(te);    }    /*      calling DisposeWindow here would be technically incorrect,      even though we allocated storage for the window on the heap.      We instead call CloseWindow to have the structures taken      care of and then dispose of the storage ourselves.    */    CloseWindow(window);    DisposePtr((Ptr)window);    /*      As we only only ever have 1 application window, if it's      closed then we quit the application    */    quit = 1;  }}/*  Gets called from our assembly language routine, AsmClikLoop, which is in  turn called by the TEClick toolbox routine. Saves the windows clip region,  sets it to the portRect, adjusts the scrollbar values to match the TE scroll  amount, then restores the clip region.*/pascal void PascalClikLoop(void) {  WindowPtr window;  RgnHandle region;  window = FrontWindow();  region = NewRgn();  GetClip(region);  ClipRect(&window->portRect);  adjustScrollbarValues(window, true);  SetClip(region);  DisposeRgn(region);}/*  Gets called from our assembly language routine, AsmClikLoop, which is in  turn called by the TEClick toolbox routine. It returns the address of the  default clikLoop routine that was put into the TERec by TEAutoView to  AsmClikLoop so that it can call it.*/pascal ProcPtr GetOldClikLoop(void) {  return ((DocumentPeek)FrontWindow())->docClik;}/* Handles clicking on menus or keyboard shortcuts */void menuSelect(long mResult) {  short theItem;  short theMenu;  Str255 daName;  theItem = LoWord(mResult);  theMenu = HiWord(mResult);  switch(theMenu) {    case mApple: {      if(theItem == mAppleAbout) {        Alert(rAboutAlert, nil);      }#if TARGET_API_MAC_TOOLBOX      else {        /* all non-About items in this menu are Desk Accessories */        /* type Str255 is an array in MPW 3 */        GetMenuItemText(GetMenuHandle(mApple), theItem, daName);        OpenDeskAcc(daName);      }#endif    } break;    case mFile: {      switch(theItem) {        case mFileOpen: {          if(windowNotOpen) {            openFileDialog();          }        } break;        case mFileQuit: {          quit = 1;        } break;      }    } break;    case mEdit: {      switch(theItem) {        case mEditCopy: {        } break;        case mEditSelectAll: {        } break;      }    } break;    case mFont: {      switch(theItem) {        default: {        } break;      }    } break;    case mSize: {      switch(theItem) {        default: {        } break;      }    } break;  }  HiliteMenu(0);}/* Handles mouse down events */void mouseDown(EventRecord *event) {  WindowPtr window;  Rect tempRect;  short part;  switch(FindWindow(event->where, &window)) {    case inContent: {      if(window != FrontWindow()) {        SelectWindow(window);      }    } break;    case inMenuBar: {      adjustMenus();      menuSelect(MenuSelect(event->where));    } break;    case inDrag: {      tempRect = getScreenBounds();      DragWindow(window, event->where, &tempRect);    } break;    case inGoAway: {      if(TrackGoAway(window, event->where)) {        closeWindow(window);      }    } break;    case inGrow: {      growWindow(window, event);    } break;    case inZoomIn:    case inZoomOut: {      if(TrackBox(window, event->where, part)) {        zoomWindow(window, part);      }    } break;#if TARGET_API_MAC_TOOLBOX    case inSysWindow: { // Click happens in a Desk Accessory      SystemClick(event, window);    } break;#endif  }}void loopTick() {  EventRecord event;#if TARGET_API_MAC_TOOLBOX  SystemTask();#endif  GetNextEvent(everyEvent, &event);  switch(event.what) {    case nullEvent: {      idleWindow();    } break;    case updateEvt: {      repaintWindow((WindowPtr)event->message);    } break;    case mouseDown: {      mouseDown(&event);    } break;    case keyDown: {      if(event.modifiers & cmdKey) {        adjustMenus();        menuSelect(MenuKey(event.message & charCodeMask));      }    } break;    case activateEvt: {      activateWindow((WindowPtr)event.message, (event.modifiers & activeFlag) != 0);    } break;    case kHighLevelEvent: {      AEProcessAppleEvent(&event);    } break;    case diskEvt: {      if((event.message & 0xFFFF0000) != noErr) {        DILoad();        DIBadMount({70, 70}, event.message);        DIUnload();      }    } break;    case kOSEvent: {      switch ((event->message >> 24) & 0x0FF) {        case kMouseMovedMessage: {          DoIdle();        } break;                case kSuspendResumeMessage: {          gInBackground = (event->message & kResumeMask) == 0;          activateWindow(FrontWindow(), !gInBackground);        } break;      }    } break;  }}/*  if you're looking for the main() function, this is it.  the runtime libraries in MPW provide hooks that allow  you to setup the mac boilerplate.*/pascal void sioDemoInit(int *mainArgc, char ***mainArgv) {	static char progName[] = "querycsv";	static char* argv[3];#if TARGET_API_MAC_TOOLBOX  MaxApplZone();  InitGraf((Ptr)&qd.thePort);  InitFonts();  InitWindows();  InitMenus();  TEInit();  InitDialogs(nil);#endif  InitCursor();  FlushEvents(everyEvent, 0);  setupAppleEvents();  setupMenus();	*mainArgc = 1;	argv[0] = progName;	argv[1] = NULL;	argv[2] = NULL;	*mainArgv = argv;  gInBackground = false;  while(!quit && windowNotOpen) {    loopTick();  }  if(!windowNotOpen) {    openWindow();    *mainArgc = 2;    argv[1] = progArg;  }  if(quit) {		raise(SIGABRT);	}}/* our program will be getting all its input from the file whose name is passed to main, so just return end of file */pascal void sioDemoRead(  char *buffer,  long nCharsDesired,  long *nCharsUsed,  short *eofFlag) {  *eofFlag = true;  *nCharsUsed = 0;}pascal void sioDemoWrite(SInt16 filenum, char *buffer, SInt32 nChars) {	if(filenum == kSIOStdOutNum) {		//output( buffer, nChars, blackColor, gStdOutWindow );	}	else if(filenum == kSIOStdErrNum) {		//output( buffer, nChars, redColor, gStdOutWindow );	}	loopTick(); // get one event	if(quit)	{		raise(SIGABRT); // does not return to sioDemoRead...	}}pascal void sioDemoExit(void) {  free(progArg);  while(!quit) {		// loop until user quits.		loopTick();	};	__sioInit = 0;	__sioRead = 0;	__sioWrite = 0;	__sioExit = 0;}pascal void (*__sioInit)(int *mainArgc, char ***mainArgv) = sioDemoInit;pascal void (*__sioRead)(    char    *buffer,    SInt32 	nCharsDesired,    SInt32 	*nCharsUsed,    SInt16 	*eofFlag  ) = sioDemoRead;pascal void (*__sioWrite)(SInt16 filenum, char *buffer, SInt32 nChars) = sioDemoWrite;pascal void (*__sioExit)(void) = sioDemoExit;int main(int argc, char **argv) {  printf("hello");  return 0;}