/*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
if (!String.fromCodePoint) {
	(function() {
		var defineProperty = (function() {
			/*  IE 8 only supports `Object.defineProperty` on DOM elements */
			try {
				var object = {};
				var $defineProperty = Object.defineProperty;
				var result = $defineProperty(object, object, object) && $defineProperty;
			} catch(error) {}
			return result;
		}());
		var stringFromCharCode = String.fromCharCode;
		var floor = Math.floor;
		var fromCodePoint = function(codePoints) {
			var MAX_SIZE = 0x4000;
			var codeUnits = [];
			var highSurrogate;
			var lowSurrogate;
			var index = -1;
			var length = arguments.length;
			if (!length) {
				return '';
			}
			var result = '';
			while (++index < length) {
				var codePoint = Number(arguments[index]);
				if (
					!isFinite(codePoint) || /*  `NaN`, `+Infinity`, or `-Infinity` */
					codePoint < 0 || /*  not a valid Unicode code point */
					codePoint > 0x10FFFF || /*  not a valid Unicode code point */
					floor(codePoint) != codePoint /*  not an integer */
				) {
					throw RangeError('Invalid code point: ' + codePoint);
				}
				if (codePoint <= 0xFFFF) { /*  BMP code point */
					codeUnits.push(codePoint);
				} else { /*  Astral code point; split in surrogate halves */
					/*  http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae */
					codePoint -= 0x10000;
					highSurrogate = (codePoint >> 10) + 0xD800;
					lowSurrogate = (codePoint % 0x400) + 0xDC00;
					codeUnits.push(highSurrogate, lowSurrogate);
				}
				if (index + 1 == length || codeUnits.length > MAX_SIZE) {
					result += stringFromCharCode.apply(null, codeUnits);
					codeUnits.length = 0;
				}
			}
			return result;
		};
		if (defineProperty) {
			defineProperty(String, 'fromCodePoint', {
				'value': fromCodePoint,
				'configurable': true,
				'writable': true
			});
		} else {
			String.fromCodePoint = fromCodePoint;
		}
	}());
}

if (!Array.prototype.filter) {
  Array.prototype.filter = function(fun/*, thisArg*/) {
    'use strict';

    if (this === void 0 || this === null) {
      throw new TypeError();
    }

    var t = Object(this);
    var len = t.length >>> 0;
    if (typeof fun !== 'function') {
      throw new TypeError();
    }

    var res = [];
    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
    for (var i = 0; i < len; i++) {
      if (i in t) {
        var val = t[i];

        /*  NOTE: Technically this should Object.defineProperty at */
        /*        the next index, as push can be affected by */
        /*        properties on Object.prototype and Array.prototype. */
        /*        But that method's new, and collisions should be */
        /*        rare, so use the more-compatible alternative. */
        if (fun.call(thisArg, val, i, t)) {
          res.push(val);
        }
      }
    }

    return res;
  };
}

/* read file as JSON, parse it */
var fs = require('fs');

var data = JSON.parse(fs.readFileSync("./filtered4.json", 'utf8'));

var i, len;

var string = "/*unicode normalization mapping table*/\n\
static const long\n";

/*
data = data.filter(function(elem){
return (elem[2].indexOf("ARABIC") === -1 && elem[2].indexOf("MATHEMATICAL") === -1 && elem[2].indexOf("CJK COMPATIBILITY") === -1);
});
*/

/* use fromcodepoint to write to the file in utf-8 */
for(i = 0, len = data.length; i < len; i++) {
  string+= 'hash2_' + (i+1) + "[] = {0x" + data[i][1].replace(/ /g, ", 0x") + '},  /* '+ data[i][2] + "\n"; */
}

string += "\nstatic const struct hash2Entry hash2["+data.length+"] = {\n";
for(i = 0, len = data.length; i < len; i++) {
  string += '{0x' +
    /* String.fromCodePoint(parseInt( */
    data[i][0]+/* , 16)) + */
    ', ' +
    data[i][1].split(" ").length +
    ', hash2_'+(i+1)+ '},  /*'+ data[i][2] + "*/\n";
}
string += '};';

fs.writeFileSync('./hash2.h', string, 'utf8');



